---
title: url输入后发生什么
---

# 这是老经典的题了：浏览器输入url后发生了什么事

[[toc]]

![image-20211112103143396](https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103143396.png)



## 大致流程

1. 浏览器进程发出<u>URL请求</u>给网络进程
2. 网络进程接收到URL请求后，<u>发起网络请求</u>，然后服务器返回HTTP数据到网络进程，网络进程<u>解析HTTP响应头数据</u>，并将其<u>转发</u>给浏览器进程
3. 浏览器进程接收到网络进程的响应头数据后，<u>发送CommitNavigation消息</u>到渲染进程，发送CommitNavigation时会<u>携带响应头等基本信息</u>。
4. 渲染进程接收到CommitNavigation消息之后，便开始<u>准备接收HTML数据</u>，接收数据的方式是直接和网络进程建立<u>数据管道</u>
5. 最后渲染进程会向浏览器进程“<u>确认提交</u>”，这是告诉浏览器进程，说我已经<u>准备好接收和解析页面数据</u>了
6. 最后浏览器进程<u>更新页面状态</u>

## 分析每个流程

### 用户输入URL

浏览器的地址栏会判断所输入的内容是<u>搜索</u>还是<u>网址</u>

- 如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；

- 如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL，比如输入`www.baidu.com` 地址栏会根据规则，把这段内容加上协议，合成完整的URL，如`https://www.baidu.com`

补充：

- 用户输入完内容，按下回车键，浏览器导航栏显示<u>loading状态</u>，但是页面还是呈现前一个页面，这是<u>因为新页面的响应数据还没有获得</u>。

- 这里面有个<u>beforeunload事件</u>，该事件允许页面退出之前执行一些数据的<u>清理操作</u>，还可以询问用户是否要离开当前页面，比如当前页面有未提交的表单，用户可以通过beforeunload事件来取消导航，让浏览器不在进行后续工作。

### URL 请求过程

- 浏览器进程将构建请求行数据，进行<u>进程间通信（IPC）</u>将URL请求发送给网络进程，类似于下面这个：

```http
GET /index.html HTTP1.1
```

- 网络进程获取到URL，先去<u>本地缓存</u>（也叫浏览器缓存，浏览器缓存是在磁盘中的）中查找是否有缓存文件（hosts文件优先级比本地缓存高，<u>先查找hosts文件再看本地缓存</u>），如果有，拦截请求，直接200返回；否则，进入网络请求过程（具体看[浏览器缓存](./浏览器缓存.md)）
- 网络进程向<u>本地DNS服务器</u>请求该域名对应的<u>IP和端口号</u>，如果之前<u>DNS数据缓存服务</u>缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，<u>http默认80</u>，<u>https默认443</u>。如果是https请求，还需要建立<u>TLS连接</u>。（具体看[DNS解析原理](./DNS解析原理)）
- 在进程TCP连接的过程中，Chrome有个机制，同一个域名下最多只能建立<u>6个TCP连接</u>，如果在同一个域名下有10个请求发生，那么其中4个请求会进入等待转台，直至进行中的请求完成。如果请求个数小于6，会直接建立TCP连接。
- <u>TCP三次握手建立连接</u>，http请求<u>加上TCP头部</u>——包括<u>源端口号</u>、<u>目的程序端口号</u>和<u>用于校验数据完整性的序号</u>，向下传输。
- <u>网络层</u>在数据包上<u>加上IP头部</u>——包括<u>源IP地址</u>和<u>目的IP地址</u>，继续向下传输到底层
- 底层通过<u>物理网络传输</u>给目的服务器主机，紧接着目的服务器主机网络层<u>接收到数据包</u>，<u>解析出IP头部</u>，识别出数据部分，将解开的数据包向上传输到传输层。
- 目的服务器主机传输层获取到数据包，<u>解析出TCP头部</u>，<u>识别端口</u>，将解开的数据包向上传输到应用层
- 应用层HTTP<u>解析请求头和请求体</u>
  - 如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；
  - 如果不是重定向，首先服务器会根据请求头中的If-None-Match 的值来判断请求的资源是否被更新
  - 如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；
  - 否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：
    ```http
    Cache-Control:Max-age=2000
    ```

- 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程

- 数据<u>传输完成</u>，TCP四次挥手<u>断开连接</u>。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提高资源加载速度

	```http
	Connection:Keep-Alive
	```

- 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来<u>判断响应数据的类型</u>，如果是<u>字节流类型</u>，就将该请求<u>交给下载管理器</u>；如果是<u>text/html类型</u>，就通知浏览器进程<u>获取文档准备渲染</u>



![image-20211112103153704](https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103153704.png)

![image-20211112103158988](https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103158988.png)



- 从返回的响应头信息来看，其 Content-Type 的值是 application/octet-stream，显示数据是<u>字节流类型</u>的，通常情况下，浏览器会按照下载类型来处理该请求。需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

- 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（<u>根域名和协议一样</u>就被认为是同一个站点），如果满足上述条件，就<u>复用</u>之前网页的进程，否则，<u>新创建</u>一个单独的渲染进程。

- 浏览器会<u>发出“提交文档”的消息</u>给渲染进程，渲染进程收到消息后，会和网络进程<u>建立传输数据的“管道”</u>，文档数据传输完成后，渲染进程会<u>返回“确认提交”的消息</u>给浏览器进程。

- 浏览器<u>收到“确认提交”的消息</u>后，会<u>更新浏览器的页面状态</u>，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页。这也解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

![image-20211112103204834](https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103204834.png)

- 渲染进程<u>对文档进行页面解析和子资源加载</u>，HTML 通过HTML 解析器转成<u>DOM Tree</u>（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成<u>CSSOM Tree</u>，两个tree结合，形成<u>render tree</u>（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以<u>计算</u>出每个元素具体的宽高颜色位置，结合起来，开始<u>绘制</u>，最后显示在屏幕中新页面显示出来。（具体看[浏览器渲染原理](./浏览器渲染原理.md)）

## 参考

> [「浏览器工作原理」写给女友的秘籍-浏览器组成&网络请求篇（1.2W字)](https://juejin.cn/post/6846687590540640263#heading-33)
>
> [从输入URL到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)
>
> [导航流程：从输入URL到页面展示，这中间发生了什么？](https://time.geekbang.org/column/article/117637)
>
> [浏览器的工作原理：现代网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browsers_we_will_talk_about)

