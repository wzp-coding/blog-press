---
title: 知识点
---

## vite基本原理

```html
// index.html
<div id="app"></div>
<script type="module">
  import { createApp } from 'vue'
  import Main from './Main.vue'

  createApp(Main).mount('#app')
</script>
```

Vite 会在本地帮你启动一个服务器，当浏览器读取到这个 html 文件之后，会在执行到 import 的时候才去向服务端发送 `Main.vue` 模块的请求，Vite 此时在利用内部的一系列黑魔法，包括 Vue 的 template 解析，代码的编译等等，解析成浏览器可以执行的 js 文件返回到浏览器端。

这就保证了只有在真正使用到这个模块的时候，浏览器才会请求并且解析这个模块，最大程度的做到了按需加载。

## 依赖预编译

依赖预编译，其实是 Vite 2.0 在为用户启动开发服务器之前，先用 `esbuild` 把检测到的依赖预先构建了一遍。

> 当你用 `import { debounce } from 'lodash'` 导入一个命名函数的时候，可能你理想中的场景就是浏览器去下载只包含这个函数的文件。但其实没那么理想，`debounce` 函数的模块内部又依赖了很多其他函数，形成了一个依赖图。
>
> 当浏览器请求 `debounce` 的模块时，又会发现内部有 2 个 `import`，再这样延伸下去，这个函数内部竟然带来了 600 次请求，耗时会在 1s 左右。
>
> 这当然是不可接受的，于是尤老师想了个折中的办法，正好利用 [Esbuild](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fevanw%2Fesbuild) 接近无敌的构建速度，让你在没有感知的情况下在启动的时候预先帮你把 `debounce` 所用到的所有内部模块全部打包成一个传统的 `js bundle`。
>
> `Esbuild` 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

大致过程：在 `httpServer.listen` 启动开发服务器之前，会进行依赖预构建步骤，根据本次运行的入口文件来扫描其中的依赖，之后再根据分析出来的依赖，使用ESbuild把它们打包成单文件的bunble，之后在浏览器请求相关模块时，返回这个预构建好的模块

在预构建这个步骤中，还会对 `CommonJS` 模块进行分析，方便后面需要统一处理成浏览器可以执行的 `ES Module`。

## 什么是Tree shaking？

Treeshaking是一个术语，通常用于描述移除[JavaScript](https://so.csdn.net/so/search?q=JavaScript&spm=1001.2101.3001.7020)上下文中的未引用代码(dead-code)，就像一棵大树，将那些无用的叶子都摇掉。
它依赖于ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具rollup。

## Tree shaking的原理

使用Tree shaking的原理是ES6的模块静态分析引入，这就可以在编译时正确判断到底加载了什么代码，但是要注意import 和export是ES6原生的而不是通过babel或者webpack转化的

## Tree shaking 与 按需引入的区别？

按需引入是在babel编译过程中，其本质是在babel编译阶段将部分代码做了替换

Tree shaking是在webpack打包阶段，移除 JavaScript 上下文中的未引用代码

## vue3使用Proxy代替Object.defineProperty的好处

vue2中Object.defineProperty的缺陷:

1. 无法原生监听数组的变化，需要特殊处理
2. 必须遍历对象的每个属性（当示例初始化的时，Object.definePropety是从data的根节点遍历到末节点。一次性遍历全部)
3. 无法监听属性的新增删除操作（VUE提供Vue.set Vue.delete API，原因就是因为Object.definePropety无法监听新增删除操作）

Proxy对象是ES2015（ES6）引入的一个原生对象，proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截。因此它能监听数组，监听新增删除操作，深层遍历嵌套的对象等。

但因为浏览器兼容所限，使用proxy会放弃对于IE的支持，vue只能使用Object.defineProperty实现双向绑定。这在当时是一种很前卫的设计，不过随着浏览器的不断迭代，这种技术在api和性能上愈发跟不上时代的步调。

到目前为止，各大主流移动端浏览器，PC端浏览器，包括新一代window产品内置Microsoft Edge都满足对于Vue3的支持。其次，若真的需要满足支持IE及极少数低版本浏览器，还可以使用垫片工具（es6-proxy-polyfill）。

## 组合式API（Composition API）好处

- 使复杂组件的逻辑更紧凑，而且可以将公共逻辑进行抽取，提高代码逻辑的可复用性，从而实现与模板的无关性
- 对 tree-shaking 友好，使代码的可压缩性更强。