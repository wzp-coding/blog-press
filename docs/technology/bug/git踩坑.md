---
title: git踩坑
---
[[toc]]

## 起因

事情是这样的，我在公司开发项目的时候，我之前**多次在本地commit，然后push到远程分支dev**，然后我一直继续这样做项目，直到我完成了某个需求后，组长叫我push到远程分支dev，再提个mr(gitlab的merge request)，之后他看完没问题再同意这个mr将远程分支dev合并到远程主分支master，但是事情不是那么顺利，组长看完跟我说**提交多了**(也就是除去这个需求还有其它不必要的文件或代码)，因为我是同时开发多个需求的，这样会导致我commit很多次而且杂乱无章，我于是想办法**能不能将远程分支dev回退到原始版本，再将我后面写完的代码提交，再规范一下commit消息，再push到远程分支dev，再提mr？**

## 如何处理？

> 必知：git分为：工作区，暂存区，版本库
>
> 工作区：就是你在电脑里能看到的目录。
>
> 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。
>
> 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。
>
> 对应到常用开发的三个操作
>
> ​	`git add .` 将工作区修改的文件提交到暂存区
>
> ​	`git commit -m '注释'` 将暂存区的文件提交到本地版本库
>
> ​	`git push` 将本地版本库同步到远程版本库

**怕后悔的话**，新建一个分支进行操作

```shell
git checkout -b tmp
```

此时我们已经建立并切换到tmp分支，比如你之前在dev分支，此时你可以理解为复制了dev分支的所有文件，之后在tmp分支上的一切操作都不会影响到dev分支，这样一旦后悔了，直接切换到dev分支然后删除tmp分支即可

接下来，我在tmp分支上进行一系列的测试

我查了一下git回退版本的命令，分为回退本地版本和回退远程版本

```shell
git reset [--soft | --mixed | --hard] [HEAD]
```

> `--mixed` 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。
>
> `--soft` 参数用于回退到某个版本
>
> `--hard` 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：

![img](/images/webp)

结合图片我们可以直观的看到，我们需要的是不删除文件的前提下，撤销commit，也就是`--mixed`模式，也就是默认模式

回退的时候，我们需要找到最原始的版本的对应的哈希值

```shell
git log #显示当前分支所有提交过的版本信息，不包括已经被删除的 commit 记录和reset的操作
git reflog #显示所有分支的所有操作记录信息（包括已经被删除的 commit 记录和 reset 的操作）
#提升阅读体验，加上参数 --pretty=oneline 只会显示版本号和提交时的备注信息
git log --pretty=oneline
git reflog --pretty=oneline
```

四个命令都能找到之前对应的版本库的哈希值，找到指定的哈希值后，我们执行下面命令

```shell
git reset 哈希值
```

![image-20210820144024359](/images/image-20210820144024359.png)

此时我们可以在工作区看到有很多已修改未提交的文件，此时我们只选择需要提交的文件提交到暂存区，再进行commit既可

![image-20210820144154178](/images/image-20210820144154178.png)

此时`git log --pretty=oneline`查看一下commit记录

![image-20210820144742723](/images/image-20210820144742723.png)

成功了，此时本地版本库已经回退到我们想要的结果了，下一步就是同步远程分支dev了

> 提醒：此时我们还在测试分支tmp上

如何强制同步远程仓库与本地仓库一致呢？

```shell
#git push origin 本地分支:远程分支 -f
#-f表示强制推送
git push origin tmp:dev -f
```

这样我们远程仓库就跟我们本地仓库一致了，此时再提mr既可

## 经验教训

那么经过此时有什么感悟呢？今后如何避免这些问题呢？有什么场景呢？

常规场景：我们在进行项目开发的时候，每天写完代码直接提交到暂存区既可，**不要随便commit**，因为有些公司commit会有规范的，完整开发完一个需求后，再进行commit

bug场景：你在开发一个需求时，组长突然让你改某一个bug，此时你需要**建立一个bug分支**，在该分支上进行bug的修复，然后正常push即可，这样不会将你之前暂存区的文件一起提交