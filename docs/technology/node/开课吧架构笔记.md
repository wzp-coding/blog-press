---
title: 学习笔记
---

# 生活不易，整理笔记

[[toc]]

Node.js基础                                                                                   

课程目标                                                                                        

掌握异步I/O概念、promisify用法、流、buﬀer
掌握一个简单http服务（页面、json数据、静态资源）
实战一个cli工具(vue路由约定)
I/O处理                                                                                       

异步非阻塞I/O                                                                                    

响水壶                                                                                         

关于上面的概念，网上有一个很经典的响水壶解释，怪怪在这里引申给大家，并谈谈自己的理解。


隔壁王大爷（不是隔壁老王，hhhhh~~）有个水壶，王大爷经常用它来烧开水。

王大爷把水壶放到火上烧，然后啥也不干在那等，直到水开了王大爷再去搞别的事情。（同步阻塞）

王大爷觉得自己有点憨，不打算等了。把水壶放上去之后大爷就是去看电视，时不时来瞅一眼有没有开
（同步非阻塞）

王大爷去买了个响水壶，他把响水壶放在火上，然后也是等着水开，水开的时候水壶会发出声响（异步
阻塞）

王大爷又觉得自己有点憨，他把响水壶放在火上然后去看电视，这时他不用是不是来瞅一眼，因为水开
的时候水壶会发出声音通知大爷。（异步非阻塞）

上面四个栗子里，阻塞非阻塞说明的是大爷的状态，同步非同步说明的是水壶的调用姿势。水壶能在烧
好的时候主动响起，就等同于我们异步的定义，能在结束时通知主线程并且回调。所以异步一般配合非
阻塞，才能发挥其作用。



// 03-fs.js
const fs = require('fs');

// 同步调用
const data = fs.readFileSync('./conf.js'); //代码会阻塞在这里
console.log(data);

// 异步调用
fs.readFile('./conf.js', (err, data) => {
if (err) throw err;
console.log(data);
})

// promisify
const {promisify} = require('util')
const readFile = promisify(fs.readFile)
readFile('./conf.js').then(data=>console.log(data))
            web全栈架构师
// fs Promises API node v10
const fsp = require("fs").promises;
fsp
.readFile("./confs.js")
.then(data => console.log(data))
.catch(err => console.log(err));

// async/await
(async () => {
const fs = require('fs')
const { promisify } = require('util')
const readFile = promisify(fs.readFile)
const data = await readFile('./index.html')
console.log('data',data)
})()


// 引用方式
Buffer.from(data).toString('utf-8')



Buﬀer缓冲区                                                                                                  

读取数据类型为Buﬀer

Buﬀer - 用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。                                           八位字节组
成的数组，可以有效的在JS中存储二进制数据

// 04-buffer.js
// 创建一个长度为10字节以0填充的Buffer
const buf1 = Buffer.alloc(10);
console.log(buf1);

// 创建一个Buffer包含ascii.
// ascii 查询 http://ascii.911cha.com/
const buf2 = Buffer.from('a')
console.log(buf2,buf2.toString())

// 创建Buffer包含UTF-8字节
// UFT-8：一种变长的编码方案，使用 1~6 个字节来存储；
// UFT-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储；
// UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。
const buf3 = Buffer.from('Buffer创建方法');
console.log(buf3); 

// 写入Buffer数据
buf1.write('hello');
console.log(buf1); 

// 读取Buffer数据
console.log(buf3.toString());

// 合并Buffer
const buf4 = Buffer.concat([buf1, buf3]);
                web全栈架构师
console.log(buf4.toString());

// 可以尝试修改fs案例输出文件原始内容


Buﬀer类似数组，所以很多数组方法它都有
GBK 转码 iconv-lite
http服务                                                                                                    

创建一个http服务器，05-http.js

const http = require('http');
const server = http.createServer((request, response) => {
console.log('there is a request');
response.end('a response from server');
});
server.listen(3000);



// 打印原型链
function getPrototypeChain(obj) {
var protoChain = [];
while (obj = Object.getPrototypeOf(obj)) {//返回给定对象的原型。如果没有继承属
性，则返回 null 。

protoChain.push(obj);
}
protoChain.push(null);
return protoChain;
}

显示一个首页

const {url, method} = request;
if (url === '/' && method === 'GET') {
fs.readFile('index.html', (err, data) => {
if (err) {
response.writeHead(500, { 'Content-Type': 
'text/plain;charset=utf-8' });
response.end('500，服务器错误');
return ;
}
response.statusCode = 200;
response.setHeader('Content-Type', 'text/html');
response.end(data);
});
} else {
response.statusCode = 404;
response.setHeader('Content-Type', 'text/plain;charset=utf-8');
response.end('404, 页面没有找到');
}

编写一个接口
                web全栈架构师
else if (url === '/users' && method === 'GET') {
response.writeHead(200, { 'Content-Type': 'application/json' });
response.end(JSON.stringify([{name:'tom',age:20}]));
}

Stream流                                                                                                   

stream - 是用于与node中流数据交互的接口

//二进制友好，图片操作,06-stream.js
const fs = require('fs')
const rs2 = fs.createReadStream('./01.jpg')
const ws2 = fs.createWriteStream('./02.jpg')
rs2.pipe(ws2);

//响应图片请求，05-http.js
const {url, method, headers} = request;

else if (method === 'GET' && headers.accept.indexOf('image/*') !== -1) {
fs.createReadStream('.'+url).pipe(response);
}

Accept代表发送端（客户端）希望接受的数据类型。 比如：Accept：text/xml; 代表客户端希望
接受的数据类型是xml类型。

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 比如：Content-
Type：text/html; 代表发送端发送的数据格式是html。

二者合起来， Accept:text/xml； Content-Type:text/html ，即代表希望接受的数据类型是xml格
式，本次请求发送的数据的数据格式是html。


CLI工具                                                                                                     

创建工程                                                                                                      

mkdir vue-auto-router-cli
cd vue-auto-router-cli
npm init -y 
npm i commander download-git-repo ora handlebars figlet clear chalk open -s



# bin/kkb.js
#指定脚本解释器为node
#!/usr/bin/env node
console.log('cli.....')

# package.json
"bin": {
"kkb": "./bin/kkb.js"
},

                web全栈架构师
# 将npm 模块链接到对应的运行项目中去
npm link

# 删除的情况
ls /usr/local/bin/
rm /usr/local/bin/kkb


定制命令行界面                                                                                                   

commander.js

kkb.js文件

#!/usr/bin/env node
const program = require('commander')
program.version(require('../package').version)

program
.command('init <name>')
.description('init project')
.action(name => {
console.log('init ' + name)
})

program.parse(process.argv)



打印欢迎界面                                                                                                    

/lib/init.js

const {promisify} = require('util')
const figlet = promisify(require('figlet'))
const clear = require('clear')
const chalk = require('chalk')
const log = content => console.log(chalk.green(content))
module.exports = async name => {
// 打印欢迎画面
clear()
const data = await figlet('KKB Welcome')
log(data)
}


// bin/kkb.js
program
.command('init <name>')
.description('init project')
.action(require('../lib/init'))


                web全栈架构师

克隆脚手架                                                                                                     

/lib/download.js

const {promisify} = require('util')
module.exports.clone = async function(repo,desc) {
const download = promisify(require('download-git-repo'))
const ora = require('ora')
const process = ora(`下载.....${repo}`)
process.start()
await download(repo, desc)
process.succeed()
}

/lib/init.js

const {clone} = require('./download')
module.exports.init = async name => {
// console.log('init ' + name)
log('创建项目:' + name)
// 从github克隆项目到指定文件夹
await clone('github:su37josephxia/vue-template', name)
}


安装依赖                                                                                                      

// promisiy化spawn
// 对接输出流
const spawn = async (...args) => {
const { spawn } = require('child_process');
return new Promise(resolve => {
const proc = spawn(...args)
proc.stdout.pipe(process.stdout)
proc.stderr.pipe(process.stderr)
proc.on('close', () => {
resolve()
})
})
}

module.exports.init = async name => {

// ....
log('安装依赖')
await spawn('cnpm', ['install'], { cwd: `./${name}` })
log(chalk.green(`
安装完成：
To get Start:
===========================
cd ${name}
npm run serve
===========================
                web全栈架构师
`))

}





启动项目                                                                                                      

const open = require("open")
module.exports.init = async name => {
// ...
// 打开浏览器
open(`http://localhost:8080`);
await spawn('npm', ['run', 'serve'], { cwd: `./${name}` })
}


约定路由功能                                                                                                    

loader 文件扫描
代码模板渲染 hbs Mustache风格模板

/lib/refresh.js

const fs = require('fs')
const handlebars = require('handlebars')
const chalk = require('chalk')
module.exports = async () => {

// 获取页面列表
const list =
fs.readdirSync('./src/views')
.filter(v => v !== 'Home.vue')
.map(v => ({
name: v.replace('.vue', '').toLowerCase(),
file: v
}))

// 生成路由定义
compile({
list
}, './src/router.js', './template/router.js.hbs')

// 生成菜单
compile({
list
}, './src/App.vue', './template/App.vue.hbs')

/**
* 编译模板文件
* @param meta 数据定义
* @param filePath 目标文件路径
* @param templatePath 模板文件路径
                web全栈架构师
*/
function compile(meta, filePath, templatePath) {
if (fs.existsSync(templatePath)) {
const content = fs.readFileSync(templatePath).toString();
const result = handlebars.compile(content)(meta);
fs.writeFileSync(filePath, result);
}
console.log(chalk.green(`${filePath} 创建成功`))
}
}

/bin/kkb

program
.command('refresh')
.description('refresh routers...')
.action(require('../lib/refresh'))


发布npm                                                                                                     

#!/usr/bin/env bash
npm config get registry # 检查仓库镜像库
npm config set registry=http://registry.npmjs.org
echo '请进行登录相关操作：'
npm login # 登陆
echo "-------publishing-------"
npm publish # 发布
npm config set registry=https://registry.npm.taobao.org # 设置为淘宝镜像
echo "发布完成"
exit




                web全栈架构师
Koa2源码解读                                                                                    


Koa2源码解读
课前准备
回顾
课堂目标
课堂主题
知识点
koa
koa 原理：
context
中间件
常见koa中间件的实现
总结
作业 && 答疑

课前准备                                                                                        

1. koa2 https://github.com/koajs/koa


回顾                                                                                          

基于Koa打造企业级MVC框架


课堂目标                                                                                        

1. 手写koa
2. 手写static中间件


课堂主题                                                                                        

1. koa 原理
2. context
3. Application剖析
4. 中间件机制
5. 常见中间件


知识点                                                                                         

koa                                                                                         


    开课吧web全栈架构师
概述：Koa 是一个新的 web 框架， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有
表现力、更健壮的基石。

koa是Express的下一代基于Node.js的web框架

koa2完全使用Promise并配合             async  来实现异步

特点：

轻量，无捆绑
中间件架构
优雅的API设计
增强的错误处理
安装：     npm i koa -S

中间件机制、请求、响应处理

const Koa = require('koa')
const app = new Koa()
app.use((ctx, next) => {

ctx.body = [
{
name: 'tom'
}
]
next()
})

app.use((ctx, next) => {
// 同步sleep
const expire = Date.now() + 100;
while (Date.now() < expire)

// ctx.body && ctx.body.push(
//     {
//         name:'jerry'
//     }
// )
console.log('url' + ctx.url)
if (ctx.url === '/html') {
ctx.type = 'text/html;charset=utf-8'
ctx.body = `<b>我的名字是:${ctx.body[0].name}</b>`
}
})

app.listen(3000)


// 搞个小路由
const router = {}
router['/html'] = ctx => {
ctx.type = 'text/html;charset=utf-8'
ctx.body = `<b>我的名字是:${ctx.body[0].name}</b>`
}

const fun = router[ctx.url]
fun && fun(ctx)

            开课吧web全栈架构师
Koa中间件机制：Koa中间件机制就是函数式 组合概念 Compose的概念，将一组需要顺序执行的
函数复合为一个函数，外层函数的参数实际是内层函数的返回值。洋葱圈模型可以形象表示这种机
制，是源码中的精髓和难点。






常见的中间件操作

静态服务

app.use(require('koa-static')(__dirname + '/'))

路由

const router = require('koa-router')()
router.get('/string', async (ctx, next) => {
ctx.body = 'koa2 string'
})
router.get('/json', async (ctx, next) => {
ctx.body = {
title: 'koa2 json'
}
})
app.use(router.routes())


日志

app.use(async (ctx,next) => {
const start = Date.now()
await next()
const end = Date.now()
            开课吧web全栈架构师
console.log(`请求${ctx.url} 耗时${parseInt(end - start)}ms`)
})
app.use(async (ctx,next) => {
const expire = Date.now() + 102;
while (Date.now() < expire)
ctx.body = [
{
name:'tom'
}
]
})

koa 原理：                                                                                                   

一个基于nodejs的入门级http服务，类似下面代码：


const http = require('http')
const server = http.createServer((req, res)=>{
res.writeHead(200)
res.end('hi kaikeba')
})

server.listen(3000,()=>{
console.log('监听端口3000')
})


koa的目标是用更简单化、流程化、模块化的方式实现回调部分

// 创建kkb.js
const http = require("http");

class KKB {
listen(...args) {
const server = http.createServer((req, res) => {
this.callback(req, res);
});
server.listen(...args);
}
use(callback) {

            开课吧web全栈架构师
this.callback = callback;
}
}
module.exports = KKB;

// 调用，index.js
const KKB = require("./kkb");
const app = new KKB();

app.use((req, res) => {
res.writeHead(200);
res.end("hi kaikeba");
});

app.listen(3000, () => {
console.log("监听端口3000");
});

目前为止，KKB只是个马甲，要真正实现目标还需要引入上下文（context）和中间件机制
（middleware）


context                                                                                                   

koa为了能够简化API，引入上下文context概念，将原始请求对象req和响应对象res封装并挂载到
context上，并且在context上设置getter和setter，从而简化操作。

使用方法，接近koa了

// app.js
app.use(ctx=>{
ctx.body = 'hehe'
})


知识储备：getter/setter方法

// 测试代码，test-getter-setter.js

            开课吧web全栈架构师
const kaikeba = {
info:{ name: '开课吧', desc: '开课吧真不错' },
get name(){
return this.info.name
},
set name(val){
console.log('new name is' + val)
this.info.name = val
}
}
console.log(kaikeba.name)
kaikeba.name = 'kaikeba'
console.log(kaikeba.name)



封装request、response和context

https://github.com/koajs/koa/blob/master/lib/response.js

// request.js
module.exports = {
get url() {
return this.req.url;
},

get method(){
return this.req.method.toLowerCase()
}
};


// response.js
module.exports = {
get body() {
return this._body;
},
set body(val) {
this._body = val;
}
};


// context.js
module.exports = {
get url() {
return this.request.url;
},
get body() {
return this.response.body;
},
set body(val) {
this.response.body = val;
},
get method() {
return this.request.method
}
};
            开课吧web全栈架构师
// kkb.js
// 导入这三个类
const context = require("./context");
const request = require("./request");
const response = require("./response");

class KKB {
listen(...args) {
const server = http.createServer((req, res) => {
// 创建上下文
let ctx = this.createContext(req, res);

this.callback(ctx)
// 响应
res.end(ctx.body);
});
// ...
}
// 构建上下文, 把res和req都挂载到ctx之上，并且在ctx.req和ctx.request.req同时保存
createContext(req, res) {
const ctx = Object.create(context);
ctx.request = Object.create(request);
ctx.response = Object.create(response);

ctx.req = ctx.request.req = req;
ctx.res = ctx.response.res = res;
return ctx;
}
}


中间件                                                                                                       

Koa中间件机制：Koa中间件机制就是函数式 组合概念 Compose的概念，将一组需要顺序执行的
函数复合为一个函数，外层函数的参数实际是内层函数的返回值。洋葱圈模型可以形象表示这种机
制，是源码中的精髓和难点。




            开课吧web全栈架构师


知识储备：函数组合

const add = (x, y) => x + y
const square = z => z * z
const fn = (x, y) => square(add(x, y))
console.log(fn(1, 2))

上面就算是两次函数组合调用，我们可以把他合并成一个函数

const compose = (fn1, fn2) => (...args) => fn2(fn1(...args))
const fn = compose(add,square)

多个函数组合：中间件的数目是不固定的，我们可以用数组来模拟

const compose = (...[first,...other]) => (...args) => {
let ret = first(...args)
other.forEach(fn => {
ret = fn(ret)
})
return ret
}
const fn = compose(add,square)
console.log(fn(1, 2))



异步中间件：上面的函数都是同步的，挨个遍历执行即可，如果是异步的函数呢，是一个
promise，我们要支持async + await的中间件，所以我们要等异步结束后，再执行下一个中间
件。


            开课吧web全栈架构师
function compose(middlewares) {
return function() {
return dispatch(0);
// 执行第0个
function dispatch(i) {
let fn = middlewares[i];
if (!fn) {
return Promise.resolve();
}
return Promise.resolve(
fn(function next() {
// promise完成后，再执行下一个
return dispatch(i + 1);
})
);
}
};
}

async function fn1(next) {
console.log("fn1");
await next();
console.log("end fn1");
}

async function fn2(next) {
console.log("fn2");
await delay();
await next();
console.log("end fn2");
}

function fn3(next) {
console.log("fn3");
}

function delay() {
return new Promise((reslove, reject) => {
setTimeout(() => {
reslove();
}, 2000);
});
}

const middlewares = [fn1, fn2, fn3];
const finalFn = compose(middlewares);
finalFn();




            开课吧web全栈架构师


compose用在koa中，kkb.js

const http = require("http");
const context = require("./context");
const request = require("./request");
const response = require("./response");

class KKB {
// 初始化中间件数组
constructor() {
this.middlewares = [];
}
listen(...args) {
const server = http.createServer(async (req, res) => {
const ctx = this.createContext(req, res);
// 中间件合成
const fn = this.compose(this.middlewares);
// 执行合成函数并传入上下文
await fn(ctx);
res.end(ctx.body);
});
server.listen(...args);
}
use(middleware) {
// 将中间件加到数组里
this.middlewares.push(middleware);
}
// 合成函数
compose(middlewares) {
return function(ctx) { // 传入上下文
return dispatch(0);
function dispatch(i) {
let fn = middlewares[i];
if (!fn) {
return Promise.resolve();
}
return Promise.resolve(
fn(ctx, function next() {// 将上下文传入中间件，mid(ctx,next)
return dispatch(i + 1);
})
);
}
};

            开课吧web全栈架构师
}
createContext(req, res) {
let ctx = Object.create(context);
ctx.request = Object.create(request);
ctx.response = Object.create(response);

ctx.req = ctx.request.req = req;
ctx.res = ctx.response.res = res;
return ctx;
}
}
module.exports = KKB;

使用，app.js

const delay = () => new Promise(resolve => setTimeout(() => resolve() ,2000));

app.use(async (ctx, next) => {
ctx.body = "1";
await next();
ctx.body += "5";
});

app.use(async (ctx, next) => {
ctx.body += "2";
await delay();
await next();
ctx.body += "4";
});

app.use(async (ctx, next) => {
ctx.body += "3";
});


koa-compose的源码


            开课吧web全栈架构师
兼顾OOP和AOP
函数编程 函数即逻辑 (React 函数即组件 组件即页面)



看一下Express


常见koa中间件的实现                                                                                               

koa中间件的规范：

一个async函数
接收ctx和next两个参数
任务结束需要执行next

const mid = async (ctx, next) => {
// 来到中间件，洋葱圈左边
next() // 进入其他中间件
// 再次来到中间件，洋葱圈右边
};  



中间件常见任务：

请求拦截
路由
日志
静态文件服务



路由 router

将来可能的用法

const Koa = require('./kkb')
const Router = require('./router') 
const app = new Koa()
const router = new Router();

router.get('/index', async ctx => { ctx.body = 'index page'; });
router.get('/post', async ctx => { ctx.body = 'post page'; });
router.get('/list', async ctx => { ctx.body = 'list page'; });
router.post('/index', async ctx => { ctx.body = 'post page'; });

// 路由实例输出父中间件 router.routes()
app.use(router.routes());

routes()的返回值是一个中间件，由于需要用到method，所以需要挂载method到ctx之上，修改
request.js


            开课吧web全栈架构师




// request.js
module.exports = {
// add...
get method(){
return this.req.method.toLowerCase()
}
}


// context.js
module.exports = {
// add...
get method() {
return this.request.method
},
}


class Router {
constructor() {
this.stack = [];
}

register(path, methods, middleware) {
let route = {path, methods, middleware}
this.stack.push(route);
}
// 现在只支持get和post，其他的同理
get(path,middleware){
this.register(path, 'get', middleware);
}
post(path,middleware){
this.register(path, 'post', middleware);
}
routes() {
let stock = this.stack;
            开课吧web全栈架构师
return async function(ctx, next) {
let currentPath = ctx.url;
let route;

for (let i = 0; i < stock.length; i++) {
let item = stock[i];
if (currentPath === item.path && item.methods.indexOf(ctx.method) >= 
0) {
// 判断path和method
route = item.middleware;
break;
}
}

if (typeof route === 'function') {
route(ctx, next);
return;
}

await next();
};
}
}
module.exports = Router;

使用

const Koa = require('./kkb')
const Router = require('./router') 
const app = new Koa()
const router = new Router();

router.get('/index', async ctx => { 
console.log('index,xx')
ctx.body = 'index page'; 
});
router.get('/post', async ctx => { ctx.body = 'post page'; });
router.get('/list', async ctx => { ctx.body = 'list page'; });

router.post('/index', async ctx => { ctx.body = 'post page'; });

// 路由实例输出父中间件 router.routes()
app.use(router.routes());

app.listen(3000,()=>{
console.log('server runing on port 9092')
})



静态文件服务koa-static

配置绝对资源目录地址，默认为static
获取文件或者目录信息
静态文件读取
返回

            开课吧web全栈架构师
// static.js
const fs = require("fs");
const path = require("path");

module.exports = (dirPath = "./public") => {
return async (ctx, next) => {
if (ctx.url.indexOf("/public") === 0) {
// public开头 读取文件
const url = path.resolve(__dirname, dirPath);
const fileBaseName = path.basename(url);
const filepath = url + ctx.url.replace("/public", "");
console.log(filepath);
// console.log(ctx.url,url, filepath, fileBaseName)
try {
stats = fs.statSync(filepath);
if (stats.isDirectory()) {
const dir = fs.readdirSync(filepath);
// const
const ret = ['<div style="padding-left:20px">'];
dir.forEach(filename => {
console.log(filename);
// 简单认为不带小数点的格式，就是文件夹，实际应该用statSync
if (filename.indexOf(".") > -1) {
ret.push(
`<p><a style="color:black" href="${
ctx.url
}/${filename}">${filename}</a></p>`
);
} else {
// 文件
ret.push(
`<p><a href="${ctx.url}/${filename}">${filename}</a></p>`
);
}
});
ret.push("</div>");
ctx.body = ret.join("");
} else {
console.log("文件");

const content = fs.readFileSync(filepath);
ctx.body = content;
}
} catch (e) {
// 报错了 文件不存在
ctx.body = "404, not found";
}
} else {
// 否则不是静态资源，直接去下一个中间件
await next();
}
};
};


// 使用
const static = require('./static')
app.use(static(__dirname + '/public'));
        开课吧web全栈架构师




请求拦截：黑名单中存在的ip访问将被拒绝

// iptable.js
module.exports = async function(ctx, next) {
const { res, req } = ctx;
const blackList = ['127.0.0.1'];
const ip = getClientIP(req);

if (blackList.includes(ip)) {//出现在黑名单中将被拒绝
ctx.body = "not allowed";
} else {
await next();
}
};
function getClientIP(req) {
return (
req.headers["x-forwarded-for"] || // 判断是否有反向代理 IP
req.connection.remoteAddress || // 判断 connection 的远程 IP
req.socket.remoteAddress || // 判断后端的 socket 的 IP
req.connection.socket.remoteAddress
);
}

// app.js
app.use(require("./interceptor"));
app.listen(3000, '0.0.0.0', () => {
console.log("监听端口3000");
});

请求拦截应用非常广泛：登录状态验证、CORS头设置等。


总结                                                                                                        

1. 回顾知识点
2. 提示学习方法

3. 提示本次课重点和必会知识


Koa2源码解读
课前准备
回顾
课堂目标
课堂主题
知识点
koa
koa 原理：
context
中间件
常见koa中间件的实现
总结
            开课吧web全栈架构师
作业 && 答疑

作业 && 答疑                                                                                    

扩展内容

Object.create的理解

https://juejin.im/post/5dd20cb3f265da0bf66b6670

中间件扩展学习

https://juejin.im/post/5dbf9bdaf265da4d25054f91

策略模式：

https://github.com/su37josephxia/frontend-basic/tree/master/src/strategy

中间件对比

https://github.com/nanjixiong218/analys-middlewares/tree/master/src

责任链模式

https://blog.csdn.net/liuwenzhe2008/article/details/70199520

思维导图 
https://www.processon.com/view/link/5d4b852ee4b07c4cf3069fec#map

作业：
实现compose函数。
要求: 提交代码截图
- 实现洋葱圈模型


        开课吧web全栈架构师
⽹络编程 http https http2 websocket                                                                     



知识点                                                                                                 

HTTP协议                                                                                              

// 观察HTTP协议
curl -v http://www.baidu.com



http协议详解

创建接⼝，api.js

// /http/api.js
const http = require("http");
const fs = require("fs");

http
.createServer((req, res) => {
const { method, url } = req;
if (method == "GET" && url == "/") {
fs.readFile("./index.html", (err, data) => {
res.setHeader("Content-Type", "text/html");
res.end(data);
});
} else if (method == "GET" && url == "/api/users") {
res.setHeader("Content-Type", "application/json");
res.end(JSON.stringify([{ name: "tom", age: 20 }]));
}
})
.listen(3000);

请求接⼝


        开课吧web全栈架构师
// index.html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
(async () => {
const res = await axios.get("/api/users")
console.log('data',res.data)
document.writeln(`Response : ${JSON.stringify(res.data)}`)
})()
</script>

埋点更容易

const img = new Image()
img.src='/api/users?abc=123'



协议 端⼝ host



跨域：浏览器同源策略引起的接⼝调⽤问题

// proxy.js
const express = require('express')
const app = express()
app.use(express.static(__dirname + '/'))
module.exports = app



// index.js
const api = require('./api')
const proxy = require('./proxy')
api.listen(4000)
proxy.listen(3000)





// 或者通过baseURL⽅式
axios.defaults.baseURL = 'http://localhost:4000'

浏览器抛出跨域错误


        开课吧web全栈架构师
!


常⽤解决⽅案：

1. JSONP(JSON with Padding)，前端+后端⽅案，绕过跨域

前端构造script标签请求指定URL（由script标签发出的GET请求不受同源策略限制），服务器返
回⼀个函数执⾏语句，该函数名称通常由查询参callback的值决定，函数的参数为服务器返回的
json数据。该函数在前端执⾏后即可获取数据。

2. 代理服务器

请求同源服务器，通过该服务器转发请求⾄⽬标服务器，得到结果再转发给前端。

前端开发中测试服务器的代理功能就是采⽤的该解决⽅案，但是最终发布上线时如果web应⽤和
接⼝服务器不在⼀起仍会跨域。

3. CORS(Cross Origin Resource Share) - 跨域资源共享，后端⽅案，解决跨域

预检请求

原理：cors是w3c规范，真正意义上解决跨域问题。它需要服务器对请求进⾏检查并对响应头做相应处理，
从⽽允许跨域请求。

具体实现：

响应简单请求: 动词为get/post/head，没有⾃定义请求头，Content-Type是application/x-www-
form-urlencoded，multipart/form-data或text/plain之⼀，通过添加以下响应头解决：

res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000')

该案例中可以通过添加⾃定义的x-token请求头使请求变为preﬂight请求

// index.html
axios.defaults.baseURL = 'http://localhost:3000';
axios.get("/users", {headers:{'X-Token':'jilei'}})

响应preﬂight请求，需要响应浏览器发出的options请求（预检请求），并根据情况设置响应头：


    开课吧web全栈架构师
else if (method == "OPTIONS" && url == "/api/users") {
res.writeHead(200, {
"Access-Control-Allow-Origin": "http://localhost:3000",
"Access-Control-Allow-Headers": "X-Token,Content-Type",
"Access-Control-Allow-Methods": "PUT"
});
res.end();
}



则服务器需要允许x-token，若请求为post，还传递了参数：

// index.html
axios.post("http://localhost:3000/users", {foo:'bar'}, {headers:{'X-
Token':'jilei'}})
// http-server.js
else if ((method == "GET" || method == "POST") && url == "/users") {}

则服务器还需要允许content-type请求头

如果要携带cookie信息，则请求变为credential请求： ​

// index.js
// 预检options中和/users接⼝中均需添加
res.setHeader('Access-Control-Allow-Credentials', 'true');
// 设置cookie
res.setHeader('Set-Cookie', 'cookie1=va222;')

// index.html
// 观察cookie存在
console.log('cookie',req.headers.cookie)
// ajax服务
axios.defaults.withCredentials = true



Proxy代理模式                                                                                           

var express = require('express');
const proxy = require('http-proxy-middleware')

const app = express()
app.use(express.static(__dirname + '/'))
app.use('/api', proxy({ target: 'http://localhost:4000', changeOrigin: false 
}));
module.exports = app

        开课吧web全栈架构师


对⽐⼀下nginx 与webpack devserver

// vue.config.js
module.exports = {
devServer: {
disableHostCheck: true,
compress: true,
port: 5000,
proxy: {
'/api/': {
target: 'http://localhost:4000',
changeOrigin: true,
},
},
},
}

nginx

server {
listen       80;
# server_name  www.josephxia.com;
location / {
root   /var/www/html;
index  index.html index.htm;
try_files $uri $uri/ /index.html;
}

location /api {
proxy_pass  http://127.0.0.1:3000;
proxy_redirect     off;
proxy_set_header   Host             $host;
proxy_set_header   X-Real-IP        $remote_addr;
proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
}
}



Bodyparser                                                                                          

application/x-www-form-urlencoded


        开课吧web全栈架构师
<form action="/api/save" method="post">
<input type="text" name="abc" value="123">
<input type="submit" value="save">
</form>


// api.js
else if (method === "POST" && url === "/api/save") {
let reqData = [];
let size = 0;
req.on('data', data => {
console.log('>>>req on', data);
reqData.push(data);
size += data.length;
});
req.on('end', function () {
console.log('end')
const data = Buffer.concat(reqData, size);
console.log('data:', size, data.toString())
res.end(`formdata:${data.toString()}`)
});
}





application/json

await axios.post("/api/save", {
a: 1,
b: 2
})


// 模拟application/x-www-form-urlencoded
await axios.post("/api/save", 'a=1&b=3', {
headers: {
'Content-Type': 'application/x-www-form-urlencoded',
},
})




上传⽂件                                                                                                


        开课吧web全栈架构师
// Stream pipe
request.pipe(fis)
response.end()


// Buffer connect
request.on('data',data => {
chunk.push(data)
size += data.length
console.log('data:',data ,size)
})
request.on('end',() => {
console.log('end...')
const buffer = Buffer.concat(chunk,size)
size = 0
fs.writeFileSync(outputFile,buffer)
response.end()
})


// 流事件写⼊
request.on('data', data => {
console.log('data:',data)
fis.write(data)
})
request.on('end', () => {
fis.end()
response.end()
})





实战⼀个爬⾍                                                                                              

原理：服务端模拟客户端发送请求到⽬标服务器获取⻚⾯内容并解析，获取其中关注部分的数据。

// spider.js
const originRequest = require("request");
const cheerio = require("cheerio");
const iconv = require("iconv-lite");

function request(url, callback) {
const options = {
url: url,
encoding: null
};
originRequest(url, options,callback);
}
        开课吧web全栈架构师
for (let i = 100553; i < 100563; i++) {
const url = `https://www.dy2018.com/i/${i}.html`;
request(url, function(err, res, body) {
const html = iconv.decode(body, "gb2312");
const $ = cheerio.load(html);
console.log($(".title_all h1").text());
});
}

实现⼀个即时通讯IM                                                                                          

Socket实现

原理：Net模块提供⼀个异步API能够创建基于流的TCP服务器，客户端与服务器建⽴连接后，服务器可
以获得⼀个全双⼯Socket对象，服务器可以保存Socket对象列表，在接收某客户端消息时，推送给其他
客户端。

// socket.js
const net = require('net')
const chatServer = net.createServer()
const clientList = []
chatServer.on('connection',client => {
client.write('Hi!\n')
clientList.push(client)
client.on('data',data => {
console.log('receive:',data.toString())
clientList.forEach(v => {
v.write(data)
})
})
})
chatServer.listen(9000)

通过Telnet连接服务器

telnet localhost 9000



Http实现

原理：客户端通过ajax⽅式发送数据给http服务器，服务器缓存消息，其他客户端通过轮询⽅式查询最
新数据并更新列表。

<html>
<head>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
        开课吧web全栈架构师
</head>

<body>
<div id="app">
<input v-model="message">
<button v-on:click="send">发送</button>
<button v-on:click="clear">清空</button>
<div v-for="item in list">{{item}}</div>
</div>

<script>
const host = 'http://localhost:3000'
var app = new Vue({
el: '#app',
data: {
list: [],
message: 'Hello Vue!'
},
methods: {
send: async function () {
let res = await axios.post(host + '/send', {
message: this.message
})
this.list = res.data
},
clear: async function () {
let res = await axios.post(host + '/clear')
this.list = res.data
}
},
mounted: function () {
setInterval(async () => {
const res = await axios.get(host + '/list')
this.list = res.data
}, 1000);
}
});
</script>
</body>
</html>


const express = require('express')
const app = express()
const bodyParser = require('body-parser');
const path = require('path')

app.use(bodyParser.json()); 

const list = ['ccc', 'ddd']
        开课吧web全栈架构师
app.get('/', (req,res)=>{
res.sendFile(path.resolve('./index.html'))
})

app.get('/list', (req, res) => {
res.end(JSON.stringify(list))
})

app.post('/send', (req, res) => {
list.push(req.body.message)
res.end(JSON.stringify(list))
})

app.post('/clear', (req, res) => {
list.length = 0
res.end(JSON.stringify(list))
})

app.listen(3000); 



Socket.IO实现

安装：    npm install --save socket.io
两部分：nodejs模块，客户端js

// 服务端：chat-socketio.js
var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);

app.get('/', function(req, res){
res.sendFile(__dirname + '/index.html');
});

io.on('connection', function(socket){
console.log('a user connected');

//响应某⽤户发送消息
socket.on('chat message', function(msg){
console.log('chat message:' + msg);

// ⼴播给所有⼈
io.emit('chat message', msg);
// ⼴播给除了发送者外所有⼈
// socket.broadcast.emit('chat message', msg)
});  

        开课吧web全栈架构师
socket.on('disconnect', function(){
console.log('user disconnected');
});
});

http.listen(3000, function(){
console.log('listening on *:3000');
});


// 客户端：index.html
<!DOCTYPE html>
<html>
<head>
<title>Socket.IO chat</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font: 13px Helvetica, Arial;
}
form {
background: #000;
padding: 3px;
position: fixed;
bottom: 0;
width: 100%;
}
form input {
border: 0;
padding: 10px;
width: 90%;
margin-right: 0.5%;
}
form button {
width: 9%;
background: rgb(130, 224, 255);
border: none;
padding: 10px;
}
#messages {
list-style-type: none;
margin: 0;
padding: 0;
}
#messages li {
padding: 5px 10px;
        开课吧web全栈架构师
}
#messages li:nth-child(odd) {
background: #eee;
}
</style>
</head>
<body>
<ul id="messages"></ul>
<form action="">
<input id="m" autocomplete="off" /><button>Send</button>
</form>

<script 
src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js">
</script>
<script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script>
$(function() {
var socket = io();
$("form").submit(function(e) {
e.preventDefault(); // 避免表单提交⾏为
socket.emit("chat message", $("#m").val());
$("#m").val("");
return false;
});

socket.on("chat message", function(msg) {
$("#messages").append($("<li>").text(msg));
});
});
</script>
</body>
</html>

Socket.IO库特点：

源于HTML5标准

⽀持优雅降级

WebSocket
WebSocket over FLash
XHR Polling
XHR Multipart Streaming
Forever Iframe
JSONP Polling



Https                                                                                               

        开课吧web全栈架构师
创建证书

# 创建私钥
openssl genrsa -out privatekey.pem 1024
# 创建证书签名请求
openssl req -new -key privatekey.pem -out certrequest.csr
# 获取证书，线上证书需要经过证书授证中⼼签名的⽂件；下⾯只创建⼀个学习使⽤证书
openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out 
certificate.pem
# 创建pfx⽂件
openssl pkcs12 -export -in certificate.pem -inkey privatekey.pem -out 
certificate.pfx


Http2                                                                                   

多路复⽤ - 雪碧图、多域名CDN、接⼝合并

官⽅演示 - https://http2.akamai.com/demo
多路复⽤允许同时通过单⼀的 HTTP/2 连接发起多重的请求-响应消息；⽽HTTP/1.1协议中，
浏览器客户端在同⼀时间，针对同⼀域名下的请求有⼀定数量限制。超过限制数⽬的请求会
被阻塞**

⾸部压缩

http/1.x 的 header 由于 cookie 和 user agent很容易膨胀，⽽且每次都要重复发送。
http/2使⽤ encoder 来减少需要传输的 header ⼤⼩，通讯双⽅各⾃ cache⼀份
header ﬁelds 表，既避免了重复 header 的传输，⼜减⼩了需要传输的⼤⼩。⾼效的压
缩算法可以很⼤的压缩 header，减少发送包的数量从⽽降低延迟
服务端推送

在 HTTP/2 中，服务器可以对客户端的⼀个请求发送多个响应。举个例⼦，如果⼀个请
求请求的是index.html，服务器很可能会同时响应index.html、logo.jpg 以及 css 和 js
⽂件，因为它知道客户端会⽤到这些东⻄。这相当于在⼀个 HTML ⽂档内集合了所有的
资源


    开课吧web全栈架构师
数据持久化 - MySQL                                                                               

回顾                                                                                          

http协议
websocket
socket.io


课堂目标                                                                                        

掌握node.js中实现持久化的多种方法
掌握mysql下载、安装和配置
掌握node.js中原生mysql驱动模块的应用
掌握node.js中的ORM模块Sequelize的应用
掌握Sequelize的应用案例


资源                                                                                          

MySQL相关：

MySQL：下载
node驱动：文档
Sequelize：文档、api
mongodb相关：

MongoDB：下载
node驱动：文档
mongoose：文档
redis相关：

redis：下载
node_redis：文档


node.js中实现持久化的多种方法                                                                          

文件系统 fs

数据库

关系型数据库-mysql
文档型数据库-mongodb
键值对数据库-redis


文件系统数据库                                                                                     


    开课吧web全栈架构师
// fsdb.js
// 实现一个文件系统读写数据库
const fs = require("fs");

function get(key) {
fs.readFile("./db.json", (err, data) => {
const json = JSON.parse(data);
console.log(json[key]);
});
}
function set(key, value) {
fs.readFile("./db.json", (err, data) => {
// 可能是空文件，则设置为空对象
const json = data ? JSON.parse(data) : {};
json[key] = value; // 设置值
// 重新写入文件
fs.writeFile("./db.json", JSON.stringify(json), err => {
if (err) {
console.log(err);
}
console.log("写入成功！");
});
});
}

// 命令行接口部分
const readline = require("readline");
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

rl.on("line", function(input) {
const [op, key, value] = input.split(" ");

if (op === 'get') {
get(key)
} else if (op === 'set') {
set(key, value)
} else if(op === 'quit'){
rl.close();
}else {
console.log('没有该操作');
}
});

rl.on("close", function() {
console.log("程序结束");
process.exit(0);
});


MySQL安装、配置                                                                                                

mac

            开课吧web全栈架构师
windows

菜鸟教程 http://www.runoob.com/mysql/mysql-tutorial.html
node.js原生驱动                                                                                               

安装mysql模块：         npm i mysql --save
mysql模块基本使用

// mysql.js
const mysql = require("mysql");
// 连接配置
const cfg = {
host: "localhost",
user: "root", 
password: "example", // 修改为你的密码
database: "kaikeba" // 请确保数据库存在
};
// 创建连接对象
const conn = mysql.createConnection(cfg);

// 连接
conn.connect(err => {
if (err) {
throw err;
} else {
console.log("连接成功！");
}
});

// 查询 conn.query()
// 创建表
const CREATE_SQL = `CREATE TABLE IF NOT EXISTS test (
id INT NOT NULL AUTO_INCREMENT,
message VARCHAR(45) NULL,
PRIMARY KEY (id))`;
const INSERT_SQL = `INSERT INTO test(message) VALUES(?)`;
const SELECT_SQL = `SELECT * FROM test`;
conn.query(CREATE_SQL, err => {
if (err) {
throw err;
}
// 插入数据
conn.query(INSERT_SQL, "hello,world", (err, result) => {
if (err) {
throw err;
}
console.log(result);
conn.query(SELECT_SQL, (err, results) => {
console.log(results);
conn.end(); // 若query语句有嵌套，则end需在此执行
})
});
});



            开课吧web全栈架构师
ES2017写法

// mysql2.js
(async () => {
// get the client
const mysql = require('mysql2/promise');
// 连接配置
const cfg = {
host: "localhost",
user: "root",
password: "example", // 修改为你的密码
database: "kaikeba" // 请确保数据库存在
};
// create the connection
const connection = await mysql.createConnection(cfg);


// 查询 conn.query()
// 创建表
const CREATE_SQL = `CREATE TABLE IF NOT EXISTS test (
id INT NOT NULL AUTO_INCREMENT,
message VARCHAR(45) NULL,
PRIMARY KEY (id))`;
const INSERT_SQL = `INSERT INTO test(message) VALUES(?)`;
const SELECT_SQL = `SELECT * FROM test`;

// query database
let ret = await connection.execute(CREATE_SQL);
console.log('create:', ret)
ret = await connection.execute(INSERT_SQL, ['abc']);
console.log('insert:', ret)
const [rows, fields] = await connection.execute(SELECT_SQL);
console.log('select:', rows)

})()





Node.js ORM - Sequelize                                                                                   

概述：基于Promise的ORM(Object Relation Mapping)，是一种数据库中间件 支持多种数据库、
事务、关联等

中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功
能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目
的。目前，它并没有很严格的定义，但是普遍接受IDC的定义：中间件是一种独立的系统软
件服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机
服务器的操作系统之上，管理计算资源和网络通信。从这个意义上可以用一个等式来表示中
间件：中间件=平台+通信，这也就限定了只有用于分布式系统中才能叫中间件，同时也把它
与支撑软件和实用软件区分开来。

安装：     npm i sequelize mysql2 -S

基本使用：
            开课吧web全栈架构师
(async () => {
const Sequelize = require("sequelize");

// 建立连接
const sequelize = new Sequelize("kaikeba", "root", "example", {
host: "localhost",
dialect: "mysql",
operatorsAliases: false // 仍可通过传入 operators map 至 
operatorsAliases 的方式来使用字符串运算符，但会返回弃用警告
});

// 定义模型
const Fruit = sequelize.define("Fruit", {
name: { type: Sequelize.STRING(20), allowNull: false },
price: { type: Sequelize.FLOAT, allowNull: false },
stock: { type: Sequelize.INTEGER, defaultValue: 0 }
});

// 同步数据库，force: true则会删除已存在表
let ret = await Fruit.sync()
console.log('sync',ret)
ret = await Fruit.create({
name: "香蕉",
price: 3.5
})
console.log('create',ret)
ret = await Fruit.findAll()

await Fruit.update(
{ price: 4 },
{ where: { name:'香蕉'} }
)

console.log('findAll',JSON.stringify(ret))
const Op = Sequelize.Op;
ret = await Fruit.findAll({
// where: { price: { [Op.lt]:4 }, stock: { [Op.gte]: 100 } }
where: { price: { [Op.lt]: 4, [Op.gt]: 2 } }
})
console.log('findAll', JSON.stringify(ret, '', '\t'))


})()


强制同步：创建表之前先删除已存在的表

Fruit.sync({force: true})

避免自动生成时间戳字段

const Fruit = sequelize.define("Fruit", {}, {
timestamps: false
});


    开课吧web全栈架构师
指定表名：       freezeTableName: true      或   tableName:'xxx'

设置前者则以modelName作为表名；设置后者则按其值作为表名。

蛇形命名 underscored: true,
默认驼峰命名

UUID-主键

id: {
type: Sequelize.DataTypes.UUID,
defaultValue: Sequelize.DataTypes.UUIDV1,
primaryKey: true
},



Getters & Setters：可用于定义伪属性或映射到数据库字段的保护属性

// 定义为属性的一部分
name: {
type: Sequelize.STRING,
allowNull: false,
get() {
const fname = this.getDataValue("name");
const price = this.getDataValue("price");
const stock = this.getDataValue("stock");        
return `${fname}(价格：￥${price} 库存：${stock}kg)`;
}
}

// 定义为模型选项
// options中
{
getterMethods:{
amount(){
return this.getDataValue("stock") + "kg";
}
},
setterMethods:{
amount(val){
const idx = val.indexOf('kg');
const v = val.slice(0, idx);
this.setDataValue('stock', v);
}
}
}

// 通过模型实例触发setterMethods
Fruit.findAll().then(fruits => {
console.log(JSON.stringify(fruits));
// 修改amount，触发setterMethods
fruits[0].amount = '150kg';
fruits[0].save();
});


    开课吧web全栈架构师
校验：可以通过校验功能验证模型字段格式、内容，校验会在                                    create   、 update  和  save  时自动
运行

price: {
validate: {
isFloat: { msg: "价格字段请输入数字" },
min: { args: [0], msg: "价格字段必须大于0" }
}
},
stock: {
validate: {
isNumeric: { msg: "库存字段请输入数字" }
}
}

模型扩展：可添加模型实例方法或类方法扩展模型

// 添加类级别方法
Fruit.classify = function(name) {
const tropicFruits = ['香蕉', '芒果', '椰子']; // 热带水果
return tropicFruits.includes(name) ? '热带水果':'其他水果';
};

// 添加实例级别方法
Fruit.prototype.totalPrice = function(count) {
return (this.price * count).toFixed(2);
};

// 使用类方法
['香蕉','草莓'].forEach(f => console.log(f+'是'+Fruit.classify(f))); 

// 使用实例方法
Fruit.findAll().then(fruits => {
const [f1] = fruits;
console.log(`买5kg${f1.name}需要￥${f1.totalPrice(5)}`);      
});

数据查询

// 通过id查询(不支持了)
Fruit.findById(1).then(fruit => {
// fruit是一个Fruit实例，若没有则为null
console.log(fruit.get());
});


// 通过属性查询
Fruit.findOne({ where: { name: "香蕉" } }).then(fruit => {
// fruit是首个匹配项，若没有则为null
console.log(fruit.get());
});

// 指定查询字段
Fruit.findOne({ attributes: ['name'] }).then(fruit => {
// fruit是首个匹配项，若没有则为null
console.log(fruit.get());
    开课吧web全栈架构师
});

// 获取数据和总条数
Fruit.findAndCountAll().then(result => {
console.log(result.count);
console.log(result.rows.length);
});

// 查询操作符
const Op = Sequelize.Op;
Fruit.findAll({
// where: { price: { [Op.lt]:4 }, stock: { [Op.gte]: 100 } }
where: { price: { [Op.lt]:4,[Op.gt]:2 }}
}).then(fruits => {
console.log(fruits.length);
});

// 或语句
Fruit.findAll({
// where: { [Op.or]:[{price: { [Op.lt]:4 }}, {stock: { [Op.gte]: 100 }}] 
}
where: { price: { [Op.or]:[{[Op.gt]:3 }, {[Op.lt]:2 }]}}
}).then(fruits => {
console.log(fruits[0].get());
});

// 分页
Fruit.findAll({
offset: 0, 
limit: 2,
})

// 排序
Fruit.findAll({
order: [['price', 'DESC']],
})

// 聚合
Fruit.max("price").then(max => {
console.log("max", max);
});
Fruit.sum("price").then(sum => {
console.log("sum", sum);
});

更新

Fruit.findById(1).then(fruit => {
// 方式1
fruit.price = 4;
fruit.save().then(()=>console.log('update!!!!'));
});
// 方式2
Fruit.update({price:4}, {where:{id:1}}).then(r => {
console.log(r);
console.log('update!!!!')
})
    开课吧web全栈架构师
删除

// 方式1
Fruit.findOne({ where: { id: 1 } }).then(r => r.destroy());

// 方式2
Fruit.destroy({ where: { id: 1 } }).then(r => console.log(r));



实体关系图和与域模型 ERD


初始化数据库

// 初始化数据库
const sequelize = require('./util/database');
const Product = require('./models/product');
const User = require('./models/user');
const Cart = require('./models/cart');
const CartItem = require('./models/cart-item');
const Order = require('./models/order');
const OrderItem = require('./models/order-item');


Product.belongsTo(User, {
constraints: true,
onDelete: 'CASCADE'
});
User.hasMany(Product);
User.hasOne(Cart);
Cart.belongsTo(User);
Cart.belongsToMany(Product, {
through: CartItem
        开课吧web全栈架构师
});
Product.belongsToMany(Cart, {
through: CartItem
});
Order.belongsTo(User);
User.hasMany(Order);
Order.belongsToMany(Product, {
through: OrderItem
});
Product.belongsToMany(Order, {
through: OrderItem
});

同步数据

// 同步数据
sequelize.sync().then(
async result => {
let user = await User.findByPk(1)
if (!user) {
user = await User.create({
name: 'Sourav',
email: 'sourav.dey9@gmail.com'
})
await user.createCart();
}
app.listen(3000, () => console.log("Listening to port 3000"));
})


中间件鉴权

app.use(async (ctx, next) => {
const user = await User.findByPk(1)
ctx.user = user;
await next();
});



功能实现

const router = require('koa-router')()
/**
* 查询产品
*/
router.get('/admin/products', async (ctx, next) => {
// const products = await ctx.user.getProducts()
const products = await Product.findAll()
ctx.body = { prods: products }
})

/**
* 创建产品
*/
router.post('/admin/product', async ctx => {
            开课吧web全栈架构师
const body = ctx.request.body
const res = await ctx.user.createProduct(body)
ctx.body = { success: true }
})

/**
* 删除产品
*/
router.delete('/admin/product/:id', async (ctx, next) => {
const id = ctx.params.id
const res = await Product.destroy({
where: {
id
}
})
ctx.body = { success: true }
})

/**
* 查询购物车
*/
router.get('/cart', async ctx => {
const cart = await ctx.user.getCart()
const products = await cart.getProducts()
ctx.body = { products }
})

/**
* 添加购物车
*/
router.post('/cart', async ctx => {
const { body } = ctx.request
const prodId = body.id
let newQty = 1
const cart = await ctx.user.getCart()
const products = await cart.getProducts({
where: {
id: prodId
}
})

let product
if (products.length > 0) {
product = products[0]
}
if (product) {
const oldQty = product.cartItem.quantity
newQty = oldQty + 1
} else {
product = await Product.findByPk(prodId)
}
await cart.addProduct(product, {
through: {
quantity: newQty
}
})
ctx.body = { success: true }
})
    开课吧web全栈架构师
/**
* 添加订单
*/
router.post('/orders', async ctx => {
const cart = await ctx.user.getCart()
const products = await cart.getProducts()
const order = await ctx.user.createOrder()
const result = await order.addProduct(
products.map(p => {
p.orderItem = {
quantity: p.cartItem.quantity
}
return p
})
)
await cart.setProducts(null)
ctx.body = { success: true }
})

/**
* 删除购物车
*/
router.delete('/cartItem/:id', async ctx => {
const id = ctx.params.id
const cart = await ctx.user.getCart()
const products = await cart.getProducts({
where: { id }
})
const product = products[0]
await product.cartItem.destroy()
ctx.body = { success: true }
})

/**
* 查询订单
*/
router.get('/orders', async ctx => {
const orders = await ctx.user.getOrders({ include: ['products'], order: 
[['id', 'DESC']] })
ctx.body = { orders }
})


app.use(router.routes())









Restful服务

实践指南 http://www.ruanyifeng.com/blog/2014/05/restful_api.html

原理 http://www.ruanyifeng.com/blog/2011/09/restful.html
            开课吧web全栈架构师


TODO List范例

https://github.com/BayliSade/TodoList





关于新版本的警告问题

https://segmentfault.com/a/1190000011583806


购物车相关接口实现                                                                                   


作业:

sequelize + sqllite3  实现一个一对多关系

提交代码截图

本例中使用内存数据库模拟不需要安装数据库

根据测试用例内容建立用户和商品数据模型

并设置合理的数据关系

使数据模型生效


    开课吧web全栈架构师
Mac mysql安装⽂档

1.⾸先进⼊官⽹下载安装包

官⽹地址: https://www.mysql.com/

进⼊后选择如下:





    开课吧web全栈架构师
2.打开安装包安装


开课吧web全栈架构师
开课吧web全栈架构师
开课吧web全栈架构师
3.MySQL配置

1.打开系统偏好设置，在最下⽅找到 MySQL，然后点击 Start MySQL Server


    开课吧web全栈架构师
2.打开 ﬁnder(访达)，点击菜单栏的 前往➞前往⽂件夹...，然后输⼊ /usr/local/mysql/bin，回⻋，查看
该⽬录下是否有 mysql，如下图所示：


3.打开终端，输⼊ cd /usr/local/mysql/bin，然后输⼊pwd确认⼀下⾃⼰当前是处于这个⽬录下


4.接着输⼊ vim ~/.bash_proﬁle，然后在此⽂件中添加 mysql 的 bin ⽬录（这⾥⽤的是 vim 的输⼊模
式，不会的请⾃⾏百度，博主认为对于程序员来说会使⽤简单的 vim 命令是必须的），如下图所示：


\5. 添加完成后，按 esc，然后切换到英⽂输⼊法，按下 shift + :，再输⼊wq，回⻋（这⼀步的⽬的是保
存并退出这个⽂件，⽤的也是 vim 的输⼊模式）

\6. 接着输⼊ source ~/.bash_proﬁle，回⻋，以使刚才的配置⽣效。⾄此，mysql 的配置已经完成了

Mac MySQL Workbench 安装说明

1.下载


    开课吧web全栈架构师
2.打开安装包直接安装好后显示如下


3.添加⽤户并设置权限

    开课吧web全栈架构师
4.连接数据库

下载mysql依赖:npm i mysql –S

导⼊mysql模块 const mysql = require('mysql')

设置⽤户密码等连接数据库


    开课吧web全栈架构师
Windows MySQL安装⽂档

1.⾸先进⼊官⽹下载安装包

官⽹地址: https://www.mysql.com/

选择如下downloads并下滑选择下载: 


2.点击选择mysql进⼊


    开课吧web全栈架构师
3.找到下图指示地⽅找到MSI安装


                                                            


    开课吧web全栈架构师
                                                        




4.下载好后,打开安装包开始安装 


                                                            


5.设置安装路径和数据存放路径

    开课吧web全栈架构师
                


开课吧web全栈架构师
                                        


6.下⼀步


                                            


开课吧web全栈架构师
7.安装sql Server


                                                        


8.执⾏下⼀步
    开课吧web全栈架构师
                                                        


9.默认执⾏下⼀步


                                                        


10.下⼀步

    开课吧web全栈架构师
                                                        


11.选择加密⽅式


                                                        


12.设置密码

    开课吧web全栈架构师
                                                        


13.设置服务名称


                                                        


14.下⼀步安装

    开课吧web全栈架构师
                                                        


15.执⾏下⼀步


                                                        


16.完成安装

    开课吧web全栈架构师
                                                        


安装失败后控制⾯板卸载mysql,将安装⽂件夹清空, c盘下Program Files和Program Files(X86)中只要有
mysql⽂件夹都删了重新安装   

删除mysql服务可以通过管理员进⼊命令提示符,输⼊ sc delete + mysql服务名即可 

Windows MySQL Workbench 安装说明

1.⾸先进⼊官⽹下载安装包

官⽹地址: https://www.mysql.com/

进⼊后选择如下:


                                                        




    开课吧web全栈架构师
                                                        





                                                        


                                                        


2.打开安装包开始安装


    开课吧web全栈架构师
                                    


3.选择安装位置


                                    


开课吧web全栈架构师
                                    





                                    




4.开始安装


开课吧web全栈架构师
                                                


5.安装完成


                                                


6.连接


    开课吧web全栈架构师
                                                        


7.添加⽤户,设置权限


                                                        


    开课吧web全栈架构师
                                                        


                                                        


8.连接数据库

下载mysql依赖:npm i mysql –S

导⼊mysql模块 const mysql = require('mysql') 

设置⽤户密码等连接数据库


    开课吧web全栈架构师
    





开课吧web全栈架构师
关联                                                                                                  

// 1:N关系
const Player = sequelize.define('player', {name: Sequelize.STRING});
const Team  = sequelize.define('team', {name: Sequelize.STRING});

// 会添加teamId到Player表作为外键
Player.belongsTo(Team); // 1端建⽴关系
Team.hasMany(Player); // N端建⽴关系

// 同步
sequelize.sync({force:true}).then(async ()=>{
await Team.create({name: '⽕箭'});
await Player.bulkCreate([{name: '哈登', teamId:1},{name: '保罗', teamId:1}]);

// 1端关联查询  
const players = await Player.findAll({include:[Team]});
console.log(JSON.stringify(players,null,2));

// N端关联查询
const team = await Team.findOne({where:{name:'⽕箭'},include:[Player]});
console.log(JSON.stringify(team,null,2));
});


// 多对多关系
const Fruit = sequelize.define("fruit", { name: Sequelize.STRING });
const Category = sequelize.define("category", { name: Sequelize.STRING });
Fruit.FruitCategory = Fruit.belongsToMany(Category, {
through: "FruitCategory"
});

// 插⼊测试数据
sequelize.sync({ force: true }).then(async () => {
await Fruit.create(
{
name: "⾹蕉",
categories: [{ id: 1, name: "热带" }, { id: 2, name: "温带" }]
},
{
include: [Fruit.FruitCategory]
}
);
// 多对多联合查询
const fruit = await Fruit.findOne({
where: { name: "⾹蕉" }, // 通过through指定条件、字段等

        开课吧web全栈架构师
include: [{ model: Category, through: { attributes: ['id', 'name'] 
} }]
});
})




        开课吧web全栈架构师
KeystoneJS                                                                                          

安装

npm install -g yo
npm install -g generator-keystone
yo keystone


运⾏

npm start



登⼊后台

#⽤户名
user@keystonejs.com
#密码
admin



增加⼀个实例

var keystone = require('keystone');
var Types = keystone.Field.Types;

var Order = new keystone.List('Order');

Order.add({
name: { type: Types.Text, required: true, index: true },
date: { type: Types.Date },
text: { type: Types.Text },
markdown: { type: Types.Markdown},
code: { type: Types.Code},
color: { type: Types.Color},
});

Order.register();





            开课吧web全栈架构师
源码

// keystone/admin/app/createDynamicRouter.js






            开课吧web全栈架构师
conf.js

module.exports = {
db: {
url:"mongodb://localhost:27017/test",
options: { useNewUrlParser: true }
}
}

model/user.js



通⽤路由 + 通⽤中间件

module.exports = {
schema: {
mobile: { type: String, required: true },
realName: { type: String, required: true },
}
}

index.js

const Koa = require('koa')
const app = new Koa()

const port = 3000
app.listen(port,() => {
console.log(`app started at port ${port}...`)
})




// framework/loader.js

const fs = require('fs')
const path = require('path')
const mongoose = require('mongoose')

function load(dir, cb) {
// 获取绝对路径
const url = path.resolve(__dirname, dir)
const files = fs.readdirSync(url)
files.forEach(filename => {

        开课吧web全栈架构师
// 去掉后缀名
filename = filename.replace('.js', '')
// 导⼊⽂件
const file = require(url + '/' + filename)
// 处理逻辑
cb(filename, file)
})
}

const loadModel = config => app => {
mongoose.connect(config.db.url, config.db.options);
const conn = mongoose.connection
conn.on("error", () => console.error("连接数据库失败"))
app.$model = {}
load('../model', (filename, { schema }) => {
console.log('load model: ' + filename, schema)
app.$model[filename] = mongoose.model(filename, schema)
})
}

module.exports = {
loadModel
}

通过loader加载数据模型

// index.js
// 初始化数据库
const config = require('./conf')
const {loadModel} = require('./framework/loader.js')
loadModel(config)(app)

/framework/router.js

const router = require('koa-router')()
const {
init, get, create, update, del,list
} = require('./api')

router.get('/api/:list/:id', init, get)
router.get('/api/:list', init, list)
router.post('/api/:list', init,create)
router.put('/api/:list/:id', init, update)
router.delete('/api/:list/:id', init, del)

module.exports = router.routes()

api/user/ crud

            开课吧web全栈架构师
/framework/api.js

module.exports = {
async init(ctx, next) {
console.log(ctx.params)
const model = ctx.app.$model[ctx.params.list]
if (model) {
ctx.list = model
await next()
} else {
ctx.body = 'no this model'
}
},

async list(ctx) {
ctx.body = await ctx.list.find({})

},
async get(ctx) {
ctx.body = await ctx.list.findOne({ _id: ctx.params.id })

},
async create(ctx) {
const res = await ctx.list.create(ctx.request.body)
ctx.body = res
},
async update(ctx) {
const res = await ctx.list.updateOne({ _id: ctx.params.id }, 
ctx.request.body)
ctx.body = res
},
async del(ctx) {
const res = await ctx.list.deleteOne({ _id: ctx.params.id })
ctx.body = res
},
async page(ctx) {
console.log('page...', ctx.params.page)
ctx.body = await ctx.list.find({})/*  */
},
}


加载路由


            开课吧web全栈架构师
const bodyParser = require('koa-bodyparser')
app.use(bodyParser())
app.use(require('koa-static')(__dirname + '/'))
const restful = require('./framework/router')
app.use(restful)






    开课吧web全栈架构师
持久化之mongodb                                                                             

回顾                                                                                      

数据持久化之关系型数据库mysql应⽤

原⽣mysql驱动node-mysql应⽤

ORM模块Sequelize的应⽤


课堂⽬标                                                                                    

掌握mongodb基本使⽤
理解⽂档型数据库设计理念
掌握原⽣模块node-mongodb-native应⽤
掌握ODM模块mongoose应⽤
了解快速开发⼯具KeyStoneJS


资源                                                                                      

mongodb相关：

MongoDB：下载
node驱动：⽂档
mongoose：⽂档
redis相关：

redis：下载
node_redis：⽂档
可视化⼯具：Robo3T



LAMP 或 LNMP (Linux Nginx Mysql PHP) 与 MEAN


        开课吧全栈工程师
mongodb安装、配置                                                                                        

下载安装
配置环境变量
创建dbpath⽂件夹
启动：

mongo
// 默认连接

测试：

// helloworld.js
// 查询所有数db据库
show dbs

// 切换/创建数据库,当创建⼀个集合(table)的时候会⾃动创建当前数据库
use test

// 插⼊⼀条数据
db.fruits.save({name:'苹果',price:5})

// 条件查询
db.fruits.find({price:5})
`1234`

// 得到当前db的所有聚集集合
db.getCollectionNames()

// 查询
db.fruits.find()


mongo命令⾏操作

                开课吧全栈工程师
参考资料

菜⻦⽂档

http://www.runoob.com/mongodb/mongodb-create-database.html  
官⽹

https://docs.mongodb.com/manual/reference/method/


mongodb原⽣驱动                                                                                         

http://mongodb.github.io/node-mongodb-native/3.1/quick-start/quick-start/

官⽹API

https://www.cnblogs.com/chen-lhx/p/6004623.html

操作符

安装mysql模块：        npm install mongodb --save      
连接mongodb

(async () => {
const { MongoClient } = require('mongodb')

// 创建客户端
const client = new MongoDB(
'mongodb://localhost:27017',
{
//userNewUrlParser这个属性会在url⾥识别验证⽤户所需的db
userNewUrlParser: true
}
)
let ret
// 创建连接
ret = await client.connect()
console.log('ret:', ret)

const db = client.db('test')

const fruits = db.collection('fruits')

// 添加⽂档
ret = await fruits.insertOne({
name: '芒果',
price: 20.1
})
console.log('插⼊成功', JSON.stringify(ret))

// 查询⽂档

                开课吧全栈工程师
ret = await fruits.findOne()
console.log('查询⽂档:', ret)

// 更新⽂档 
// 更新的操作符 $set
ret = await fruits.updateOne({ name: '芒果' }, 
{ $set: { name: '苹果' } })
console.log('更新⽂档', JSON.stringify(ret.result))

// 删除⽂档
ret = await fruits.deleteOne({name: '苹果'})

await fruits.deleteMany()

client.close()

})()

案例：⽠果超市

提取数据库配置,./models/conf.js

// models/conf.js
module.exports = {
url: "mongodb://localhost:27017",
dbName: 'test',
}



封装数据库连接，./models/db.js

const conf = require("./conf");
const EventEmitter = require("events").EventEmitter;

// 客户端
const MongoClient = require("mongodb").MongoClient;

class Mongodb {
constructor(conf) {
// 保存conf
this.conf=conf;

this.emmiter = new EventEmitter();
// 连接
this.client = new MongoClient(conf.url, { useNewUrlParser: true });
this.client.connect(err => {
if (err) throw err;
console.log("连接成功");

            开课吧全栈工程师
this.emmiter.emit("connect");
});
}

col(colName, dbName = conf.dbName) {
return this.client.db(dbName).collection(colName);
}

once(event, cb) {
this.emmiter.once(event, cb);
}
}

// 2.导出db
module.exports = new Mongodb(conf);

eventEmmiter

// eventEmmiter.js
const EventEmitter = require('events').EventEmitter; 
const event = new EventEmitter(); 
event.on('some_event', num =>  { 
console.log('some_event 事件触发:'+num); 
}); 
let num = 0
setInterval(() =>  { 
event.emit('some_event' , num ++ ); 
}, 1000); 


添加测试数据，./initData.js

const mongodb = require('./models/db')
mongodb.once('connect', async () => {
const col = mongodb.col('fruits')
// 删除已存在
await col.deleteMany()
const data = new Array(100).fill().map((v, i) => {
return { name: "XXX" + i, price: i, category: Math.random() > 0.5 
? '蔬菜' : '⽔果' }
})

// 插⼊
await col.insertMany(data)
console.log("插⼊测试数据成功")
})



            开课吧全栈工程师
前端⻚⾯调⽤ index.html

<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-
scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />

<!-- <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">
</script> -->
<script src="https://cdn.bootcss.com/vue/2.6.11/vue.min.js">
</script>
<script src="https://cdn.bootcss.com/element-ui/2.13.0/index.js">
</script>
<script src="https://cdn.bootcss.com/axios/0.19.2/axios.js">
</script>
<link href="https://cdn.bootcss.com/element-ui/2.13.0/theme-
chalk/index.css" rel="stylesheet">

<title>⽠果超市</title>
</head>

<body>
<div id="app">
<el-input placeholder="请输⼊内容" v-model="search" 
class="input-with-select"  @change="changeHandler">
<el-button slot="append" icon="el-icon-search"></el-
button>
</el-input>
<el-radio-group v-model="category" @change="getData">
<el-radio-button v-for="v in categorys" :label="v" 
:key="v">{{v}}</el-radio-button>
</el-radio-group>
<el-table :data="fruits" style="width: 100%">
<el-table-column prop="name" label="名称" width="180">
</el-table-column>
<el-table-column prop="price" label="价格" width="180">
</el-table-column>
<el-table-column prop="category" label="种类">
</el-table-column>
</el-table>
<el-pagination layout="prev, pager, next" @current-
change="currentChange" :total="total">
</el-pagination>
</div>
<script>

    开课吧全栈工程师
var app = new Vue({
el: "#app",
data: {
page: 1,
total: 0,
fruits: [],
categorys: [],
category: [],
search:''
},
created() {
this.getData()

this.getCategory()
},
methods: {
async currentChange(page) {
this.page = page;
await this.getData()
},
async changeHandler(val){
console.log('search...',val)
this.search = val
await this.getData()
},
async getData() {
const res = await axios.get(`/api/list?
page=${this.page}&category=${this.category}&keyword=${this.search}`)
const data = res.data.data
this.fruits = data.fruits
this.total = data.pagination.total
},
async getCategory() {
const res = await axios.get(`/api/category`)
this.categorys = res.data.data
console.log('category', this.categorys)
}
}
});
</script>
</body>

</html>



接⼝编写，index.js

const express = require("express")

        开课吧全栈工程师
const app = express()
const path = require("path")
const mongo = require("./models/db")
// const testdata = require("./initData")

app.get("/", (req, res) => {
res.sendFile(path.resolve("./index.html"))
})

app.get("/api/list", async (req, res) => {
// 分⻚查询
const { page} = req.query
try {
const col = mongo.col("fruits")
const total = await col.find().count()
const fruits = await col
.find()
.skip((page - 1) * 5)
.limit(5)
.toArray()
res.json({ ok: 1, data: { fruits, pagination: { total, page } } })
} catch (error) {
console.log(error)
}
})

app.listen(3000)


增加类别搜索功能

app.get("/api/category", async (req, res) => {
const col = mongo.col("fruits")
const data = await col.distinct('category')
res.json({ ok: 1, data })
})

app.get("/api/list", async (req, res) => {
// 分⻚查询
const { page, category ,keyword} = req.query

// 构造条件
const condition = {}
if (category) {
condition.category = category
}

if (keyword) {

        开课吧全栈工程师
condition.name = { $regex: new RegExp(keyword)  }
}

// 增加
const total = await col.find(condition).count()
const fruits = await col
.find(condition)   // 增加
.skip((page - 1) * 5)
.limit(5)
.toArray()

})










操作符

https://docs.mongodb.com/manual/reference/operator/query/ 
操作符⽂档

查询操作符：提供多种⽅式定位数据库数据

// ⽐较$eq，$gt，$gte，$in等
await col.find({price:{$gt:10}}).toArray()

// 逻辑$and,$not,$nor,$or
// price>10 或 price<5
await col.find({$or: [{price:{$gt:10}},{price:{$lt:5}}]}) 
// price不⼤于10且price不⼩于5
await col.find({$nor: [{price:{$gt:10}},{price:{$lt:5}}]}) 

// 元素$exists，$type
await col.insertOne({ name: "芒果", price: 20.0, stack:true })
await col.find({stack:{$exists:true}})

// 模拟$regex，$text，$expr
await col.find({name:{$regex:/芒/}})
await col.createIndex({name:'text'}) // 验证⽂本搜索需⾸先对字段加索引
await col.find({$text:{$search:'芒果'}}) // 按词搜索，单独字查询不出结果

// 数组$all,$elemMatch,$size
col.insertOne({..., tags: ["热带", "甜"]}) // 插⼊带标签数据
// $all：查询指定字段包含所有指定内容的⽂档
await col.find({ tags: {$all:['热带','甜'] } }  

        开课吧全栈工程师
// $elemMatch: 指定字段数组中⾄少有⼀个元素满⾜所有查询规则  
col.insertOne({hisPrice: [20,25,30]}); // 数据准备
col.find({ hisPrice: { $elemMatch: { $gt: 24,$lt:26 } } }) // 历史价位有
没有出现在24~26之间

// 地理空间$geoIntersects,$geoWithin,$near,$nearSphere
// 创建stations集合
const stations = db.collection("stations");
// 添加测试数据，执⾏⼀次即可
await stations.insertMany([ 
{ name: "天安⻔东", loc: [116.407851, 39.91408] },
{ name: "天安⻔⻄", loc: [116.398056, 39.913723] },
{ name: "王府井", loc: [116.417809, 39.91435] }
]);
await stations.createIndex({ loc: "2dsphere" });
r = await stations.find({
loc: {
$nearSphere: {
$geometry: {
type: "Point",
coordinates: [116.403847, 39.915526]
},
$maxDistance: 1000
}
}
}).toArray();
console.log("天安⻔附近地铁站", r);



更新操作符：可以修改数据库数据或添加附加数据

// 字段相关：$set,$unset,$setOnInsert,$rename,$inc,$min,$max,$mul
// 更新多个字段
await fruitsColl.updateOne(
{ name: "芒果" }, 
{ $set: { price: 19.8, category: '热带⽔果' } }, 
);
// 更新内嵌字段
{ $set: { ..., area: {city: '三亚'} } }

// 数组相关：$,$[],$addToSet,$pull,$pop,$push,$pullAll
// $push⽤于新增
insertOne({tags: ['热带','甜']}) //添加tags数组字段
fruitsColl.updateMany({ name: "芒果" }, { $push: {tags: '上⽕'}})
// $pull,$pullAll⽤于删除符合条件项，$pop删除⾸项-1或尾项1
fruitsColl.updateMany({ name: "芒果" }, { $pop: {tags: 1}})
fruitsColl.updateMany({ name: "芒果" }, { $pop: {tags: 1}})

    开课吧全栈工程师
// $，$[]⽤于修改
fruitsColl.updateMany({ name: "芒果", tags: "甜" }, { $set: {"tags.$": 
"⾹甜"} })

// 修改器，常结合数组操作符使⽤：$each,$position,$slice,$sort
$push: { tags: { $each: ["上⽕", "真⾹"], $slice: -3 } }



聚合操作符：使⽤aggregate⽅法，使⽂档顺序通过管道阶段从⽽得到最终结果


// 聚合管道阶段：$group,$count,$sort,$skip,$limit,$project等
// 分⻚查询
r = await fruitsColl
.aggregate([{ $sort: { price: -1 } }, { $skip: 0 }, { $limit: 2 
}])
.toArray();
// 投射:只选择name,price并排除_id
fruitsColl.aggregate([..., {$project:
{name:1,price:1,_id:0}}]).toArray();

// 聚合管道操作符：$add,$avg,$sum等
// 按name字段分组，统计组内price总和
fruitsColl.aggregate([{ $group:{_id:"$name",total:
{$sum:"$price"}}}]).toArray();

常⽤聚合管道阶段操作均有对应的单个⽅法，通过Cursor调⽤

await fruitsColl.ﬁnd().count()

    开课吧全栈工程师
await fruitsColl.ﬁnd().sort({ price: -1 }).skip(0).limit(2) .project({name:1,price:1}) 
.toArray();




ODM - Mongoose                                                                                      

概述：优雅的NodeJS对象⽂档模型object document model。Mongoose有两个特点：
通过关系型数据库的思想来设计⾮关系型数据库

基于mongodb驱动，简化操作


安装：    npm install mongoose -S

基本使⽤：

// mongoose.js
const mongoose = require("mongoose");

// 1.连接
mongoose.connect("mongodb://localhost:27017/test", { useNewUrlParser: true 
});

const conn = mongoose.connection;
conn.on("error", () => console.error("连接数据库失败"));
conn.once("open", async () => {
// 2.定义⼀个Schema - Table
const Schema = mongoose.Schema({
category: String,
name: String
});

// 3.编译⼀个Model, 它对应数据库中复数、⼩写的Collection
const Model = mongoose.model("fruit", Schema);
try {
// 4.创建，create返回Promise
let r = await Model.create({
category: "温带⽔果",
name: "苹果",
price: 5
});
console.log("插⼊数据:", r);

                开课吧全栈工程师
// 5.查询，find返回Query，它实现了then和catch，可以当Promise使⽤
// 如果需要返回Promise，调⽤其exec()
r = await Model.find({ name: "苹果" });
console.log("查询结果:", r);

// 6.更新，updateOne返回Query
r = await Model.updateOne({ name: "苹果" }, { $set: { name: '芒果' } });
console.log("更新结果：", r);

// 7.删除，deleteOne返回Query
r = await Model.deleteOne({ name: "苹果" });
console.log("删除结果：", r);
} catch (error) {
console.log(error);
}
});

Mongoose中各概念和关系数据库、⽂档数据库对应关系：


Schema
字段定义

const blogSchema = mongoose.Schema({
title: { type: String, required: [true, '标题为必填项'] }, // 定义校验规则
author: String,
body: String,
comments: [{ body: String, date: Date }], // 定义对象数组
date: { type: Date, default: Date.now }, // 指定默认值
hidden: Boolean,
meta: {
// 定义对象
votes: Number,
favs: Number
}
});

        开课吧全栈工程师
// 定义多个索引
blogSchema.index({ title:1, author: 1, date: -1 });
const BlogModel = mongoose.model("blog", blogSchema);
const blog = new BlogModel({
title: "nodejs持久化",
author: "jerry",
body: "...."
});
const r = await blog.save();
console.log("新增blog", r);

可选字段类型：

String
Number
Date
Buﬀer
Boolean
Mixed
ObjectId
Array

避免创建索引警告：

mongoose.connect("mongodb://localhost:27017/test", {
useCreateIndex: true
})

定义实例⽅法：抽象出常⽤⽅法便于复⽤

// 定义实例⽅法
blogSchema.methods.findByAuthor = function () {
return this.model('blog').find({ author: this.author }).exec();
}

// 获得模型实例
const BlogModel = mongoose.model("blog", blogSchema);
const blog = new BlogModel({...});

// 调⽤实例⽅法
r = await blog.findByAuthor();
console.log('findByAuthor', r);

实例⽅法还需要定义实例，⽤起来较繁琐，可以使⽤静态⽅法

静态⽅法


        开课吧全栈工程师
blogSchema.statics.findByAuthor = function(author) {
return this.model("blog")
.find({ author })
.exec();
};

r=await BlogModel.findByAuthor('jerry')
console.log("findByAuthor", r);


虚拟属性

blogSchema.virtual("commentsCount").get(function() {
return this.comments.length;
});
r = await BlogModel.findOne({author:'jerry'});
console.log("blog留⾔数：", r.commentsCount);


购物⻋相关接⼝实现                                                                                           

mongoose.js

// mongoose.js
const mongoose = require("mongoose");
// 1.连接
mongoose.connect("mongodb://localhost:27017/test", { useNewUrlParser: true 
});
const conn = mongoose.connection;
conn.on("error", () => console.error("连接数据库失败"));




⽤户模型，./models/user.js

const mongoose = require("mongoose");

const schema = mongoose.Schema({
name: String,
password: String,
cart: []
});

schema.statics.getCart = function(_id) {
return this.model("user")

                开课吧全栈工程师
.findById(_id)
.exec();
};

schema.statics.setCart = function(_id, cart) {
return this.model("user")
.findByIdAndUpdate(_id, { $set: { cart } })
.exec();
};

const model = mongoose.model("user", schema);

// 测试数据
model.updateOne(
{ _id: "5c1a2dce951e9160f0d8573b" },
{ name: "jerry", cart: [{ pname: "iPhone", price: 666, count: 1 }] },
{ upsert: true },
(err, r) => {
console.log('测试数据');
console.log(err, r);
}
);

module.exports = model;



API编写，./index.js



// mongoose.js
const mongoose = require("mongoose");
// 1.连接
mongoose.connect("mongodb://localhost:27017/test", { useNewUrlParser: true });
const conn = mongoose.connection;
conn.on("error", () => console.error("连接数据库失败"));



// models/user.js
const mongoose = require("mongoose");

const schema = mongoose.Schema({
name: String,
password: String,
cart: []
});

schema.statics.getCart = function(_id) {

            开课吧全栈工程师
return this.model("user")
.findById(_id)
.exec();
};

schema.statics.setCart = function(_id, cart) {
return this.model("user")
.findByIdAndUpdate(_id, { $set: { cart } })
.exec();
};

const model = mongoose.model("user", schema);

// 测试数据
model.updateOne(
{ _id: "5c1a2dce951e9160f0d8573b" },
{ name: "jerry", cart: [{ pname: "iPhone", price: 666, count: 1 }] },
{ upsert: true },
(err, r) => {
console.log('测试数据');
console.log(err, r);
}
);

module.exports = model;



// index.js
const express=require('express')
const app=new express();
const bodyParser = require('body-parser');
const path = require('path')

// 数据库相关
require('./mongoose')
const UserModel = require('./models/user')

// mock session
const session = {sid:{userId:'5c1a2dce951e9160f0d8573b'}}

app.use(bodyParser.json()); 
app.get("/", (req, res) => {
res.sendFile(path.resolve("./index.html"))
})
// 查询购物⻋数据
app.get('/api/cart', async (req,res)=>{
const data = await UserModel.getCart(session.sid.userId)
res.send({ok:1, data})

            开课吧全栈工程师
})

// 设置购物⻋数据
app.post('/api/cart', async (req,res)=>{
await UserModel.setCart(session.sid.userId, req.body.cart)
res.send({ok:1})
})

app.listen(3000);

index.html

<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://unpkg.com/element-ui/lib/index.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-
chalk/index.css" />
<title>⽠果超市</title>
</head>
<body>
<div id="app">
<el-button @click='getCart'>getCart</el-button>
<el-button @click='setCart'>setCart</el-button>
</div>
<script>
var app = new Vue({
el: "#app",
methods: {
async getCart(page) {
const ret = await axios.get('/api/cart')
console.log('ret:', ret.data.data)
},
async setCart() {
const ret = await axios.post(
'/api/cart', {
cart:[
{
name:'菠萝',
count:1
}
]
}

                开课吧全栈工程师
)
}
}
});
</script>
</body>

</html>





模型

数据层

crud - mongoose 是不是⼀个通⽤问题 有规律的

restful接⼝ - ？ 

crud 界⾯ - ？后台界⾯

快速开发平台 jeecg mysql
KeystoneJS 4.0
py django





作业                                                                                      

练习使⽤订阅发布⽅式实现异步流程控制  

要求: 提交代码截图 - 可以使⽤Eventemitter函数不必⾃⼰实现



上课脑图地址： 

node： https://www.processon.com/view/link/5d4b852ee4b07c4cf3069fec#map

事件循环：https://www.processon.com/view/link/5e70b1c2e4b011fcce9b89b5#map








        开课吧全栈工程师
docker环境搭建教程                                                                                        

docker环境搭建教程
VirtualBox下载并安装
下载
傻⽠式安装 
下载ubuntu镜像
VirtualBox中安装Ubuntu
登录配置
docker安装
docker-compose安装

VirtualBox下载并安装                                                                                     

下载                                                                                                  

VirtualBox下载地址

傻⽠式安装                                                                                               


            开课吧web全栈架构师
开课吧web全栈架构师
开课吧web全栈架构师

下载ubuntu镜像                                     

ubuntu镜像下载地址


VirtualBox中安装Ubuntu                            

点击新建创建虚拟机


开课吧web全栈架构师
选择分配的虚拟机内存⼤⼩视⾃⼰情况⽽定，默认1024MB，我这⾥选择2048MB


创建虚拟硬盘


        开课吧web全栈架构师
开课吧web全栈架构师
⾄此，⼀台Ubuntu虚拟机已经创建完成，接下来导⼊下载的阿⾥云镜像


        开课吧web全栈架构师


修改⽹卡连接⽅式为桥接⽹卡




然后启动虚拟机开始安装Ubuntu系统

        开课吧web全栈架构师



开课吧web全栈架构师



开课吧web全栈架构师



开课吧web全栈架构师



开课吧web全栈架构师


填写信息的时候⼀定要注意把密码记住，后续登录需要使⽤


        开课吧web全栈架构师



开课吧web全栈架构师
安装完成，重新启动并登录

        开课吧web全栈架构师
登录配置                                                                                    

使⽤ssh登录，windows需要使⽤⼦系统，mac直接终端ssh安装即可

使⽤ifconﬁg查看ip地址


        开课吧web全栈架构师
windows⼦系统进⾏ssh登录

ssh ⽤户名@ip地址




使⽤root账户登录

# 使⽤root账户登录  输⼊密码
sudo  su 
# 编辑sshd配置⽂件
vi /etc/ssh/sshd_config
# 在 sshd_config ⽂件⾥的 “Authentication” 部分加上以下内容
PermitRootLogin yes
# 完成以后退出 vim 并保存
service sshd restart  # 重启 ssh 服务以应⽤更改
passwd root   # 直接修改 Root ⽤户的密码

这样重新登陆 ssh 就可以⽤ Root账户 登陆了


            开课吧web全栈架构师
配置ssh免密登录

# ⽣成ssh秘钥对
ssh-keygen -t rsa -P ''

退出到⼦系统


            开课吧web全栈架构师
# 拷⻉本地ssh公钥到虚拟机root账号下
scp ~/.ssh/id_rsa.pub root@10.20.19.108:/root/  

# ssh登录
ssh root@10.20.19.108 

# 将公钥加⼊信任列表
cat id_rsa.pub >> ~/.ssh/authorized_keys

免密登录配置完成，接下来就可以进⾏免密登录了


            开课吧web全栈架构师




docker安装                                                                                            

# apt升级
sudo apt-get update
# 添加相关软件包
sudo apt-get install \
apt-transport-https \
ca-certificates \
curl \
software-properties-common

# 下载软件包的合法性，需要添加软件源的 GPG 密钥
curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-
key add -

# source.list 中添加 Docker 软件源
sudo add-apt-repository \
"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \
$(lsb_release -cs) \
stable"

# 安装 Docker CE
sudo apt-get update
sudo apt-get install docker-ce


            开课吧web全栈架构师
#  启动   Docker CE
sudo  systemctl enable docker      等价于 chkconfig docker on
sudo  systemctl start     docker  等价于 service start docker

#  建⽴   docker  ⽤户组(附加)
sudo  groupadd docker
sudo  usermod   -aG  docker  $USER

# Helloworld测试
docker run hello-world



镜像加速

Azure 中国镜像      https://dockerhub.azk8s.cn
阿⾥云加速器(需登录账号获取)
七⽜云加速器        https://reg-mirror.qiniu.com

# /etc/docker/daemon.json
{
"registry-mirrors": [
"                                 ,
"
]
}

# 重启docker服务，使之⽣效
sudo systemctl daemon-reload
sudo systemctl restart docker



docker-compose安装                                                                                    

apt install docker-compose

使⽤docker-compose


            开课吧web全栈架构师
version: '3.1'
services:
mongo:
image: mongo
restart: always
ports:
- 27017:27017
mongo-express:
image: mongo-express
restart: always 
ports:
- 8081:8081



启动：    docker-compose up

关闭：    docker-compose down


            开课吧web全栈架构师
Koa实战 - 登录认证                                                                                              

课程目标                                                                                                      

掌握三种常见鉴权方式
Session/Cookie
Token
OAuth
SSO
session-cookie方式                                                                                          

cookie原理解析

// cookie.js
const http = require("http")
http
.createServer((req, res) => {
if(req.url === '/favicon.ico'){
res.end('')
return
}
// 观察cookie存在
console.log('cookie:', req.headers.cookie)
// 设置cookie
res.setHeader('Set-Cookie', 'cookie1=abc;')
res.end('hello cookie!!')
})
.listen(3000)

Header Set-Cookie负责设置cookie
请求传递Cookie



session的原理解释

// cookie.js
const http = require("http")
const session = {}
http
.createServer((req, res) => {
// 观察cookie存在
console.log('cookie:', req.headers.cookie)

const sessionKey = 'sid'
const cookie = req.headers.cookie
if(cookie && cookie.indexOf(sessionKey) > -1 ){
res.end('Come Back ')
// 简略写法未必具有通用性
const pattern = new RegExp(`${sessionKey}=([^;]+);?\s*`)
const sid = pattern.exec(cookie)[1]
                web全栈架构师
console.log('session:',sid ,session ,session[sid])
} else {
const sid = (Math.random() * 99999999).toFixed()
// 设置cookie
res.setHeader('Set-Cookie', `${sessionKey}=${sid};`)
session[sid] = {name : 'laowang'}
res.end('Hello')
}
res.end('hello cookie!!')
})
.listen(3000)

session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信
息。

原理


实现原理：

1. 服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion(我们可以将
seesion保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一
个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。 
2. 签名。这一步通过秘钥对sid进行签名处理，避免客户端修改sid。（非必需步骤） 
3. 浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次
http请求的请求头中会带上该域名下的cookie信息， 
4. 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端
保存的该客户端的session，然后判断该请求是否合法。



哈希Hash - SHA MD5

- 把一个不定长摘要定长结果
- 摘要 yanglaoshi -> x
- 雪崩效应

摘要

            web全栈架构师
对称DES

非对称 - RSA



koa中的session使用：         npm i koa-session -S

// index.js
const koa = require('koa')
const app = new koa()
const session = require('koa-session')

// 签名key keys作用 用来对cookie进行签名
app.keys = ['some secret'];

// 配置项
const SESS_CONFIG = {
key: 'kkb:sess', // cookie键名
maxAge: 86400000, // 有效期，默认一天
httpOnly: true, // 仅服务器修改
signed: true, // 签名cookie
};

// 注册
app.use(session(SESS_CONFIG, app));

// 测试
app.use(ctx => {
if (ctx.path === '/favicon.ico') return;
// 获取
let n = ctx.session.count || 0;
// 设置
ctx.session.count = ++n;
ctx.body = '第' + n + '次访问';
});

app.listen(3000)



##### 使用redis存储session

redis介绍

- 是一个高性能的key-value数据库。



##### Redis 与其他 key - value 缓存产品有以下三个特点：

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的
存储。
- Redis支持数据的备份，即master-slave模式的数据备份。

##### Redis 优势

                web全栈架构师

- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered 
Sets 数据类型操作。
- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子
性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。



HMAC 



```js
// redis.js
const redis = require('redis');

const client = redis.createClient(6379,'localhost');

client.set('hello','This is a value');

client.get('hello',function (err,v) {
console.log("redis get ",v);
})




安装：     npm i -S koa-redis

配置使用：

// koa-redis
const redisStore = require('koa-redis');
const redis = require('redis')
const redisClient = redis.createClient(6379, "localhost");

const wrapper = require('co-redis');
const client = wrapper(redisClient);

app.use(session({
key:'kkb:sess',
store: redisStore({client}) // 此处可以不必指定client
}, app));

app.use(async (ctx,next) => {
const keys = await client.keys('*')
keys.forEach(async key =>
console.log(await client.get(key))
)
await next()
})

为什么要将session存储在外部存储中

Session信息未加密存储在客户端cookie中
浏览器cookie有长度限制
                web全栈架构师


session-cookie方式

// index.html
<html>

<head>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>

<body>
<div id="app">
<div>
<input v-model="username">
<input v-model="password">
</div>
<div>
<button v-on:click="login">Login</button>
<button v-on:click="logout">Logout</button>
<button v-on:click="getUser">GetUser</button>
</div>
<div>
<button onclick="document.getElementById('log').innerHTML = ''">Clear 
Log</button>
</div>
</div>
<h6 id="log"></h6>
</div>
<script>
// axios.defaults.baseURL = 'http://localhost:3000'
axios.defaults.withCredentials = true
axios.interceptors.response.use(
response => {
document.getElementById('log').append(JSON.stringify(response.data))
return response;
}
);
var app = new Vue({
el: '#app',
data: {
username: 'test',
password: 'test'
},
methods: {
async login() {
await axios.post('/users/login', {
username: this.username,
password: this.password
})
},
async logout() {
await axios.post('/users/logout')
},
async getUser() {
await axios.get('/users/getUser')

                web全栈架构师
}
}
});
</script>
</body>
</html>



const Koa = require('koa')
const router = require('koa-router')()
const session = require('koa-session')
const cors = require('koa2-cors')
const bodyParser = require('koa-bodyparser')
const static = require('koa-static')
const app = new Koa();

//配置session的中间件
app.use(cors({
credentials: true
}))
app.keys = ['some secret'];

app.use(static(__dirname + '/'));
app.use(bodyParser())
app.use(session(app));

app.use((ctx, next) => {
if (ctx.url.indexOf('login') > -1) {
next()
} else {
console.log('session', ctx.session.userinfo)
if (!ctx.session.userinfo) {
ctx.body = {
message: "登录失败"
}
} else {
next()
}
}
})

router.post('/users/login', async (ctx) => {
const {
body
} = ctx.request
console.log('body',body)
//设置session
ctx.session.userinfo = body.username;
ctx.body = {
message: "登录成功"
}
})
router.post('/users/logout', async (ctx) => {
//设置session
delete ctx.session.userinfo
ctx.body = {
                web全栈架构师
message: "登出系统"
}
})
router.get('/users/getUser', async (ctx) => {
ctx.body = {
message: "获取数据成功",
userinfo: ctx.session.userinfo
}
})

app.use(router.routes());
app.use(router.allowedMethods());
app.listen(3000);





过程回顾：



用户登录的时候，服务端生成一个唯一的会话标识，并以它为key存储数据
会话标识在客户端和服务端之间通过cookie进行传输
服务端通过会话标识可以获取到会话相关的信息，然后对客户端的请求进行响应；如果找不
到有效的会话，那么认为用户是未登陆状态
会话会有过期时间，也可以通过一些操作（比如登出）来主动删除






Token 验证                                                                                                  

session不足

服务器有状态
不灵活如果APP该怎么办 跨域怎么办



原理


                web全栈架构师
1. 客户端使用用户名跟密码请求登录 
2. 服务端收到请求，去验证用户名与密码 
3. 验证成功后，服务端会签发一个令牌(Token)，再把这个 Token 发送给客户端 
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 
6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请
求的数据

案例：令牌认证

登录页，index.html

<html>
<head>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">
</script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>

<body>
<div id="app">
<div>
<input v-model="username" />
<input v-model="password" />
</div>
<div>
<button v-on:click="login">Login</button>
<button v-on:click="logout">Logout</button>
<button v-on:click="getUser">GetUser</button>
</div>
<div>
<button @click="logs=[]">Clear Log</button>
</div>
<!-- 日志 -->
<ul>
<li v-for="(log,idx) in logs" :key="idx">
{{ log }}
</li>
</ul>
</div>
            web全栈架构师
<script>
axios.interceptors.request.use(
config => {
const token = window.localStorage.getItem("token");
if (token) {
// 判断是否存在token，如果存在的话，则每个http header都加上token
// Bearer是JWT的认证头部信息
config.headers.common["Authorization"] = "Bearer " + token;
}
return config;
},
err => {
return Promise.reject(err);
}
);

axios.interceptors.response.use(
response => {
app.logs.push(JSON.stringify(response.data));
return response;
},
err => {
app.logs.push(JSON.stringify(response.data));
return Promise.reject(err);
}
);
var app = new Vue({
el: "#app",
data: {
username: "test",
password: "test",
logs: []
},
methods: {
login: async function() {
const res = await axios.post("/users/login-token", {
username: this.username,
password: this.password
});
localStorage.setItem("token", res.data.token);
},
logout: async function() {
localStorage.removeItem("token");
},
getUser: async function() {
await axios.get("/users/getUser-token");
}
}
});
</script>
</body>
</html>




登录接口

        web全栈架构师
安装依赖：       npm i jsonwebtoken koa-jwt -S
接口编写，index.js

const Koa = require('koa')
const router = require('koa-router')()

const jwt = require("jsonwebtoken")
const jwtAuth = require("koa-jwt")
const secret = "it's a secret"
const cors = require('koa2-cors')
const bodyParser = require('koa-bodyparser')
const static = require('koa-static')
const app = new Koa();
app.keys = ['some secret'];

app.use(static(__dirname + '/'));
app.use(bodyParser())

router.post("/users/login-token", async ctx => {
const { body } = ctx.request;
//登录逻辑，略
//设置session
const userinfo = body.username;
ctx.body = {
message: "登录成功",
user: userinfo,
// 生成 token 返回给客户端
token: jwt.sign(
{
data: userinfo,
// 设置 token 过期时间，一小时后，秒为单位
exp: Math.floor(Date.now() / 1000) + 60 * 60
},
secret
)
};
});

router.get(
"/users/getUser-token",
jwtAuth({
secret
}),
async ctx => {
// 验证通过，state.user
console.log(ctx.state.user);

//获取session
ctx.body = {
message: "获取数据成功",
userinfo: ctx.state.user.data 
};
}
);


app.use(router.routes());
    web全栈架构师
app.use(router.allowedMethods());
app.listen(3000);


eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoidGVzdCIsImV4cCI6MTU4NT
QwNzgxMSwiaWF0IjoxNTg1NDA0MjExfQ.6fTqLuj13_MmqjdOOAzM3tn8O7nW7HZ-
MmJKat4eTg4


过程回顾                                                                                   

用户登录的时候，服务端生成一个token返回给客户端
客户端后续的请求都带上这个token
服务端解析token获取用户信息，并响应用户的请求
token会有过期时间，客户端登出的时候也会废弃token，但是服务端不需要任何操作

与Token简单对比                                                                             

session要求服务端存储信息，并且根据id能够检索，而token不需要（因为信息就在token
中，这样实现了服务端无状态化）。在大规模系统中，对每个请求都检索会话信息可能是一
个复杂和耗时的过程。但另外一方面服务端要通过token来解析用户身份也需要定义好相应
的协议（比如JWT）。
session一般通过cookie来交互，而token方式更加灵活，可以是cookie，也可以是
header，也可以放在请求的内容中。不使用cookie可以带来跨域上的便利性。
token的生成方式更加多样化，可以由第三方模块来提供。
token若被盗用，服务端无法感知，cookie信息存储在用户自己电脑中，被盗用风险略小。




JWT(JSON WEB TOKEN)原理解析                                                                     

1. Bearer Token包含三个组成部分：令牌头、payload、哈希

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoidGVzdCIsImV4cCI6MTU2NzY5NjEzNCwiaWF0Ij
oxNTY3NjkyNTM0fQ.OzDruSCbXFokv1zFpkv22Z_9AJGCHG5fT_WnEaf72EA

第三个参数 ？？？

base64 可逆 

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoidGVzdCIsImV4cCI6MTU2NjM5OTc3MSwiaWF0Ij
oxNTY2Mzk2MTcxfQ.nV6sErzfZSfWtLSgebAL9nx2wg-LwyGLDRvfjQeF04U



1. 签名：默认使用base64对payload编码，使用hs256算法对令牌头、payload和密钥进行签名生成
哈希
2. 验证：默认使用hs256算法对hs256算法对令牌中数据签名并将结果和令牌中哈希比对





// jsonwebtoken.js
const jsonwebtoken = require('jsonwebtoken')
            web全栈架构师
const secret = '12345678'
const opt = {
secret: 'jwt_secret',
key: 'user'
}
const user = {
username: 'abc',
password: '111111'
}

const token = jsonwebtoken.sign({
data: user,
// 设置 token 过期时间
exp: Math.floor(Date.now() / 1000) + (60 * 60), 
}, secret)

console.log('生成token:' + token)
// 生成
token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7InVzZXJuYW1lIjoiYWJjIiwic
GFzc3dvcmQiOiIxMTExMTEifSwiZXhwIjoxNTQ2OTQyMzk1LCJpYXQiOjE1NDY5Mzg3OTV9.VPBCQgLB
7XPBq3RdHK9WQMkPp3dw65JzEKm_LZZjP9Y
console.log('解码:', jsonwebtoken.verify(token, secret, opt))
// 解码: { data: { username: 'abc', password: '111111' },
//  exp: 1546942395,
//  iat: 1546938795 }



HMAC SHA256
HMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协
议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用
这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入
到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。

BASE64 
按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节
描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed 
to represent arbitrary sequences of octets in a form that need not be humanly readable.） 
常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64编
码的

Beare 

Beare作为一种认证类型(基于OAuth 2.0)，使用"Bearer"关键词进行定义

参考文档：

jsonwebtoken、koa-jwt

阮一峰  JWT解释

http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html




OAuth(开放授权)                                                                                               

                web全栈架构师
概述：三方登入主要基于OAuth 2.0。OAuth协议为用户资源的授权提供了一个安全的、开放而又
简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息
（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，
因此OAUTH是安全的。

案例：OAuth登录

登录页面 index.html

<html>
<head>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
<div id="app">
<a href='/github/login'>login with github</a>
</div>
</body>
</html>



登录接口 index.js

const Koa = require('koa')
const router = require('koa-router')()
const static = require('koa-static')
const app = new Koa();
const axios = require('axios')
const querystring = require('querystring')

app.use(static(__dirname + '/'));
const config = {
client_id: '73a4f730f2e8cf7d5fcf',
client_secret: '74bde1aec977bd93ac4eb8f7ab63352dbe03ce48'
}

router.get('/github/login', async (ctx) => {
var dataStr = (new Date()).valueOf();
//重定向到认证接口,并配置参数
var path = "https://github.com/login/oauth/authorize";
path += '?client_id=' + config.client_id;

//转发到授权服务器
ctx.redirect(path);
})
router.get('/auth/github/callback', async (ctx) => {
console.log('callback..')
const code = ctx.query.code;
const params = {
client_id: config.client_id,
client_secret: config.client_secret,
code: code
}
let res = await 
axios.post('https://github.com/login/oauth/access_token', params)
const access_token = querystring.parse(res.data).access_token
            web全栈架构师
res = await axios.get('https://api.github.com/user?access_token=' + 
access_token)
console.log('userAccess:', res.data)
ctx.body = `
<h1>Hello ${res.data.login}</h1>
<img src="${res.data.avatar_url}" alt=""/>
`

})

app.use(router.routes()); /*启动路由*/
app.use(router.allowedMethods());
app.listen(7001);

单点登录

cd passport
node app.js
cd ../system
PORT=8081 SERVER_NAME=a node app.js
PORT=8082 SERVER_NAME=b node app.js


#user test
#password 123456


作业                                                                                                        

jwt原理解析 反篡改 过期检测 

要求:提交代码截图 - 提取JWT Token中的有效期  - 参考阮一峰jwt原理解析 - 利用Buﬀer进行Base64解
码 - 验证JWT 中的Hash值(选做)




                web全栈架构师
windows Redis安装文档                                                                           

Windows 安装 Redis(.msi)

下载地址

下载的时候下载 msi 安装文件：




1.首先双击现在完的安装程序 


2.点击 next 


        开课吧web全栈架构师
3. 选择安装的路径，并且打上勾（这个非常重要），添加到 path 是把 Redis 设置成 windows 下的
服务，不然你每次都要在该目录下启动命令 redis-server redis.windows.conf，但是只要一关闭 
cmd 窗口，redis 就会消失，这样就比较麻烦。 


4.设置 Redis 的服务端口，默认为 6379，默认就好，单击 next 
        开课吧web全栈架构师
5.设置 Max Memory，然后 next 进入安装 


如果 redis 的应用场景是作为数据库使用，那不要设置这个选项，因为数据库是不能容忍丢失数据的。

如果作为临时缓存那就得看自己的需要（我这里设置了 1024M 的最大内存限制）

        开课吧web全栈架构师
指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试
清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但
仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap区。


6.安装完成 


        开课吧web全栈架构师
7.测试所安装的Redis

如果你是和我一样通过msi文件的安装，你可以在 “计算机管理→服务与应用程序→服务” 看到Redis正
在运行


你也可以将它停止(不停止会出现错误代码为 18012 的错误，表示本机端口 6379 被占用)，然后在 cmd 
窗口进入Redis的安装路径的根目录

输入命令 redis-server.exe redis.windows.conf，出现下图证明 Redis 服务启动成功：


下面进行测试：

你可以在 Redis 的安装根目录下找到 redis-cli.exe 文件启动(我用的是这种方法)，或在 cmd 中先进入 
Redis 的安装根目录用命令 redis-cli.exe -h 192.168.10.61 -p 6379（注意换成自己的 IP，本地可以是 
127.0.0.1）的方式打开

测试方法：设置键值对，取出键值对（我这里键值对是 peng）


        开课吧web全栈架构师



        开课吧web全栈架构师
基于Koa定制⾃⼰的企业级三层框架                                                                       



基于Koa定制⾃⼰的企业级三层框架
回顾
课堂主题
课堂⽬标
知识点
Egg.js体验
实现分层架构
扩展点
总结
下节课预告

回顾                                                                                      

koa开发中常⻅任务


课堂主题                                                                                    

1. koa不⾜的地⽅

2. 封装路由
3. 实现控制器层

4. 实现服务层
5. 实现模型层

6. 加载中间件

课堂⽬标                                                                                    

1. 理解三层结构
2. 熟悉企业级web开发框架egg.js使⽤
3. 基于Koa定制⾃⼰的企业级三层结构框架


知识点                                                                                     

    开课吧web全栈架构师
Egg.js体验                                                                                            

三层结构

信息资源层 就是 action，或者 servlet，⽤来处理上下游数据结构。
业务逻辑层⼀般应⽤中会有⼀层service抽象，实现核⼼业务逻辑，事务控制也在这⼀层实
现。
数据访问层也即dao层，重点负责数据库访问，完成持久化功能。

创建项⽬

// 创建项⽬
$ npm i egg-init -g
$ egg-init egg --type=simple
$ cd egg-example
$ npm i

// 启动项⽬
$ npm run dev
$ open localhost:7001

浏览项⽬结构：

Public
Router -> Controller -> Service -> Model
Schedule
创建⼀个路由，router.js

router.get('/user', controller.user.index);



创建⼀个控制器，user.js

'use strict';

const Controller = require('egg').Controller;

class UserController extends Controller {
async index() {
this.ctx.body = [
{name:'tom'},
{name:'jerry'}
]
}
}

module.exports = UserController;


        开课吧web全栈架构师
约定优于配置（convention over configuration），也称作按约定编程，是⼀种软件设计范式，
旨在减少软件开发⼈员需做决定的数量，获得简单的好处，⽽⼜不失灵活性。

创建⼀个服务，./app/service/user.js

'use strict';

const Service = require('egg').Service;

class UserService extends Service {
async getAll() {
return [
{name:'tom'},
{name:'jerry'}
]
}
}

module.exports = UserService;


使⽤服务，./app/controller/user.js

async index() {
const { ctx } = this;
ctx.body = await ctx.service.user.getAll();
}

创建模型层：以mysql + sequelize为例演示数据持久化

安装：    npm install --save egg-sequelize mysql2

在   config/plugin.js    中引⼊ egg-sequelize 插件

sequelize: {
enable: true,
package: 'egg-sequelize',
}

在   config/config.default.js      中编写 sequelize 配置


        开课吧web全栈架构师
// const userConfig 中 
sequelize: {
dialect: "mysql",
host: "127.0.0.1",
port: 3306,
username: "root",
password: "example",
database: "kaikeba"
}





编写User模型，./app/model/user.js

module.exports = app => {
const { STRING } = app.Sequelize;

const User = app.model.define(
"user",
{ name: STRING(30) },
{ timestamps: false }
);

// 数据库同步
User.sync({force: true})

return User;
};



服务中或者控制器中调⽤：ctx.model.User或app.model.User

class UserService extends Service {
async getAll() {
return await this.ctx.model.User.findAll()
}
}

// 或者控制器
ctx.body = await this.ctx.model.User.findAll()





// 需要同步数据库

        开课吧web全栈架构师
https://eggjs.org/zh-cn/tutorials/sequelize.html


// 添加测试数据
const User = this.ctx.model.User
await User.sync({ force: true })
await User.create({
name: "laowang"
}
)












实现分层架构                                                                                              

⽬标是创建约定⼤于配置、开发效率⾼、可维护性强的项⽬架构

路由处理
规范

所有路由，都要放在routes⽂件夹中
若导出路由对象，使⽤            动词+空格+路径       作为key，值是操作⽅法
若导出函数，则函数返回第⼆条约定格式的对象
路由定义：

新建routes/index.js，默认Index.js没有前缀

module.exports = {
'get /':async ctx=>{
ctx.body = '⾸⻚'
},
'get /detail' : ctx=>{
ctx.body = '详情⻚⾯'
}
}



新建routes/user.js 路由前缀是/user


        开课吧web全栈架构师
module.exports = {
"get /": async ctx => {
ctx.body = "⽤户⾸⻚";
},
"get /info": ctx => {
ctx.body = "⽤户详情⻚⾯";
}
};



路由加载器，新建kkb-loader.js

const fs = require("fs");
const path = require("path");
const Router = require("koa-router");

// 读取指定⽬录下⽂件
function load(dir, cb) {
// 获取绝对路径
const url = path.resolve(__dirname, dir);
// 读取路径下的⽂件
const files = fs.readdirSync(url);
// 遍历路由⽂件，将路由配置解析到路由器中
files.forEach(filename => {
// 去掉后缀名
filename = filename.replace(".js", "");
// 导⼊⽂件
const file = require(url + "/" + filename);
// 处理逻辑
cb(filename, file);
});
}

function initRouter() {
const router = new Router();
load("routes", (filename, routes) => {
// 若是index⽆前缀，别的⽂件前缀就是⽂件名
const prefix = filename === "index" ? "" : `/${filename}`;

// 遍历路由并添加到路由器
Object.keys(routes).forEach(key => {
const [method, path] = key.split(" ");
console.log(
`正在映射地址：${method.toLocaleUpperCase()} 
${prefix}${path}`
);
// 执⾏router.method(path, handler)注册路由
router[method](prefix + path, routes[key]);
开课吧web全栈架构师
});
});
return router;
}

module.exports = { initRouter };

测试，引⼊kkb-loader.js

// index.js
const app = new (require('koa'))()
const {initRouter} = require('./kkb-loader')
app.use(initRouter().routes())
app.listen(3000)

封装，创建kkb.js

// kkb.js
const koa = require("koa");
const {initRouter} = require("./kkb-loader");

class kkb {
constructor(conf) {
this.$app = new koa(conf);
this.$router = initRouter();
this.$app.use(this.$router.routes());
}

start(port) {    
this.$app.listen(port, () => {
console.log("服务器启动成功，端⼝" + port);
});
}
}

module.exports = kkb;

修改app.js

const kkb = require("./kkb");
const app = new kkb();
app.start(3000);






控制器：抽取route中业务逻辑⾄controller
    开课吧web全栈架构师
约定： controller⽂件夹下⾯存放业务逻辑代码，框架⾃动加载并集中暴露
新建controller/home.js

module.exports = {
index: async ctx => {
ctx.body = "⾸⻚";
},
detail: ctx => {
ctx.body = "详情⻚⾯";
}
}

修改路由声明，routes/index.js

// 需要传递kkb实例并访问其$ctrl中暴露的控制器
module.exports = app => ({ 
"get /": app.$ctrl.home.index,
"get /detail": app.$ctrl.home.detail
});



加载控制器，更新kkb-loader.js

function initController() {
const controllers = {};
// 读取控制器⽬录
load("controller", (filename, controller) => {
// 添加路由
controllers[filename] = controller;
});

return controllers;
}

module.exports = { initController };


初始化控制器，kkb.js


    开课吧web全栈架构师
const {initController} = require("./kkb-loader");

class kkb {
constructor(conf) {
//...
this.$ctrl = initController(); // 先初始化控制器，路由对它有依赖
this.$router = initRouter(this); // 将kkb实例传进去
//...
}
}



修改路由初始化逻辑，能够处理函数形式的声明, kkb-loader.js

function initRouter(app) { // 添加⼀个参数
load("routes", (filename, routes) => {
// ...

// 判断路由类型，若为函数需传递app进去
routes = typeof routes == "function" ? routes(app) : routes;

// ...
});
}



服务：抽离通⽤逻辑⾄service⽂件夹，利于复⽤
新建service/user.js

const delay = (data, tick)=> new Promise(resolve=>{
setTimeout(()=>{
resolve(data)
},tick)
})

// 可复⽤的服务 ⼀个同步，⼀个异步
module.exports = {
getName() {
return delay('jerry', 1000)
},
getAge(){
return 20
}
};

加载service
    开课吧web全栈架构师
//kkb-loader.js
function initService() {
const services = {};
// 读取控制器⽬录
load("service", (filename, service) => {
// 添加路由
services[filename] = service;
});

return services;
}
module.exports = { initService };

// kkb.js
this.$service = initService();

挂载和使⽤service

// kkb-loader.js
function initRouter(app) {
// ...
// router[method](prefix + path, routes[key])
router[method](prefix + path, async ctx => { // 传⼊ctx
app.ctx = ctx; // 挂载⾄app
await routes[key](app); // 路由处理器现在接收到的是app
});
//...
}




更新路由

// routes/user.js
module.exports = {
"get /":  async (app) => {
const name = await app.$service.user.getName();
app.ctx.body = "⽤户:" +name;
},
"get /info": app => {
app.ctx.body = "⽤户年龄：" + app.$service.user.getAge();
}
};

// routes/index.js
module.exports = app => ({
"get /": app.$ctrl.home.index,
    开课吧web全栈架构师
"get /detail": app.$ctrl.home.detail
});


// controller/home.js
module.exports = (app) => ({
index: async ctx => {
// ctx.body = 'Ctrl Index'
console.log('index ctrl')
const name = await app.$service.user.getName()
app.ctx.body = 'ctrl user' + name

},
detail: async ctx => {
ctx.body = 'Ctrl Detal'
}
})

// controller科⾥化
// initController
controllers[filename] = controller(app)
this.$ctrl = initController(this)




数据库集成

集成sequelize：     npm install  sequelize mysql2 --save

约定：

config/config.js中存放项⽬配置项
key表示对应配置⽬标
model中存放数据模型
配置sequelize连接配置项，index.js

// config/index.js
module.exports = {
db:{
dialect:'mysql',
host:'localhost',
database:'kaikeba',
username:'root',
password:'example'
}
}

新增loadConfig，kkb-loader.js

    开课吧web全栈架构师
const Sequelize = require("sequelize");
function loadConfig(app) {
load("config", (filename, conf) => {
if (conf.db) {
app.$db = new Sequelize(conf.db);
}
});
}
module.exports = { loadConfig };

// kkb.js
//先加载配置项
loadConfig(this);



新建数据库模型, model/user.js

const { STRING } = require("sequelize");
module.exports = {
schema: {
name: STRING(30)
},
options: {
timestamps: false
}
};

loadModel和loadConfig初始化，kkb-loader.js

function loadConfig(app) {
load("config", (filename, conf) => {
if (conf.db) {
app.$db = new Sequelize(conf.db);

// 加载模型
app.$model = {};
load("model", (filename, { schema, options }) => {
app.$model[filename] = app.$db.define(filename, schema, 
options);
});
app.$db.sync();
}
});
}


在controller中使⽤$db
开课吧web全栈架构师
module.exports = {
// index: async ctx => {
//     ctx.body = '⾸⻚'
// },
index: async app => { // app已传递
app.ctx.body = await app.$model.user.findAll()
},
detail: app => {
app.ctx.body = '详细⻚⾯'
}
}



在service中使⽤$db

// 修改service结构，service/user.js
module.exports = app => ({
getName() {
// return delay('jerry',1000)
return app.$model.user.findAll() // 添加
},
getAge(){
return 20
}
})

// 修改kkb-loader.js
function initService(app) { // 增加参数
const services = {}
load('service', (filename, service) => {
services[filename] = service(app)// 服务变参数
})
console.log('service',services)
return services
}

// 修改kkb.js
this.$service = initService(this)



中间件

规定koa中间件放⼊middleware⽂件夹 

编写⼀个请求记录中间件，./middleware/logger.js


    开课吧web全栈架构师
module.exports = async (ctx, next) => {
console.log(ctx.method + " " + ctx.path);
const start = new Date();
await next();
const duration = new Date() - start;
console.log(
ctx.method + " " + ctx.path + " " + ctx.status + " " + duration + 
"ms"
);
};

配置中间件，./config/config.js

module.exports = {
db:{...},
middleware: ['logger'] // 以数组形式，保证执⾏顺序
}



加载中间件，kkb-loader.js

function loadConfig(app) {
load("config", (filename, conf) => {
// 如果有middleware选项，则按其规定循序应⽤中间件
if (conf.middleware) {
conf.middleware.forEach(mid => {
const midPath = path.resolve(__dirname, "middleware", mid);
app.$app.use(require(midPath));
});
}
});
}



调⽤，kkb.js

class kkb {
constructor(conf) {
this.$app = new koa(conf);
//先加载配置项
loadConfig(this);
//...
}

定时任务

使⽤Node-schedule来管理定时任务
    开课吧web全栈架构师
npm install node-schedule --save

约定：schedule⽬录，存放定时任务，使⽤crontab格式来启动定时

//log.js
module.exports = {
interval:'*/3 * * * * *',
handler(){
console.log('定时任务 嘿嘿 三秒执⾏⼀次'+ new Date())
}
}

// user.js
module.exports = {
interval:'30 * * * * *',
handler(){
console.log('定时任务 嘿嘿 每分钟第30秒执⾏⼀次'+ new Date())
}
}

定时格式是符合linux的crobtab

*    *    *    *    *    *
!    !    !    !    !    !
"    "    "    "    "    |
"    "    "    "    "    # day of week (0 - 7) (0 or 7 is Sun)
"    "    "    "    #$$$$$ month (1 - 12)
"    "    "    #$$$$$$$$$$ day of month (1 - 31)
"    "    #$$$$$$$$$$$$$$$ hour (0 - 23)
"    #$$$$$$$$$$$$$$$$$$$$ minute (0 - 59)
#$$$$$$$$$$$$$$$$$$$$$$$$$ second (0 - 59, optional)

6个占位符从左到右分别代表：秒、分、时、⽇、⽉、周⼏,　''表示通配符，匹配任
意，当秒是''时，表示任意秒数都触发，其它类推

每分钟的第30秒触发： '30 * * * * *'
每⼩时的1分30秒触发 ：'30 1 * * * *'
每天的凌晨1点1分30秒触发 ：'30 1 1 * * *'
每⽉的1⽇1点1分30秒触发 ：'30 1 1 1 * *'
2020年的1⽉1⽇1点1分30秒触发 ：'30 1 1 1 2020 *'
每周1的1点1分30秒触发 ：'30 1 1 * * 1'
每三秒 ：'*/3 * * * * *'

新增loadSchedule函数，kkb-loader.js

const schedule = require("node-schedule");
function initSchedule() {
开课吧web全栈架构师
// 读取控制器⽬录
load("schedule", (filename, scheduleConfig) => {
schedule.scheduleJob(scheduleConfig.interval, 
scheduleConfig.handler);
});
}
module.exports = { initRouter, initController, 
initService,initSchedule };

// kkb.js
const {initSchedule} = require("./kkb-loader");
class kkb {
constructor(conf) {
initSchedule();
}
}




通过约定⽂件夹的形式，开始MVC开发之旅，这个框架学习了eggjs的核⼼架构思想，到现在你已
经构建了⾃⼰的MVC框架了，刷个⽕箭吧！




扩展点                                                                                                 

1. 扩展

1. 安全
2. ⽇志
3. 线上部署
4. 单元测试等等


总结                                                                                                  
        开课吧web全栈架构师
1. 知识点
2. 学习⽅法
3. 收获


下节课预告                                                                                   

1. Koa实现原理
2. 常⻅Koa中间件实现

作业：自动加载模块           作业截图


    开课吧web全栈架构师
ts项⽬架构                                                                                              



课程⽬标                                                                                                

TypeScript实现类装饰器和⽅法装饰
搭建Node TS开发环境
基于装饰器的Router Validation Models



项⽬结构                                                                                                

1. package.json创建：     npm init -y

2. 开发依赖安装：         npm i typescript ts-node-dev tslint @types/node -D

3. 启动脚本

"scripts": {
"start": "ts-node-dev ./src/index.ts -P tsconfig.json --no-cache",
"build": "tsc -P tsconfig.json && node ./dist/index.js",
"tslint": "tslint --fix -p tsconfig.json"
}

4. 加⼊tsconfig.json

{
"compilerOptions": {
"outDir": "./dist",
"target": "es2017",
"module": "commonjs",//组织代码⽅式
"sourceMap": true,
"moduleResolution": "node", // 模块解决策略
"experimentalDecorators": true, // 开启装饰器定义
"allowSyntheticDefaultImports": true, // 允许es6⽅式import
"lib": ["es2015"],
"typeRoots": ["./node_modules/@types"],
},
"include": ["src/**/*"]
}



5. 创建⼊⼝⽂件./src/index.ts


            开课吧web全栈架构师
console.log('hello');

6. 运⾏测试：      npm start



项⽬基础代码                                                                                              

1. 安装依赖：      npm i koa koa-static koa-body koa-xtime -S

2. 编写基础代码，index.ts

import * as Koa from 'koa'
import * as bodify from 'koa-body';
import * as serve from 'koa-static';
import * as timing from 'koa-xtime';

const app = new Koa();

app.use(timing());
app.use(serve(`${__dirname}/public`));

app.use(
bodify({
multipart: true,
// 使⽤⾮严格模式，解析 delete 请求的请求体
strict: false,
}),
);

app.use((ctx: Koa.Context) => {
ctx.body = 'hello'
})

app.listen(3000, () => {
console.log('服务器启动成功');
});

3. 测试：    npm start



实现⼀个装饰器
调⽤loader




            开课吧web全栈架构师
路由定义及发现                                                                                             

1. 创建路由./src/routes/user.ts

import * as Koa from 'koa';

const users = [{ name: 'tom', age: 20 }, { name: 'tom', age: 20 }];
export default class User {
@get('/users')
public list(ctx: Koa.Context) {
ctx.body = { ok: 1, data: users };
}

@post('/users')
public add(ctx: Koa.Context) {
users.push(ctx.request.body);
ctx.body = { ok: 1 }
}

}

知识点补充：装饰器的编写，以@get('/users')为例，它是函数装饰器且有配置项，其函数签
名为：

function get(path) {
return function(target, property, descriptor) {}
}


另外需解决两个问题：

1. 路由发现
2. 路由注册

2. 路由发现及注册，创建./utils/route-decors.ts



import * as glob from 'glob';
import * as Koa from 'koa';
import * as KoaRouter from 'koa-router';

type HTTPMethod = 'get' | 'put' | 'del' | 'post' | 'patch';
type LoadOptions = {
/**
* 路由⽂件扩展名，默认值是`.{js,ts}`
*/
extname?: string;

            开课吧web全栈架构师
};
type RouteOptions = {
/**
* 适⽤于某个请求⽐较特殊，需要单独制定前缀的情形
*/
prefix?: string;
/**
* 给当前路由添加⼀个或多个中间件
*/
middlewares?: Array<Koa.Middleware>;
};
const router = new KoaRouter()
export const get = (path: string, options?: RouteOptions) => {
return (target, property, descriptor) => {
const url = options && options.prefix ? options.prefix + path : 
path
router['get'](url, target[property])
}
}
export const post = (path: string, options?: RouteOptions) => {
return (target, property, descriptor) => {
const url = options && options.prefix ? options.prefix + path : 
path
router['post'](url, target[property])
}
}

解决get post put delete⽅法公⽤逻辑
需要进⼀步对原有函数进⾏柯⾥化

const router = new KoaRouter()
const method = method => (path: string, options?: RouteOptions) => {
return (target, property, descriptor) => {
const url = options && options.prefix ? options.prefix + path : 
path
router[method](url, target[property])
}
}
export const get = method('get')
export const post = method('post')

router变量 不符合函数式编程引⽤透明的特点 对后⾯移植不利
所以要再次进⾏柯⾥化


        开课吧web全栈架构师
const router = new KoaRouter()
const decorate = (method: HTTPMethod, path: string, options: RouteOptions = 
{}, router: KoaRouter) => {
return (target, property: string) => {
const url = options.prefix ? options.prefix + path : path
router[method](url, target[property])
}
}
const method = method => (path: string, options?: RouteOptions) => 
decorate(method, path, options, router)

export const get = method('get')
export const post = method('post')



import * as glob from 'glob';
import * as Koa from 'koa';
import * as KoaRouter from 'koa-router';

type HTTPMethod = 'get' | 'put' | 'del' | 'post' | 'patch';
type LoadOptions = {
/**
* 路由⽂件扩展名，默认值是`.{js,ts}`
*/
extname?: string;
};
type RouteOptions = {
/**
* 适⽤于某个请求⽐较特殊，需要单独制定前缀的情形
*/
prefix?: string;
/**
* 给当前路由添加⼀个或多个中间件
*/
middlewares?: Array<Koa.Middleware>;
};
const router = new KoaRouter()
const decorate = (method: HTTPMethod, path: string, options: RouteOptions = 
{}, router: KoaRouter) => {
return (target, property: string) => {
const url = options.prefix ? options.prefix + path : path
router[method](url, target[property])
}
}
const method = method => (path: string, options?: RouteOptions) => 
decorate(method, path, options, router)
export const get = method('get')

    开课吧web全栈架构师
export const post = method('post')
export const put = method('put')
export const del = method('del')
export const patch = method('patch')

export const load = (folder: string, options: LoadOptions = {}): KoaRouter 
=> {
const extname = options.extname || '.{js,ts}'
glob.sync(require('path').join(folder, 
`./**/*${extname}`)).forEach((item) => require(item))
return router
}



3. 使⽤

routes/user.ts

import { get, post } from '../utils/decors'

index.ts

import { load } from './utils/decors';
import {resolve} from 'path'
const router = load(resolve(__dirname, './routes'));
app.use(router.routes())

4. 数据校验：可以利⽤中间件机制实现

添加校验函数，./routes/user.ts

//异步校验接⼝
const api = {
findByName(name) {
return new Promise((resolve, reject) => {
setTimeout(() => {
if (name === 'xia') {
reject('⽤户名已存在')
} else {
resolve()
}
}, 500);
})
}
}

export default class User {
// 添加中间件选项

            开课吧web全栈架构师
@post('/users', {
middlewares: [
async function validation(ctx: Koa.Context, next: () => 
Promise<any>) {
// ⽤户名必填
const name = ctx.request.body.name
if (!name) {
throw "请输⼊⽤户名";
}
// ⽤户名不能重复
try {
await api.findByName(name);
// 校验通过
await next();
} catch (error) {
throw error;
}
}
]
})
public async add(ctx: Koa.Context) {}
}



更新decors.ts

export const load = function(prefix: string, folder: string, options: 
LoadOptions = {}): KoaRouter {
// ...
route = function(method: HTTPMethod, path: string, options: RouteOptions = 
{}) {
return function(target, property: string, descriptor) {
// 添加中间件数组
const middlewares = [];

// 若设置了中间件选项则加⼊到中间件数组
if (options.middlewares) {
middlewares.push(...options.middlewares);
}

// 添加路由处理器
middlewares.push(target[property]);
const url = (options.prefix || prefix) + path;
// router[method](url, target[property]);
router[method](url, ...middlewares);
};
};


            开课吧web全栈架构师
// ...
return router;
};



5. 类级别路由守卫

使⽤，routes/user.ts

@middlewares([
async function guard(ctx: Koa.Context, next: () => Promise<any>){
console.log('guard', ctx.header);

if(ctx.header.token) {
await next();
} else {
throw "请登录";            
}
}
])
export default class User {}



增加中间装饰器，更新route-decors.ts

//增加中间装饰器
export const middlewares = function middlewares(middlewares: 
Koa.Middleware[]) {
return function(target) {
target.prototype.middlewares = middlewares;
};
};

//修改load⽅法
export const load = function(prefix: string, folder: string, options: 
LoadOptions = {}): KoaRouter {

route = function(method: HTTPMethod, path: string, options: 
RouteOptions = {}) {
return function(target, property: string, descriptor) {
// 晚⼀拍执⾏路由注册：因为需要等类装饰器执⾏完毕
process.nextTick(() => {
let mws = [];
// 获取class上定义的中间件                
if (target.middlewares) {
middlewares.push(...target.middlewares);
}
// ...

            开课吧web全栈架构师
});
};
};

return router;
};





数据库整合                                                                                               

1. 安装依赖：      npm i -S sequelize sequelize-typescript reflect-metadata mysql2
2. 初始化，index.ts

import { Sequelize } from 'sequelize-typescript';

const database = new Sequelize({
port:3306,
database:'kaikeba',
username:'root',
password:'example',
dialect:'mysql',
modelPaths: [`${__dirname}/model`],    
});
database.sync({force: true})



3. 创建模型

// model/user.js
import { Table, Column, Model, DataType } from 'sequelize-typescript';

@Table({modelName: 'users'})
export default class User extends Model<User> {
@Column({
primaryKey: true,
autoIncrement: true,
type: DataType.INTEGER,
})
public id: number;

@Column(DataType.CHAR)
public name: string;
}



            开课吧web全栈架构师
4. 使⽤模型，routes/user.ts

import model from '../model/user';

export default class User {

@get('/users')
public async list(ctx: Koa.Context) {
const users = await model.findAll()
ctx.body = { ok: 1, data: users };
}
}





框架不⾜

Restful接⼝
model可以⾃动加载到ctx中
server层⾃动加载





作业：使⽤装饰器模式完成对⽇志⽅法输出样式的装饰 

要求：提交代码截图 










            开课吧web全栈架构师
部署_nginx_pm2_docker                                                                                       

课程目标                                                                                                      

Nginx

静态资源location
动态数据请求proxy
负载均衡
了解cluster原理

掌握pm2部署NodeJS服务


参考文档                                                                                                      

使用pm2+nginx部署koa2(https) https://www.zhaofinger.com/detail/5


课程内容                                                                                                      

如何构建一个高可用的node环境                                                                                          

主要解决问题

故障恢复
多核利用
http://www.sohu.com/a/247732550_796914
多进程共享端口

// app.js
const http = require('http')
const server = http.createServer((request, response) => {
Math.random() > 0.5 ? aa() : '2'     
response.end('Hello ')
})

if (!module.parent) {
server.listen(3000);
console.log('app started at port 3000...');
} else {
module.exports = server
}

// test.js
const request = require('request');
setInterval(() => {
request('http://localhost:3000', function (error, response, body) {
console.log('body:', body); // Print the HTML for the Google homepage.
})
}, 1000
                开课吧全栈工程师
)

// cluster.js
var cluster = require('cluster');
var os = require('os'); // 获取CPU 的数量
var numCPUs = os.cpus().length;

var process = require('process')

var workers = {};
if (cluster.isMaster) {
// 主进程分支
cluster.on('exit', (worker, code, signal) => {
console.log('工作进程 %d 关闭 (%s). 重启中...',
worker.process.pid, signal || code);
delete workers[worker.process.pid]
worker = cluster.fork()
workers[worker.process.pid] = worker
});

console.log('numCPUs:', numCPUs)
for (var i = 0; i < numCPUs; i++) {
var worker = cluster.fork();
console.log('init ... pid', worker.process.pid)
workers[worker.process.pid] = worker;
}
} else {
var app = require('./app');
app.listen(3000);
}
// 当主进程被终止时，关闭所有工作进程
process.on('SIGTERM', function () {
for (var pid in workers) {
process.kill(pid);
}
process.exit(0);
});
require('./test')       


文件上传服务器                                                                                                   

scp (最原始)

scp docker-compose.yml root@47.98.252.43:/root/source/ #文件
scp -r mini-01 root@47.98.252.43:/root/source/     #文件夹

git (实际工作中)
deploy插件 (debug)


PM2的应用                                                                                                    

内建负载均衡（使用Node cluster 集群模块、子进程，可以参考朴灵的《深入浅出node.js》一书
第九章）
                开课吧全栈工程师
线程守护，keep alive
0秒停机重载，维护升级的时候不需要停机.
现在 Linux (stable) & MacOSx (stable) & Windows (stable).多平台支持
停止不稳定的进程（避免无限循环）
控制台检测 https://id.keymetrics.io/api/oauth/login#/register
提供 HTTP API



配置

npm install -g pm2
pm2 start app.js --watch -i 2
// watch 监听文件变化
// -i 启动多少个实例

pm2 stop all
pm2 list

pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程


配置process.yml

apps:
- script : app.js
instances: 2
watch  : true
env    :
NODE_ENV: production



Keymetrics在线监控

https://id.keymetrics.io

pm2 link 8hxvp4bfrftvwxn uis7ndy58fvuf7l TARO-SAMPLE



pm2设置为开机启动

pm2 startup




Nginx 反向代理 + 前端静态服务 -》 dist                                                                               







                开课吧全栈工程师
静态服务 

反向代理 



安装                                                                                                        

yum install nginx
-----
apt update
apt install nginx

添加静态路由                                                                                                    

# /etc/nginx/sites-enable/taro

server {
listen 80;
server_name taro.josephxia.com;
location / {
root /root/source/taro-node/dist;
index index.html index.htm;
}
}


# 验证Nginx配置
nginx -t

# 重新启动Nginx
service nginx restart

nginx -s reload 


# /etc/nginx/sites-enable
# taro

server {
listen 80;
server_name taro.josephxia.com;
location / {
root /root/source/taro-node/dist;
index index.html index.htm;
}
location ~ \.(gif|jpg|png)$ {
root /root/source/taro-node/server/static;
}
location /api {
proxy_pass  http://127.0.0.1:3000;
proxy_redirect     off;
proxy_set_header   Host             $host;
proxy_set_header   X-Real-IP        $remote_addr;
proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
}
}

                开课吧全栈工程师
# X-Real-IP 用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源
IP追加


# 查看配置文件位置
nginx -t 
# nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
# nginx: configuration file /etc/nginx/nginx.conf test is successful

#重启
service nginx restart

nginx -s reload





Docker概念                                                                                                  

操作系统层面的虚拟化技术 
隔离的进程独立于宿主和其它的隔离的进程 - 容器
GO语言开发



特点                                                                                                        

高效的利用系统资源
快速的启动时间
一致的运行环境
持续交付和部署
更轻松的迁移

对比传统虚拟机总结                                                                                                 

特性                            容器                                            虚拟机

启动                            秒级                                            分钟级

硬盘使用                          一般为     MB                                    一般为     GB

性能                            接近原生                                          弱于

系统支持量                         单机支持上千个容器                                     一般几十个

三个核心概念                                                                                                    

镜像
容器
仓库


Docker基本使用                                                                                                

构建一个Nginx服务器
                开课吧全栈工程师
1. 拉取官方镜像


# 拉取官方镜像
docker pull nginx 

# 查看
docker images nginx

# 启动镜像
mkdir www
echo 'hello docker!!' >> www/index.html 

# 启动
# www目录里面放一个index.html
                                                
docker   run  -p  80:80  -v  $PWD/www:/usr/share/nginx/html         -d  nginx（Linux）
docker run -p 80:80 -v "%cd%"/www:/usr/share/nginx/html -d nginx（Windows）
# 查看进程
docker ps 
docker ps -a // 查看全部

# 伪终端 ff6容器的uuid
# -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， 
# -i 则让容器的标准输入保持打开
docker exec -it ff6 /bin/bash

# 停止
docker stop ff6

# 删除镜像
docker rm ff6

Dockerfile定制镜像                                                                                            

#Dockerfile
FROM nginx:latest
RUN echo '<h1>Hello, Kaikeba!</h1>' > /usr/share/nginx/html/index.html


# 定制镜像
docker build -t mynginx .

# 运行
# -d 守护态运行
docker run -p 80:80 -d  mynginx



定制一个程序NodeJS镜像

npm init -y
npm i koa -s


// package.json
{
"name": "myappp",

                开课吧全栈工程师
"version": "1.0.0",
"main": "app.js",
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
"keywords": [],
"author": "",
"license": "ISC",
"description": "myappp",
"dependencies": {
"koa": "^2.7.0"
}
}






// app.js
const Koa = require('koa')
const app = new Koa()
app.use(ctx => {
Math.random() > 0.8 ? abc() : ''
ctx.body = 'Hello Docker'
})
app.listen(3000, () => {
console.log('app started at http://localhost:3000/')
})



#Dockerfile
#制定node镜像的版本
FROM node:10-alpine
#移动当前目录下面的文件到app目录下
ADD . /app/
#进入到app目录下面，类似cd
WORKDIR /app
#安装依赖
RUN npm install
#对外暴露的端口
EXPOSE 3000
#程序启动脚本
CMD ["node", "app.js"]


# 定制镜像
docker build -t mynode .

# 运行
docker run -p 3000:3000  -d mynode



Pm2 - 利用多核资源

                开课吧全栈工程师
# .dockerignore
node_modules


// process.yml
apps:
- script : app.js
instances: 2
watch  : true
env    :
NODE_ENV: production



# Dockerfile
FROM keymetrics/pm2:latest-alpine
WORKDIR /usr/src/app
ADD . /usr/src/app
RUN npm config set registry https://registry.npm.taobao.org/ && \    
npm i
EXPOSE 3000
#pm2在docker中使用命令为pm2-docker
CMD ["pm2-runtime", "start", "process.yml"]


# 定制镜像
docker build -t mypm2 .

# 运行
docker run -p 3000:3000  -d mypm2


Docker-Compose                                                                                            

#docker-compose.yml
app-pm2:
container_name: app-pm2
#构建容器
build: .
# volumes:
#   - .:/usr/src/app
ports:
- "3000:3000"


// 强制重新构建并启
# --force-recreate 强制重建容器
# --build 强制编译
docker-compose up -d --force-recreate --build




                开课吧全栈工程师
#docker-compose.yml
version: '3.1'
services:
nginx:
image: nginx:kaikeba
ports:
- 80:80


# 运行
docker-compose up

# 后台运行
docker-compose up -d

部署Mongo + MongoExpress

#docker-compose.yml
version: '3.1'
services:
mongo:
image: mongo
restart: always
ports:
- 27017:27017
mongo-express:
image: mongo-express
restart: always 
ports:
- 8081:8081



代码中添加Mongoose调用

// mongoose.js
const mongoose = require("mongoose");
// 1.连接
mongoose.connect("mongodb://mongo:27017/test", { useNewUrlParser: true });
const conn = mongoose.connection;
conn.on("error", () => console.error("连接数据库失败"));


// app.js

const mongoose = require('mongoose');
mongoose.connect('mongodb://mongo:27017/test', {useNewUrlParser: true});
const Cat = mongoose.model('Cat', { name: String });
Cat.deleteMany({})
const kitty = new Cat({ name: 'Zildjian' });
kitty.save().then(() => console.log('meow'));

app.use(async ctx => {

ctx.body = await Cat.find()

                开课吧全栈工程师
})


Github WebHook实现CI持续集成                                                                                    

启动NodeJS监听

var http = require('http')
var createHandler = require('github-webhook-handler')
var handler = createHandler({ path: '/webhooks', secret: 'myHashSecret' })
// 上面的 secret 保持和 GitHub 后台设置的一致

function run_cmd(cmd, args, callback) {
var spawn = require('child_process').spawn;
var child = spawn(cmd, args);
var resp = "";

child.stdout.on('data', function (buffer) { resp += buffer.toString(); });
child.stdout.on('end', function () { callback(resp) });
}

http.createServer(function (req, res) {
handler(req, res, function (err) {
res.statusCode = 404
res.end('no such location')
})
}).listen(3000)

handler.on('error', function (err) {
console.error('Error:', err.message)
})


handler.on('*', function (event) {
console.log('Received *', event.payload.action);
//   run_cmd('sh', ['./deploy-dev.sh'], function(text){ console.log(text) 
});
})

handler.on('push', function (event) {
console.log('Received a push event for %s to %s',
event.payload.repository.name,
event.payload.ref);
// 分支判断
if(event.payload.ref === 'refs/heads/master'){
console.log('deploy master..')
}
//   run_cmd('sh', ['./deploy-dev.sh'], function(text){ console.log(text) 
});
})


handler.on('issues', function (event) {
console.log('Received an issue event for % action=%s: #%d %s',
event.payload.repository.name,
event.payload.action,
                开课吧全栈工程师
event.payload.issue.number,
event.payload.issue.title)
})



五、拓展点、未来计划、行业趋势（5min）

前端微服务化
六、总结

cluster概念
pm2基本使用
nginx静态路由、反向代理
docker部署
七、作业

维       结一         部署的解决方        要求提交
思   导图总       下全栈                案          脑图截图

八、互动问答

九、下节课的内容

微信公众号开发




            开课吧全栈工程师
负载均衡SLB                                                                                     

负载均衡（Server Load Balancer）是将访问流量根据转发策略分发到后端多台服务器的流量分发控制
服务。负载均衡扩展了应用的服务能力，增强了应用的可用性。



分类

四层(传输层)负载均衡:对客户端TCP/IP协议的包转发
七层(应用层)负载均衡:Http的应用层负载均衡,Nginx就是一个典型的7层负载均衡SLB



中小型的Web应用，比如日PV小于1000万，用Nginx
DNS轮询
大型网站或重要的服务，且服务器比较多时，可以考虑用LVS F5



Nginx的负载均衡算法

轮询 每个请求按时间顺序逐一分配到不同的后端服务器;
ip_hash 每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证
来自同一ip的请求被打到固定的机器上，可以解决session问题。
url_hash 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。后台服务器为
缓存的时候效率。
fair 这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地
进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。                                         Nginx
本身是不支持       fair 的，如果需要使用这种调度算法，必须下载Nginx的                      upstream_fair  模块。

https://www.cnblogs.com/zhaoyanjun/p/9139390.html








            开课吧全栈工程师
常见Web攻击                                                                                     

一、课前准备                                                                                      

一、课堂主题                                                                                      

二、课堂目标                                                                                      

掌握XSS (实施 + 防御)
掌握CSRF (实施 + 防御)
掌握点击劫持 (实施 + 防御)
掌握SQL注入 (实施 + 防御)
掌握OS注入 (实施 + 防御)
了解请求劫持
了解DDOS
四、知识要点                                                                                      

1、XSS                                                                                       

Cross Site Scripting

跨站脚本攻击

XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻
击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的非本站点HTML标签或
JavaScript进行的一种攻击。

跨站脚本攻击有可能造成以下影响:

利用虚假输入表单骗取用户个人信息。
利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
显示伪造的文章或图片。



XSS攻击分类

反射型 - url参数直接注入

// 普通
http://localhost:3000/?from=china

// alert尝试
http://localhost:3000/?from=<script>alert(3)</script>

// 获取Cookie
http://localhost:3000/?from=<script src="http://localhost:4000/hack.js">
</script>

// 短域名伪造 https://dwz.cn/

    开课吧web全栈架构师
// 伪造cookie入侵 chrome
document.cookie="kaikeba:sess=eyJ1c2VybmFtZSI6Imxhb3dhbmciLCJfZXhwaXJlIjoxNTUzNT
Y1MDAxODYxLCJfbWF4QWdlIjo4NjQwMDAwMH0="


存储型 - 存储到DB后读取时注入

// 评论
<script>alert(1)</script>

// 跨站脚本注入
我来了<script src="http://localhost:4000/hack.js"></script>

XSS攻击的危害 - Scripting能干啥就能干啥                                                                               

获取页面数据
获取Cookies
劫持前端逻辑
发送请求
偷取网站的任意数据
偷取用户的资料
偷取用户的秘密和登录态
欺骗用户

防范手段                                                                                                      

ejs转义小知识

<% code %>用于执行其中javascript代码； 
<%= code %>会对code进行html转义； 
<%- code %>将不会进行转义

####

HEAD

ctx.set('X-XSS-Protection', 0) // 禁止XSS过滤

// http://localhost:3000/?from=<script>alert(3)</script> 可以拦截 但伪装一下就不行了

0 禁止XSS过滤。

1 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除
不安全的部分）。

1;mode=block 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。

1; report= (Chromium only)

启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP                                        report-uri   指令的功能
发送违规报告。

CSP

内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某
些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到
网站破坏或作为恶意软件分发版本等用途。
            开课吧web全栈架构师
CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只
需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻
击。

// 只允许加载本站资源
Content-Security-Policy: default-src 'self'

// 只允许加载 HTTPS 协议图片
Content-Security-Policy: img-src https://*

// 不允许加载任何来源框架 
Content-Security-Policy: child-src 'none'


ctx.set('Content-Security-Policy', "default-src 'self'")
// 尝试一下外部资源不能加载
http://localhost:3000/?from=<script src="http://localhost:4000/hack.js">
</script>

转义字符

黑名单

用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠
进行转义

function escape(str) {
str = str.replace(/&/g, '&amp;')
str = str.replace(/</g, '&lt;')
str = str.replace(/>/g, '&gt;')
str = str.replace(/"/g, '&quto;')
str = str.replace(/'/g, '&#39;')
str = str.replace(/`/g, '&#96;')
str = str.replace(/\//g, '&#x2F;')
return str
}

富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对
于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的
标签和标签属性实在太多，更加推荐使用白名单的方式。

白名单

const xss = require('xss')
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
console.log(html)

HttpOnly Cookie

这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应 用程序在设置cookie时，将其
属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户
cookie信息。

response.addHeader("Set-Cookie", "uid=112; Path=/; HttpOnly")

        开课吧web全栈架构师
2、CSRF                                                                                      

CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登
录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。

用户已经登录了站点 A，并在本地记录了 cookie
在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱
危险站点 B (B 站点要求访问站点A)。
站点 A 没有做任何 CSRF 防御

登录  http://localhost:4000/csrf.html



CSRF攻击危害                                                                                    

利用用户登录态
用户不知情
完成业务请求
盗取用户资金（转账，消费）
冒充用户发帖背锅
损害网站声誉

防御                                                                                          

禁止第三方网站带Cookie - 有兼容性问题

Referer Check - Https不发送referer

app.use(async (ctx, next) => {
await next()
const referer = ctx.request.header.referer
console.log('Referer:', referer)
})



验证码


3、点击劫持 - clickjacking                                                                       

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己
的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

// 登录
http://localhost:4000/clickjacking.html

防御                                                                                          

X-FRAME-OPTIONS

X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就
是为了防御用 iframe 嵌套的点击劫持攻击。

    开课吧web全栈架构师
该响应头有三个值可选，分别是

DENY，表示页面不允许通过 iframe 的方式展示
SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示


ctx.set('X-FRAME-OPTIONS', 'DENY')

JS方式

<head>
<style id="click-jack">
html {
display: none !important;
}
</style>
</head>
<body>
<script>
if (self == top) {
var style = document.getElementById('click-jack')
document.body.removeChild(style)
} else {
top.location = self.location
}
</script>
</body>

以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。

SQL注入                                                                                                     

// 填入特殊密码
1'or'1'='1

// 拼接后的SQL
SELECT *
FROM test.user
WHERE username = 'laowang'
AND password = '1'or'1'='1'

防御                                                                                                        

所有的查询语句建议使用数据库提供的参数化查询接口**，参数化的语句使用参数而不是将用户
输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query
方法中的 ? 占位参数。



// 错误写法
const sql = `
SELECT *
FROM test.user
WHERE username = '${ctx.request.body.username}' 
            开课吧web全栈架构师
AND password = '${ctx.request.body.password}'
`
console.log('sql', sql)
res = await query(sql)

// 正确的写法
const sql = `
SELECT *
FROM test.user
WHERE username = ?
AND password = ?
`
console.log('sql', sql, )
res = await query(sql,[ctx.request.body.username, ctx.request.body.password])



严格限制Web应用的数据库的操作权限**，给此用户提供仅仅能够满足其工作的最低权限，从而
最大限度的减少注入攻击对数据库的危害
后端代码检查输入的数据是否符合预期**，严格限制变量的类型，例如使用正则表达式进行一些
匹配处理。
对进入数据库的特殊字符（'，"，\，<，>，&，*，; 等）进行转义处理，或编码转换**。基本上
所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar
库。



OS命令注入                                                                                                    

OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注
入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在
被攻击的风险。倘若调用Shell时存在疏漏，就可以执行插入的非法命令。


// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo
const exec = require('mz/child_process').exec;
let params = {/* 用户输入的参数 */};
exec(`git clone ${params.repo} /some/path`);


如果传入的参数是会怎样

https://github.com/xx/xx.git && rm -rf /* &&



请求劫持                                                                                                      

DNS劫持

顾名思义，DNS服务器(DNS解析各个步骤)被篡改，修改了域名解析的结果，使得访问到的不是预期的
ip

HTTP劫持 运营商劫持，此时大概只能升级HTTPS了

DDOS                                                                                                      

            开课吧web全栈架构师
http://www.ruanyifeng.com/blog/2018/06/ddos.html 阮一峰

distributed denial of service

DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。网
站运行的各个环节，都可以是攻击目标。只要把一个环节攻破，使得整个流程跑不起来，就达到了瘫痪
服务的目的。

其中，比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承
受量，导致宕机。我遭遇的就是 cc 攻击，最多的时候全世界大概20多个 IP 地址轮流发出请求，每个地
址的请求量在每秒200次~300次。我看访问日志的时候，就觉得那些请求像洪水一样涌来，一眨眼就是
一大堆，几分钟的时间，日志文件的体积就大了100MB。说实话，这只能算小攻击，但是我的个人网站
没有任何防护，服务器还是跟其他人共享的，这种流量一来立刻就下线了。

常见攻击方式                                                                                      

SYN Flood

此攻击通过向目标发送具有欺骗性源IP地址的大量TCP“初始连接请求”SYN数据包来利用TCP握
手。目标机器响应每个连接请求，然后等待握手中的最后一步，这一步从未发生过，耗尽了进程
中的目标资源。

HTTP Flood

此攻击类似于同时在多个不同计算机上反复按Web浏览器中的刷新 - 大量HTTP请求泛滥服务器，
导致拒绝服务。



防御手段                                                                                        

- 备份网站
备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉
用户，网站出了问题，正在全力抢修。
- HTTP 请求的拦截 高防IP -靠谱的运营商  多个 Docker
硬件 服务器 防火墙
-   带宽扩容 + CDN
提高犯罪成本


作业：归纳前端安全漏洞与防范思维脑图

要求：提交脑图的截图


    开课吧web全栈架构师
防御手段                                                                                          

一、课前准备                                                                                        

一、课堂主题                                                                                        

二、课堂目标                                                                                        

密码强化

人机识别
HTTPS 

浏览器安全控制 
CSP(Content-Security-Policy)

密码学

摘要 - md5 sha1 sha256 -hash
对称
非对称

## 
四、知识要点                                                                                        

1. 密码安全（30min）                                                                                

泄露渠道

数据库被偷
服务器被入侵
通讯被窃听
内部人员泄露
其他网站（撞库）
防御
严禁明文存储
单向变换
变换复杂度要求
密码复杂度要求
加盐（防拆解）
哈希算法

明文 - 密文 - 一一对应
雪崩效应 - 明文小幅变化 密文剧烈变化
密文 -明文无法反推
密文固定长度 md5 sha1 sha256
密码传输安全

https传输
频次限制
前端加密意义有限 - 传输层加密 不会泄露 但不代表不能登录
摘要加密的复杂度

md5反查
https://www.cmd5.com/

A -> B





// /app/password.js
const crypto = require('crypto')
const hash = (type, str) => crypto.createHash(type).update(str).digest('hex')
const md5 = str => hash('md5',str)
const sha1 = str => hash('sha1',str)
const encryptPassword = (salt, password) => md5(salt + 'abced@#4@%#$7' + 
password)
const psw = '123432！@#！@#@！#'
console.log('md5', md5(psw))
console.log('sha1', sha1(psw))
module.exports = encryptPassword






两种强化方式



// index.js
const encryptPassword = require('./password')
if (res.length !== 0 && res[0].salt === null) {
console.log('no salt ..')
if (password === res[0].password) {
sql = `
update test.user
set salt = ?,
password = ?
where username = ?
`
const salt = Math.random() * 99999 + new Date().getTime()
res = await query(sql, [salt, encryptPassword(salt, password), 
username])
ctx.session.username = ctx.request.body.username
ctx.redirect('/?from=china')
}
} else {
console.log('has salt')
if (encryptPassword(res[0].salt, password) === res[0].password) {
ctx.session.username = ctx.request.body.username
ctx.redirect('/?from=china')
}
}
讨论一下下列情况      

两次MD5是否可取 A OK B NO

只加盐好不好 A 好 B 不好
中间的字符串的作用
盐泄露是否会泄露密码
但密码很复杂还需要保证密码的复杂性吗 A 需要 B不需要
2. 人机验证 与 验证码                                                                                 

$('.verify-code font').text()



http://www.lisa33xiaoq.net/1232.html


前端                                                  后端                  风控服务器

    验证码请求

随机生成背景抠图 （服务端保存随机抠图位置坐标）

    滑动距离值

        风控信息(滑动行为 页面行为)

                风险处理


前端                                                  后端                  风控服务器


滑动验证码实现原理

1.服务端随机生成抠图和带有抠图阴影的背景图片，服务端保存随机抠图位置坐标；

2.前端实现滑动交互，将抠图拼在抠图阴影之上，获取到用户滑动距离值；

3.前端将用户滑动距离值传入服务端，服务端校验误差是否在容许范围内；

备注说明：单纯校验用户滑动距离是最基本的校验,处于更高安全考虑，可以考虑用户滑动整个轨迹、用
户在当前页面上的行为等,可以将其细化复杂地步,可以根据实际情况设计。亦或借助用户行为数据分析模
型,最终的目标都是增加非法的模拟和绕过的难度。


3. HTTPS 配置（30min）                                                                            

https 和密码学
https://www.cnblogs.com/hai-blog/p/8311671.html
浏览器如何验证SSL证书
http://wemedia.ifeng.com/70345206/wemedia.shtml

HTTP的弱点                                                                                       

image-20190211101756243

#查看需要经过的节点
traceroute www.baidu.com

危害                                                                                            

窃听 

密码 敏感信息
篡改 
插入广告  重定向到其他网站(JS 和 Head头)


时代趋势                                                                                          

目前全球互联网正在从HTTP向HTTPS的大迁移
Chrome和火狐浏览器将对不采用HTTPS 加密的网站提示不安全
苹果要求所有APP通信都必须采用HTTPS加密
小程序强制要求服务器端使用HTTPS请求
特点                                                                                            

保密性 (防泄密)

完整性（防篡改）
真实性（防假冒）



HTTP + SSL = HTTPS
什么是SSL证书                                                                                      

SSL证书由浏览器中“受信任的根证书颁发机构”在验证服务器身份后颁发,具有网站身份验证和加密传输双
重功能


密码学                                                                                           

对称加密

image-20190325113523030

对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的
手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是
将对称加密的密钥进行非对称加密，然后传送给需要它的人。
DES 



不对称加密

image-20190325113607388



产生一对秘钥
公钥负责加密

私钥负责解密
私钥无法解开说明公钥无效  - 抗抵赖

计算复杂对性能有影响(极端情况下 1000倍)
常见算法 RSA（大质数）、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。

RSA原理

http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html

只能被1和本身整除的数叫质数,例如13,质数是无穷多的.得到两个巨大质数的乘积是简单的事,但想
从该乘积反推出这两个巨大质数却没有任何有效的办法,这种不可逆的单向数学关系,是国际数学界
公认的质因数分解难题.
R、S、A三人巧妙利用这一假说,设计出RSA公匙加密算法的基本原理：

1、让计算机随机生成两个大质数p和q,得出乘积n；

2、利用p和q有条件的生成加密密钥e；

3、通过一系列计算,得到与n互为质数的解密密钥d,置于操作系统才知道的地方；

4、操作系统将n和e共同作为公匙对外发布,将私匙d秘密保存,把初始质数p和q秘密丢弃.
国际数学和密码学界已证明,企图利用公匙和密文推断出明文--或者企图利用公匙推断出私匙的难度
等同于分解两个巨大质数的积.这就是Eve不可能对Alice的密文解密以及公匙可以在网上公布的原
因.
至于"巨大质数"要多大才能保证安全的问题不用担心：利用当前可预测的计算能力,在十进制下,分
解两个250位质数的积要用数十万年的时间；并且质数用尽或两台计算机偶然使用相同质数的概率
小到可以被忽略.
SSH公钥登录原理                                                                                     

https://www.cnblogs.com/scofi/p/6617394.html  原理介绍

密码口令登录

通过密码进行登录，主要流程为：

1、客户端连接上服务器之后，服务器把自己的公钥传给客户端

2、客户端输入服务器密码通过公钥加密之后传给服务器

3、服务器根据自己的私钥解密登录密码，如果正确那么就让客户端登录

公钥登录

公钥登录是为了解决每次登录服务器都要输入密码的问题，流行使用RSA加密方案，主要流程包
含：

1、客户端生成RSA公钥和私钥
2、客户端将自己的公钥存放到服务器

3、客户端请求连接服务器，服务器将一个用公钥加密随机字符串发送给客户端

4、客户端根据自己的私钥加密这个随机字符串之后再发送给服务器

5、服务器接受到加密后的字符串之后用公钥解密，如果正确就让客户端登录，否则拒绝。


客户端                                         服务器

                    发出验证请求

                用公钥加密的随机数

            用私钥解密后的随机数

                正确后同意登录


客户端                                         服务器




这样就不用使用密码了。

# 生成公钥
ssh-keygen -t rsa -P ''

xubin@xubindeMBP:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/xubin/.ssh/id_rsa):
/Users/xubin/.ssh/id_rsa already exists.
Overwrite (y/n)? yes
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/xubin/.ssh/id_rsa.
Your public key has been saved in /Users/xubin/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:IeFPfrcQ3hhP64SRTAFzGIHl2ROcopl5HotRi2XNOGk xubin@xubindeMBP
The key's randomart image is:
+---[RSA 2048]----+
|      .o*@=o     |
|     ..oEB=o     |
|      o@=+O .    |
|      B=+o @ .   |
|       =So* *    |
|      . o. = .   |
|            o    |
|                 |
|                 |
+----[SHA256]-----+
# 查看公钥
cat .ssh/id_rsa.pub 

# 将公钥拷贝到服务器
scp ~/.ssh/id_rsa.pub root@47.98.252.XXX:/root

# 将公钥加入信任列表
cat id_dsa.pub >> ~/.ssh/authorized_keys



网站如何通过加密和用户安全通讯


浏览器                                  服务器                        证书信任机构

发送一个HTTPS面请求

证书 + 公钥

            询问证书有效性

                是否有效

用公钥加密的对称秘钥

通过对称秘钥通信


浏览器                                  服务器                        证书信任机构


image-20190327161829513

https的主要实现过程说明：

（1）在通信之前，服务器端通过加密算法生成一对密钥，并把其公钥发给CA申请数字证书，CA审核
后，结合服务端发来的相关信息生成数字证书，并把该数字证书发回给服务器端。

（2）客户端和服务器端经tcp三次握手，建立初步连接。

（3）客户端发送http报文请求并协商使用哪种加密算法。

（4）服务端响应报文并把自身的数字签名发给服务端。

（5）客服端下载CA的公钥，验证其数字证书的拥有者是否是服务器端（这个过程可以得到服务器端的
公钥）。（一般是客户端验证服务端的身份，服务端不用验证客户端的身份。）

（6）如果验证通过，客户端生成一个随机对称密钥，用该密钥加密要发送的URL链接申请，再用服务器
端的公钥加密该密钥，把加密的密钥和加密的URL链接一起发送到服务器。

（7）服务器端使用自身的私钥解密，获得一个对称密钥，再用该对称密钥解密经加密的URL链接，获得
URL链接申请。
（8）服务器端根据获得的URL链接取得该链接的网页，并用客户端发来的对称密钥把该网页加密后发给
客户端。

（9）客户端收到加密的网页，用自身的对称密钥解密，就能获得网页的内容了。

（10）TCP四次挥手，通信结束。



根证书在哪里

windows

在Windows下按Windows+ R, 输入certmgr.msc，在“受信任的根证书颁发机构”-“证书中”找到
“ROOTCA”，截止日期2025/08/23，单击右键，属性，可以查看其属性“禁用此证书的所有目的”
image-20190325151051619

Mac

钥匙串

image-20190325153449439





http://www.techug.com/post/https-ssl-tls.html HTTPS加密原理介绍


配置过程                                                                                          



修改开发机的host 前置 

# 开发机的hosts文件 /etc/hosts
# 添加
127.0.0.1  www.josephxia.com

阿里云取得的真实证书 （域名 www.josephxia.com）

证书的格式说明

PKCS 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促
进公钥密码的发展而制订的一系列标准，PKCS 目前共发布过 15 个标准。 常用的有：
PKCS#7 Cryptographic Message Syntax Standard
PKCS#10 Certification Request Standard
PKCS#12 Personal Information Exchange Syntax Standard
X.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T 
X509 国际标准。
PKCS#7 常用的后缀是： .P7B .P7C .SPC
PKCS#12 常用的后缀有： .P12 .PFX
X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT
X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT
.cer/.crt是用于存放证书，它是2进制形式存放的，不含私钥。
.pem跟crt/cer的区别是它以Ascii来表示。
pfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式
p10是证书请求
p7r是CA对证书请求的回复，只用于导入

参考项目目录 nginx/conf.d/cert

docker模拟nginx环境

# 安全课程根目录
version: '3.1'
services:
nginx:
restart: always
image: nginx
ports:
- 80:80
- 443:443
volumes:
- ./conf.d/:/etc/nginx/conf.d
- ./html/:/var/www/html/

原始的80端口服务

# conf.d/www.josephxia.com.conf

server {
listen       80;
server_name  www.josephxia.com;

location / {
root   /var/www/html;
index  index.html index.htm;
}

}
# 增加的部分
server {
listen 443;
server_name localhost;
ssl on;
root html;
index index.html index.htm;
# 公钥 + 证书
ssl_certificate   conf.d/cert/www.josephxia.com.pem;
# 私钥
ssl_certificate_key  conf.d/cert/www.josephxia.com.key;
ssl_session_timeout 5m;
ssl_ciphers ECDHE-RSA-AES128-GCM-
SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_prefer_server_ciphers on;
location / {
root /var/www/html;
index index.html index.htm;
}
}

增加http -> https强制跳转
# conf.d/www.josephxia.com.conf
server {
listen       80;
server_name  www.josephxia.com;
# location / {
#     root   /var/www/html;
#     index  index.html index.htm;
# }

location / {
rewrite ^(.*) https://www.josephxia.com/$1 permanent;
}
}



SSL证书分类

https://blog.csdn.net/TrustAsia/article/details/73770588

入门级 DVSSL - 域名有效 无门槛

企业型 OVSSL - 企业资质、个人认证

增强型EVSSL - 浏览器给予绿色地址栏显示公司名字
3. helmet中间件（15min）                                                                                        

英[ˈhelmɪt] 头盔

https://www.npmjs.com/package/koa-helmet

// npm i koa-helmet -s

const Koa = require("koa");
const helmet = require("koa-helmet");
const app = new Koa();

app.use(helmet());

app.use((ctx) => {
ctx.body = "Hello World"
});

app.listen(4000);

Strict-Transport-Security：强制使用安全连接（SSL/TLS之上的HTTPS）来连接到服务器。
X-Frame-Options：提供对于“点击劫持”的保护。
X-XSS-Protection：开启大多现代浏览器内建的对于跨站脚本攻击（XSS）的过滤功能。
X-Content-Type-Options： 防止浏览器使用MIME-sniffing来确定响应的类型，转而使用明确的
content-type来确定。
Content-Security-Policy：防止受到跨站脚本攻击以及其他跨站注入攻击。


4. Session管理                                                                                  

对于cookie的安全使用，其重要性是不言而喻的。特别是对于动态的web应用，在如HTTP这样的无状态
协议的之上，它们需要使用cookie来维持状态

Cookie标示

secure - 这个属性告诉浏览器，仅在请求是通过HTTPS传输时，才传递cookie。
HttpOnly - 设置这个属性将禁止         javascript 脚本获取到这个cookie，这可以用来帮助防止跨
站脚本攻击。
Cookie域

domain - 这个属性用来比较请求URL中服务端的域名。如果域名匹配成功，或这是其子域
名，则继续检查       path 属性。
path - 除了域名，cookie可用的URL路径也可以被指定。当域名和路径都匹配时，cookie才会
随请求发送。
expires - 这个属性用来设置持久化的cookie，当设置了它之后，cookie在指定的时间到达之
前都不会过期。
5. 浏览器安全控制                                                                                    

X-XSS-Protection

防止反射型XSS
Strict-Transport-Security

强制使用HTTPS通信
CSP

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_c
nvoid#%E6%A6%82%E8%BF%B0

https://juejin.im/post/5c6ad29ff265da2da00ea459

HTTP 响应头 Content-Security-Policy     允许站点管理者在指定的页面控制用户代理的资源。除了少数例外，
这条政策将极大地指定服务源 以及脚本端点。这将帮助防止跨站脚本攻击（Cross-Site Script）                               (XSS).

<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 
https://*; child-src 'none';">





安全防范的总结

https://www.tuicool.com/articles/7Ff2EbZ



无头浏览器技术 - JS 控制API 直接操纵Chrome

 

 

 

 

 
 

 

 

 

 

 


## 参考

## 疑问