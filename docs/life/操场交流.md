---
title: 三个小伙伴的每日交流
---
[[toc]]

## vue的通信方式

父子通信=>两种

隔代通信=>两种

兄弟通信=>两种

## TCP三次连接和四次挥手

了解TCP报文头，各种标志位含义


### 为什么不能两次连接

前提：假设两次就能建立连接

原因一：无法确定双方的接收和发送能力

解释：

第一次，主机A发送，主机B收到，对于主机B：确定了主机A有发送能力

第二次，主机B发送，主机A收到，对于主机A：确定了主机B的发送能力和接收能力

可以发现，主机B无法确定主机A的接收能力

原因二：可能导致其中一方进入无限等待状态

解释：

第一次发送的数据包滞留了，主机A重发了一次，注意，此时旧的数据包对于主机A已经无法感知了

重发的这次连接很顺利，正常连接，正常挥手结束，此时主机A不再处于监听状态

就在这时，旧的数据包到了主机B，由于主机B一直处于监听状态，会对该数据包进行回应，此时对于主机B来说，连接已经建立(因为前提是两次握手),但是主机A又不搭理主机B，主机B就一直处于连接状态等待主机A发送资源(如果滞留了多个数据包，那么此时就有多个连接状态，但是都是处于无限等待状态)

刚刚假设的是旧数据包很久才到，那么如果旧数据包在重传新数据包之后，抢先在新数据包之前到达主机B呢？这个时候主机B正常应答发送数据包ack=seq+1,主机A收到这个旧数据包了，但是发现seq对应不上新数据包的seq，于是发送RST复位报文通知主机B放弃连接(可惜的是只有两次握手，因此这个通知无法到达主机B，并且主机B在发送出ack包的时候就已经建立连接了)

因此：主机B很容易以为自己成功建立了多次连接，而主机A始终觉得自己只建立了一次连接(因为主机A可以根据seq来判断是不是最新的数据包)


### 为什么不能三次挥手

服务端不能将ACK跟FIN同时发送，因为得预留一些时间将数据传输完毕

### 为什么客户端要等待2msl时间

避免第三次挥手时客户端发送给服务端的ACK报文段接收不到，导致服务端一直关闭不了

## vue生命周期

beforeCreate=>created=>beforeMount=>Mounted=>（beforeUpdate=>updated）=>beforeDestory=>Destroyed

### 为什么异步请求放在created比较合适

一致性，因为服务端没有mounted和beforeMount生命周期钩子

在created发送请求，减少loading时间

## vue插槽原理

## vue-router原理

## 执行上下文(作用域/链,VO变量对象,this)

## vue2.x和vue3.x的diff算法

## vue3中ref，reactive，readonly等API实现

## grid兼容性，能否用float实现grid？
