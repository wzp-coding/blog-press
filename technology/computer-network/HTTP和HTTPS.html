<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP和HTTPS | 吴泽鹏</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog-press/logo.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/blog-press/assets/css/0.styles.1c926e40.css" as="style"><link rel="preload" href="/blog-press/assets/js/app.6139d12d.js" as="script"><link rel="preload" href="/blog-press/assets/js/8.ae6c3984.js" as="script"><link rel="preload" href="/blog-press/assets/js/2.0264d6f2.js" as="script"><link rel="preload" href="/blog-press/assets/js/26.b4efff9b.js" as="script"><link rel="preload" href="/blog-press/assets/js/3.d809f9f2.js" as="script"><link rel="prefetch" href="/blog-press/assets/js/10.d7e47f38.js"><link rel="prefetch" href="/blog-press/assets/js/11.dec774c1.js"><link rel="prefetch" href="/blog-press/assets/js/12.bf4e5bd9.js"><link rel="prefetch" href="/blog-press/assets/js/13.b8d07eb6.js"><link rel="prefetch" href="/blog-press/assets/js/14.c00caa94.js"><link rel="prefetch" href="/blog-press/assets/js/15.9a666249.js"><link rel="prefetch" href="/blog-press/assets/js/16.bd6a696c.js"><link rel="prefetch" href="/blog-press/assets/js/17.3cd69cd0.js"><link rel="prefetch" href="/blog-press/assets/js/18.517287fb.js"><link rel="prefetch" href="/blog-press/assets/js/19.91ac48bf.js"><link rel="prefetch" href="/blog-press/assets/js/20.e32f2fcd.js"><link rel="prefetch" href="/blog-press/assets/js/21.0da0a074.js"><link rel="prefetch" href="/blog-press/assets/js/22.1bd30e45.js"><link rel="prefetch" href="/blog-press/assets/js/23.48cb1fe1.js"><link rel="prefetch" href="/blog-press/assets/js/24.2f91fffc.js"><link rel="prefetch" href="/blog-press/assets/js/25.dde1cf53.js"><link rel="prefetch" href="/blog-press/assets/js/27.37b9aeae.js"><link rel="prefetch" href="/blog-press/assets/js/28.5b257151.js"><link rel="prefetch" href="/blog-press/assets/js/29.0234654e.js"><link rel="prefetch" href="/blog-press/assets/js/30.138d64b3.js"><link rel="prefetch" href="/blog-press/assets/js/31.5083ded0.js"><link rel="prefetch" href="/blog-press/assets/js/32.e9b32179.js"><link rel="prefetch" href="/blog-press/assets/js/33.009994b5.js"><link rel="prefetch" href="/blog-press/assets/js/34.3d45314e.js"><link rel="prefetch" href="/blog-press/assets/js/35.0bb4365b.js"><link rel="prefetch" href="/blog-press/assets/js/36.7bc05dac.js"><link rel="prefetch" href="/blog-press/assets/js/37.c0c6a5c8.js"><link rel="prefetch" href="/blog-press/assets/js/38.f4da4354.js"><link rel="prefetch" href="/blog-press/assets/js/39.5649b375.js"><link rel="prefetch" href="/blog-press/assets/js/4.9e4232dd.js"><link rel="prefetch" href="/blog-press/assets/js/40.2894689c.js"><link rel="prefetch" href="/blog-press/assets/js/41.11221830.js"><link rel="prefetch" href="/blog-press/assets/js/42.d2488d65.js"><link rel="prefetch" href="/blog-press/assets/js/43.66d734aa.js"><link rel="prefetch" href="/blog-press/assets/js/44.1ffab8f9.js"><link rel="prefetch" href="/blog-press/assets/js/45.00e58203.js"><link rel="prefetch" href="/blog-press/assets/js/46.fa6aee68.js"><link rel="prefetch" href="/blog-press/assets/js/47.b5f65afa.js"><link rel="prefetch" href="/blog-press/assets/js/48.61e98198.js"><link rel="prefetch" href="/blog-press/assets/js/49.6207cdd1.js"><link rel="prefetch" href="/blog-press/assets/js/5.007799f8.js"><link rel="prefetch" href="/blog-press/assets/js/50.7dc3280a.js"><link rel="prefetch" href="/blog-press/assets/js/51.825a4e12.js"><link rel="prefetch" href="/blog-press/assets/js/52.ca846de1.js"><link rel="prefetch" href="/blog-press/assets/js/53.3e4e9df9.js"><link rel="prefetch" href="/blog-press/assets/js/54.fcf0bda2.js"><link rel="prefetch" href="/blog-press/assets/js/55.f149c70b.js"><link rel="prefetch" href="/blog-press/assets/js/56.de5a9567.js"><link rel="prefetch" href="/blog-press/assets/js/57.8047ad0c.js"><link rel="prefetch" href="/blog-press/assets/js/58.2eb97615.js"><link rel="prefetch" href="/blog-press/assets/js/59.5b73b1ee.js"><link rel="prefetch" href="/blog-press/assets/js/6.93b98aae.js"><link rel="prefetch" href="/blog-press/assets/js/60.ff4d1ea3.js"><link rel="prefetch" href="/blog-press/assets/js/61.251fdbfd.js"><link rel="prefetch" href="/blog-press/assets/js/62.5e3e7061.js"><link rel="prefetch" href="/blog-press/assets/js/63.7a89825d.js"><link rel="prefetch" href="/blog-press/assets/js/64.7180cc32.js"><link rel="prefetch" href="/blog-press/assets/js/65.009bf214.js"><link rel="prefetch" href="/blog-press/assets/js/66.a41afd3f.js"><link rel="prefetch" href="/blog-press/assets/js/67.6cb1357c.js"><link rel="prefetch" href="/blog-press/assets/js/68.9ddd8ab2.js"><link rel="prefetch" href="/blog-press/assets/js/69.e0768e8d.js"><link rel="prefetch" href="/blog-press/assets/js/7.d02898a9.js"><link rel="prefetch" href="/blog-press/assets/js/70.9d69f736.js"><link rel="prefetch" href="/blog-press/assets/js/71.188f6682.js"><link rel="prefetch" href="/blog-press/assets/js/72.5844fa81.js"><link rel="prefetch" href="/blog-press/assets/js/73.c2a47b6c.js"><link rel="prefetch" href="/blog-press/assets/js/74.c87c63e9.js"><link rel="prefetch" href="/blog-press/assets/js/75.7b2094f7.js"><link rel="prefetch" href="/blog-press/assets/js/76.f5e7d6d7.js"><link rel="prefetch" href="/blog-press/assets/js/77.09ed1df7.js"><link rel="prefetch" href="/blog-press/assets/js/78.c80e3d27.js"><link rel="prefetch" href="/blog-press/assets/js/79.039de0ce.js"><link rel="prefetch" href="/blog-press/assets/js/9.7810b5e0.js">
    <link rel="stylesheet" href="/blog-press/assets/css/0.styles.1c926e40.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog-press/" class="home-link router-link-active"><img src="/blog-press/logo.png" alt="吴泽鹏" class="logo"> <span class="site-name can-hide">吴泽鹏</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-press/technology/html-css/" class="nav-link">
  HtmlCss
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/cli-tools/" class="nav-link">
  构建工具
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/data-base/" class="nav-link">
  Database
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/computer-network/" class="nav-link router-link-active">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/extension/" class="nav-link">
  拓展知识
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/bug/" class="nav-link">
  踩坑日记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wzp-coding/blog-press" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/1521379825951864" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-press/technology/html-css/" class="nav-link">
  HtmlCss
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/cli-tools/" class="nav-link">
  构建工具
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/data-base/" class="nav-link">
  Database
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/computer-network/" class="nav-link router-link-active">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/extension/" class="nav-link">
  拓展知识
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/bug/" class="nav-link">
  踩坑日记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wzp-coding/blog-press" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/1521379825951864" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog-press/technology/computer-network/" aria-current="page" class="sidebar-link">计算机网络发展史</a></li><li><a href="/blog-press/technology/computer-network/DNS与CDN.html" class="sidebar-link">DNS解析原理</a></li><li><a href="/blog-press/technology/computer-network/EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html" class="active sidebar-link">HTTP和HTTPS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#什么是超文本" class="sidebar-link">什么是超文本</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#什么是传输" class="sidebar-link">什么是传输</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#什么是协议" class="sidebar-link">什么是协议</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#总结一下-什么是-http" class="sidebar-link">总结一下，什么是 HTTP？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#与-http-有关的组件" class="sidebar-link">与 HTTP 有关的组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#网络模型" class="sidebar-link">网络模型</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#应用层" class="sidebar-link" style="padding-left:3rem;">应用层</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#运输层" class="sidebar-link" style="padding-left:3rem;">运输层</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#网络层" class="sidebar-link" style="padding-left:3rem;">网络层</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#链路层" class="sidebar-link" style="padding-left:3rem;">链路层</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#物理层" class="sidebar-link" style="padding-left:3rem;">物理层</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#osi-模型" class="sidebar-link">OSI 模型</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#浏览器" class="sidebar-link">浏览器</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#web-服务器" class="sidebar-link">Web 服务器</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#cdn" class="sidebar-link">CDN</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#waf" class="sidebar-link">WAF</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#webservice" class="sidebar-link">WebService</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#html" class="sidebar-link">HTML</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#web-页面构成" class="sidebar-link">Web 页面构成</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#与-http-有关的协议" class="sidebar-link">与 HTTP 有关的协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#tcp-ip" class="sidebar-link">TCP/IP</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#dns" class="sidebar-link">DNS</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#uri-url" class="sidebar-link">URI / URL</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#什么是-https" class="sidebar-link">什么是 HTTPS？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-请求响应过程" class="sidebar-link">HTTP 请求响应过程</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-请求特征" class="sidebar-link">HTTP 请求特征</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-报文" class="sidebar-link">HTTP 报文</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-请求方法" class="sidebar-link">HTTP 请求方法</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-请求-url" class="sidebar-link">HTTP 请求 URL</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-版本" class="sidebar-link">HTTP 版本</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#请求头部" class="sidebar-link">请求头部</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#通用标头" class="sidebar-link" style="padding-left:3rem;">通用标头</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#date" class="sidebar-link" style="padding-left:4rem;">Date</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#cache-control" class="sidebar-link" style="padding-left:4rem;">Cache-Control</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#connection" class="sidebar-link" style="padding-left:4rem;">Connection</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#实体标头" class="sidebar-link" style="padding-left:3rem;">实体标头</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#请求标头" class="sidebar-link" style="padding-left:3rem;">请求标头</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#内容协商" class="sidebar-link" style="padding-left:3rem;">内容协商</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#响应标头" class="sidebar-link" style="padding-left:3rem;">响应标头</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#非-http-1-1-首部字段" class="sidebar-link">非 HTTP/1.1 首部字段</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#end-to-end-首部和-hop-by-hop-首部" class="sidebar-link">End-to-end 首部和 Hop-by-hop 首部</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#end-to-end-端到端-首部" class="sidebar-link">End-to-end（端到端） 首部</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#hop-by-hop-逐跳-首部" class="sidebar-link">Hop-by-hop（逐跳） 首部</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-的优点和缺点" class="sidebar-link">HTTP 的优点和缺点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#简单灵活易扩展" class="sidebar-link" style="padding-left:3rem;">简单灵活易扩展</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#应用广泛、环境成熟" class="sidebar-link" style="padding-left:3rem;">应用广泛、环境成熟</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#无状态" class="sidebar-link" style="padding-left:3rem;">无状态</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#无状态-2" class="sidebar-link" style="padding-left:3rem;">无状态</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#明文" class="sidebar-link" style="padding-left:3rem;">明文</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#性能" class="sidebar-link" style="padding-left:3rem;">性能</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#面试相关" class="sidebar-link">面试相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-和-https-的区别" class="sidebar-link">HTTP 和 HTTPS 的区别</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#简述-http1-0-1-1-2-0-的区别" class="sidebar-link">简述 HTTP1.0/1.1/2.0 的区别</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-1-0" class="sidebar-link" style="padding-left:3rem;">HTTP 1.0</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-1-1" class="sidebar-link" style="padding-left:3rem;">HTTP 1.1</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#http-2-0" class="sidebar-link" style="padding-left:3rem;">HTTP 2.0</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#https-的工作原理-tls-握手-rsa-非对称加密" class="sidebar-link">HTTPS 的工作原理(TLS 握手，RSA 非对称加密)</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/blog-press/technology/computer-network/UDP和TCP.html" class="sidebar-link">UDP和TCP</a></li><li><a href="/blog-press/technology/computer-network/Web Workers.html" class="sidebar-link">Web Worker</a></li><li><a href="/blog-press/technology/computer-network/get和post.html" class="sidebar-link">get和post</a></li><li><a href="/blog-press/technology/computer-network/传输加密安全.html" class="sidebar-link">加密传输</a></li><li><a href="/blog-press/technology/computer-network/前端安全问题.html" class="sidebar-link">前端安全</a></li><li><a href="/blog-press/technology/computer-network/图解HTTP状态码.html" class="sidebar-link">HTTP状态码</a></li><li><a href="/blog-press/technology/computer-network/浏览器渲染原理.html" class="sidebar-link">渲染原理</a></li><li><a href="/blog-press/technology/computer-network/浏览器缓存.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/blog-press/technology/computer-network/浏览器输入URL后发生什么事.html" class="sidebar-link">url输入后发生什么</a></li><li><a href="/blog-press/technology/computer-network/进程和线程.html" class="sidebar-link">进程和线程</a></li><li><a href="/blog-press/technology/computer-network/面试考查.html" class="sidebar-link">知识点</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="了解一下-http-以及-https"><a href="#了解一下-http-以及-https" class="header-anchor">#</a> 了解一下 HTTP 以及 HTTPS</h1> <p></p><div class="table-of-contents"><ul><li><a href="#什么是超文本">什么是超文本</a></li><li><a href="#什么是传输">什么是传输</a></li><li><a href="#什么是协议">什么是协议</a></li><li><a href="#总结一下-什么是-http">总结一下，什么是 HTTP？</a></li><li><a href="#与-http-有关的组件">与 HTTP 有关的组件</a><ul><li><a href="#网络模型">网络模型</a><ul><li><a href="#应用层">应用层</a></li><li><a href="#运输层">运输层</a></li><li><a href="#网络层">网络层</a></li><li><a href="#链路层">链路层</a></li><li><a href="#物理层">物理层</a></li></ul></li><li><a href="#osi-模型">OSI 模型</a></li><li><a href="#浏览器">浏览器</a></li><li><a href="#web-服务器">Web 服务器</a></li><li><a href="#cdn">CDN</a></li><li><a href="#waf">WAF</a></li><li><a href="#webservice">WebService</a></li><li><a href="#html">HTML</a></li><li><a href="#web-页面构成">Web 页面构成</a></li></ul></li><li><a href="#与-http-有关的协议">与 HTTP 有关的协议</a><ul><li><a href="#tcp-ip">TCP/IP</a></li><li><a href="#dns">DNS</a></li><li><a href="#uri-url">URI / URL</a></li></ul></li><li><a href="#什么是-https">什么是 HTTPS？</a></li><li><a href="#http-请求响应过程">HTTP 请求响应过程</a></li><li><a href="#http-请求特征">HTTP 请求特征</a></li><li><a href="#http-报文">HTTP 报文</a><ul><li><a href="#http-请求方法">HTTP 请求方法</a></li><li><a href="#http-请求-url">HTTP 请求 URL</a></li><li><a href="#http-版本">HTTP 版本</a></li><li><a href="#请求头部">请求头部</a><ul><li><a href="#通用标头">通用标头</a><ul><li><a href="#date">Date</a></li><li><a href="#cache-control">Cache-Control</a></li><li><a href="#connection">Connection</a></li></ul></li><li><a href="#实体标头">实体标头</a></li><li><a href="#请求标头">请求标头</a></li><li><a href="#内容协商">内容协商</a></li><li><a href="#响应标头">响应标头</a></li></ul></li></ul></li><li><a href="#非-http-1-1-首部字段">非 HTTP/1.1 首部字段</a></li><li><a href="#end-to-end-首部和-hop-by-hop-首部">End-to-end 首部和 Hop-by-hop 首部</a><ul><li><a href="#end-to-end-端到端-首部">End-to-end（端到端） 首部</a></li><li><a href="#hop-by-hop-逐跳-首部">Hop-by-hop（逐跳） 首部</a></li></ul></li><li><a href="#http-的优点和缺点">HTTP 的优点和缺点</a><ul><li><a href="#优点">优点</a><ul><li><a href="#简单灵活易扩展">简单灵活易扩展</a></li><li><a href="#应用广泛、环境成熟">应用广泛、环境成熟</a></li><li><a href="#无状态">无状态</a></li></ul></li><li><a href="#缺点">缺点</a><ul><li><a href="#无状态">无状态</a></li><li><a href="#明文">明文</a></li><li><a href="#性能">性能</a></li></ul></li></ul></li><li><a href="#面试相关">面试相关</a><ul><li><a href="#http-和-https-的区别">HTTP 和 HTTPS 的区别</a></li><li><a href="#简述-http1-0-1-1-2-0-的区别">简述 HTTP1.0/1.1/2.0 的区别</a><ul><li><a href="#http-1-0">HTTP 1.0</a></li><li><a href="#http-1-1">HTTP 1.1</a></li><li><a href="#http-2-0">HTTP 2.0</a></li></ul></li><li><a href="#https-的工作原理-tls-握手-rsa-非对称加密">HTTPS 的工作原理(TLS 握手，RSA 非对称加密)</a></li></ul></li><li><a href="#参考">参考</a></li></ul></div><p></p> <p>超文本传输协议可以进行文字分割：<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>，它们之间的关系如下：</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142427775.png" alt="image-20211112142427775"></p> <p>按照范围的大小： 协议 &gt; 传输 &gt; 超文本。下面就分别对这三个名字做一个解释。</p> <h2 id="什么是超文本"><a href="#什么是超文本" class="header-anchor">#</a> 什么是超文本</h2> <p>在互联网早期的时候，我们输入的信息只能保存在本地，无法和其他电脑进行交互。我们保存的信息通常都以<code>文本</code>即简单字符的形式存在，文本是一种能够被计算机解析的有意义的二进制数据包。而随着互联网的高速发展，两台电脑之间能够进行数据的传输后，人们不满足只能在两台电脑之间传输文字，还想要传输图片、音频、视频，甚至点击文字或图片能够进行<code>超链接</code>的跳转，那么文本的语义就被扩大了，这种语义扩大后的文本就被称为<code>超文本(Hypertext)</code>。</p> <h2 id="什么是传输"><a href="#什么是传输" class="header-anchor">#</a> 什么是传输</h2> <p>我们上面说到，两台计算机之间会形成互联关系进行通信，我们存储的超文本会被解析成为二进制数据包，由传输载体（例如同轴电缆，电话线，光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称为<code>传输(transfer)</code>。</p> <p>通常我们把传输数据包的一方称为<code>请求方</code>，把接到二进制数据包的一方称为<code>应答方</code>。请求方和应答方可以进行互换，请求方也可以作为应答方接受数据，应答方也可以作为请求方请求数据，它们之间的关系如下</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142433398.png" alt="image-20211112142433398"></p> <p>如图所示，A 和 B 是两个不同的端系统，它们之间可以作为信息交换的载体存在，刚开始的时候是 A 作为请求方请求与 B 交换信息，B 作为响应的一方提供信息；随着时间的推移，B 也可以作为请求方请求 A 交换信息，那么 A 也可以作为响应方响应 B 请求的信息。</p> <h2 id="什么是协议"><a href="#什么是协议" class="header-anchor">#</a> 什么是协议</h2> <p>网络协议就是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议。</p> <h2 id="总结一下-什么是-http"><a href="#总结一下-什么是-http" class="header-anchor">#</a> 总结一下，什么是 HTTP？</h2> <p><strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p> <h2 id="与-http-有关的组件"><a href="#与-http-有关的组件" class="header-anchor">#</a> 与 HTTP 有关的组件</h2> <p>随着网络世界演进，HTTP 协议已经几乎成为不可替代的一种协议，在了解了 HTTP 的基本组成后，下面再来带你进一步认识一下 HTTP 协议。</p> <h3 id="网络模型"><a href="#网络模型" class="header-anchor">#</a> 网络模型</h3> <p>网络是一个复杂的系统，不仅包括大量的应用程序、端系统、通信链路、分组交换机等，还有各种各样的协议组成，那么现在我们就来聊一下网络中的协议层次。</p> <p>为了给网络协议的设计提供一个结构，网络设计者以<code>分层(layer)</code>的方式组织协议，每个协议属于层次模型之一。每一层都是向它的上一层提供<code>服务(service)</code>，即所谓的<code>服务模型(service model)</code>。每个分层中所有的协议称为 <code>协议栈(protocol stack)</code>。因特网的协议栈由五个部分组成：物理层、链路层、网络层、运输层和应用层。我们采用自上而下的方法研究其原理，也就是应用层 -&gt; 物理层的方式。</p> <h4 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h4> <p>应用层是网络应用程序和网络协议存放的分层，因特网的应用层包括许多协议，例如我们学 web 离不开的 <code>HTTP</code>，电子邮件传送协议 <code>SMTP</code>、端系统文件上传协议 <code>FTP</code>、还有为我们进行域名解析的 <code>DNS</code> 协议。应用层协议分布在多个端系统上，一个端系统应用程序与另外一个端系统应用程序交换信息分组，我们把位于应用层的信息分组称为 <code>报文(message)</code>。</p> <h4 id="运输层"><a href="#运输层" class="header-anchor">#</a> 运输层</h4> <p>因特网的运输层在应用程序断点之间传送应用程序报文，在这一层主要有两种传输协议 <code>TCP</code>和 <code>UDP</code>，利用这两者中的任何一个都能够传输报文，不过这两种协议有巨大的不同。</p> <p>TCP 向它的应用程序提供了面向连接的服务，它能够控制并确认报文是否到达，并提供了拥塞机制来控制网络传输，因此当网络拥塞时，会抑制其传输速率。</p> <p>UDP 协议向它的应用程序提供了无连接服务。它不具备可靠性的特征，没有流量控制，也没有拥塞控制。我们把运输层的分组称为 <code>报文段(segment)</code></p> <h4 id="网络层"><a href="#网络层" class="header-anchor">#</a> 网络层</h4> <p>因特网的网络层负责将称为 <code>数据报(datagram)</code> 的网络分层从一台主机移动到另一台主机。网络层一个非常重要的协议是 <code>IP</code> 协议，所有具有网络层的因特网组件都必须运行 IP 协议，IP 协议是一种网际协议，除了 IP 协议外，网络层还包括一些其他网际协议和路由选择协议，一般把网络层就称为 IP 层，由此可知 IP 协议的重要性。</p> <h4 id="链路层"><a href="#链路层" class="header-anchor">#</a> 链路层</h4> <p>现在我们有应用程序通信的协议，有了给应用程序提供运输的协议，还有了用于约定发送位置的 IP 协议，那么如何才能真正的发送数据呢？为了将分组从一个节点（主机或路由器）运输到另一个节点，网络层必须依靠链路层提供服务。链路层的例子包括以太网、WiFi 和电缆接入的 <code>DOCSIS</code> 协议，因为数据从源目的地传送通常需要经过几条链路，一个数据包可能被沿途不同的链路层协议处理，我们把链路层的分组称为 <code>帧(frame)</code></p> <h4 id="物理层"><a href="#物理层" class="header-anchor">#</a> 物理层</h4> <p>虽然链路层的作用是将帧从一个端系统运输到另一个端系统，而物理层的作用是将帧中的一个个 <code>比特</code> 从一个节点运输到另一个节点，物理层的协议仍然使用链路层协议，这些协议与实际的物理传输介质有关，例如，以太网有很多物理层协议：关于双绞铜线、关于同轴电缆、关于光纤等等。</p> <p>五层网络协议的示意图如下</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142439179.png" alt="image-20211112142439179"></p> <h3 id="osi-模型"><a href="#osi-模型" class="header-anchor">#</a> OSI 模型</h3> <p>我们上面讨论的计算网络协议模型不是唯一的 <code>协议栈</code>，ISO（国际标准化组织）提出来计算机网络应该按照 7 层来组织，那么 7 层网络协议栈与 5 层的区别在哪里？</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142443470.png" alt="image-20211112142443470"></p> <p>从图中可以一眼看出，OSI 要比上面的网络模型多了 <code>表示层</code> 和 <code>会话层</code>，其他层基本一致。表示层主要包括数据压缩和数据加密以及数据描述，数据描述使得应用程序不必担心计算机内部存储格式的问题，而会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案。</p> <h3 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h3> <p>就如同各大邮箱使用电子邮件传送协议 <code>SMTP</code> 一样，浏览器是使用 HTTP 协议的主要载体，说到浏览器，你能想起来几种？是的，随着网景大战结束后，浏览器迅速发展，至今已经出现过的浏览器主要有</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142447508.png" alt="image-20211112142447508"></p> <p>浏览器正式的名字叫做 <code>Web Browser</code>，顾名思义，就是检索、查看互联网上网页资源的应用程序，名字里的 Web，实际上指的就是 <code>World Wide Web</code>，也就是万维网。</p> <p>我们在地址栏输入 URL（即网址），浏览器会向 DNS（域名服务器）提供网址，由它来完成 URL 到 IP 地址的映射。然后将请求你的请求提交给具体的服务器，在由服务器返回我们要的结果（以 HTML 编码格式返回给浏览器），浏览器执行 HTML 编码，将结果显示在浏览器的正文。这就是一个浏览器发起请求和接受响应的过程。</p> <h3 id="web-服务器"><a href="#web-服务器" class="header-anchor">#</a> Web 服务器</h3> <p>Web 服务器的正式名称叫做 <code>Web Server</code>，Web 服务器一般指的是网站服务器，上面说到浏览器是 HTTP 请求的发起方，那么 Web 服务器就是 HTTP 请求的应答方，Web 服务器可以向浏览器等 Web 客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个 Web 服务器是 Apache、 Nginx 、IIS。</p> <h3 id="cdn"><a href="#cdn" class="header-anchor">#</a> CDN</h3> <p>CDN 的全称是 Content Delivery Network，即内容分发网络，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户<strong>就近获取</strong>所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有<strong>内容存储</strong>和<strong>分发技术</strong>。</p> <p>打比方说你要去亚马逊上买书，之前你只能通过购物网站购买后从美国发货过海关等重重关卡送到你的家里，现在在中国建立一个亚马逊分基地，你就不用通过美国进行邮寄，从中国就能把书尽快给你送到。</p> <h3 id="waf"><a href="#waf" class="header-anchor">#</a> WAF</h3> <p>WAF 是一种 Web 应用程序防护系统（Web Application Firewall，简称 WAF），它是一种通过执行一系列针对 HTTP / HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品，它是应用层面的<strong>防火墙</strong>，专门检测 HTTP 流量，是防护 Web 应用的安全技术。</p> <p>WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p> <h3 id="webservice"><a href="#webservice" class="header-anchor">#</a> WebService</h3> <p>WebService 是一种 Web 应用程序，<strong>WebService 是一种跨编程语言和跨操作系统平台的远程调用技术</strong>。</p> <p>Web Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，它是<strong>一个基于 Web（HTTP）的服务架构技术</strong>，既可以运行在内网，也可以在适当保护后运行在外网。</p> <h3 id="html"><a href="#html" class="header-anchor">#</a> HTML</h3> <p>HTML 称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的 Internet 资源连接为一个逻辑整体。HTML 文本是由 HTML 命令组成的描述性文本，HTML 命令可以说明文字，图形、动画、声音、表格、链接等。</p> <h3 id="web-页面构成"><a href="#web-页面构成" class="header-anchor">#</a> Web 页面构成</h3> <p>Web 页面（Web page）也叫做文档，是由一个个对象组成的。一个<code>对象(Objecy)</code> 只是一个文件，比如一个 HTML 文件、一个 JPEG 图形、一个 Java 小程序或一个视频片段，它们在网络中可以通过 <code>URL</code> 地址寻址。多数的 Web 页面含有一个 <code>HTML 基本文件</code> 以及几个引用对象。</p> <p>举个例子，如果一个 Web 页面包含 HTML 文件和 5 个 JPEG 图形，那么这个 Web 页面就有 6 个对象：一个 HTML 文件和 5 个 JPEG 图形。HTML 基本文件通过 URL 地址引用页面中的其他对象。</p> <h2 id="与-http-有关的协议"><a href="#与-http-有关的协议" class="header-anchor">#</a> 与 HTTP 有关的协议</h2> <p>在互联网中，任何协议都不会单独的完成信息交换，HTTP 也一样。虽然 HTTP 属于应用层的协议，但是它仍然需要其他层次协议的配合完成信息的交换，那么在完成一次 HTTP 请求和响应的过程中，需要哪些协议的配合呢？一起来看一下</p> <h3 id="tcp-ip"><a href="#tcp-ip" class="header-anchor">#</a> TCP/IP</h3> <p><code>TCP/IP</code> 协议你一定听过，TCP/IP 我们一般称之为<code>协议簇</code>，什么意思呢？就是 TCP/IP 协议簇中不仅仅只有 TCP 协议和 IP 协议，它是一系列网络通信协议的统称。而其中最核心的两个协议就是 TCP / IP 协议，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p> <p>TCP 协议的全称是 <code>Transmission Control Protocol</code> 的缩写，意思是<code>传输控制协议</code>，HTTP 使用 TCP 作为通信协议，这是因为 TCP 是一种可靠的协议，而<code>可靠</code>能保证数据不丢失。</p> <p>IP 协议的全称是 <code>Internet Protocol</code> 的缩写，它主要解决的是通信双方寻址的问题。IP 协议使用 <code>IP 地址</code> 来标识互联网上的每一台计算机，可以把 IP 地址想象成为你手机的电话号码，你要与他人通话必须先要知道他人的手机号码，计算机网络中信息交换必须先要知道对方的 IP 地址。</p> <h3 id="dns"><a href="#dns" class="header-anchor">#</a> DNS</h3> <p>你有没有想过为什么你可以通过键入 <code>www.google.com</code> 就能够获取你想要的网站？我们上面说到，计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 <code>DNS 协议</code>。</p> <p>DNS 的全称是<code>域名系统（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p> <h3 id="uri-url"><a href="#uri-url" class="header-anchor">#</a> URI / URL</h3> <p>我们上面提到，你可以通过输入 <code>www.google.com</code> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 <code>URI</code> 的规范。</p> <p><code>URI</code>的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p> <p><code>URL</code>的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的<code>网址</code>，它实际上是 URI 的一个子集。</p> <p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142453198.png" alt="image-20211112142453198"></p> <h2 id="什么是-https"><a href="#什么是-https" class="header-anchor">#</a> 什么是 HTTPS？</h2> <p>HTTP 一般是明文传输，很容易被攻击者窃取重要信息，鉴于此，HTTPS 应运而生。HTTPS 的全称为 （Hyper Text Transfer Protocol over SecureSocket Layer），全称有点长，HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础上增加了 <code>SSL</code> 层，也就是说 <strong>HTTPS = HTTP + SSL</strong>。</p> <h2 id="http-请求响应过程"><a href="#http-请求响应过程" class="header-anchor">#</a> HTTP 请求响应过程</h2> <p>当在浏览器中输入网址后，到底发生了什么事情？假设访问的 URL 地址为 <code>http://www.someSchool.edu/someDepartment/home.index</code>，当我们输入网址并点击回车时，浏览器内部会进行如下操作</p> <ul><li>DNS 服务器会首先进行域名的映射，找到访问<code>www.someSchool.edu</code>所在的地址，然后 HTTP 客户端进程在 80 端口发起一个到服务器 <code>www.someSchool.edu</code> 的 TCP 连接（80 端口是 HTTP 的默认端口）。在客户和服务器进程中都会有一个<code>套接字</code>与其相连。</li> <li>HTTP 客户端通过它的套接字向服务器发送一个 HTTP 请求报文。该报文中包含了路径 <code>someDepartment/home.index</code> 的资源，</li> <li>HTTP 服务器通过它的套接字接受该报文，进行请求的解析工作，并从其<code>存储器(RAM 或磁盘)</code>中检索出对象 www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到 HTTP 响应报文中，并通过套接字向客户进行发送。</li> <li>HTTP 服务器随即通知 TCP 断开 TCP 连接，实际上是需要等到客户接受完响应报文后才会断开 TCP 连接。</li> <li>HTTP 客户端接受完响应报文后，TCP 连接会关闭。HTTP 客户端从响应中提取出报文中是一个 HTML 响应文件，并检查该 HTML 文件，然后循环检查报文中其他内部对象。</li> <li>检查完成后，HTTP 客户端会把对应的资源通过显示器呈现给用户。</li></ul> <p>真实的请求-响应情况可能要比上面描述的过程复杂很多。</p> <h2 id="http-请求特征"><a href="#http-请求特征" class="header-anchor">#</a> HTTP 请求特征</h2> <p>从上面整个过程中我们可以总结出 HTTP 进行分组传输是具有以下特征</p> <ul><li>支持客户-服务器模式</li> <li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li> <li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li> <li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li> <li>无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul> <h2 id="http-报文"><a href="#http-报文" class="header-anchor">#</a> HTTP 报文</h2> <p>HTTP 协议主要由三大部分组成：</p> <ul><li><code>起始行（start line）</code>：描述请求或响应的基本信息；</li> <li><code>头部字段（header）</code>：使用 key-value 形式更详细地说明报文；</li> <li><code>消息正文（entity）</code>：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li></ul> <p>其中起始行和头部字段并成为 <code>请求头</code> 或者 <code>响应头</code>，统称为 <code>Header</code>；消息正文也叫做实体，称为 <code>body</code>。HTTP 协议规定每次发送的报文必须要有 Header，但是可以没有 body，也就是说头信息是必须的，实体信息可以没有。而且在 header 和 body 之间必须要有一个空行（CRLF），如果用一幅图来表示一下的话，我觉得应该是下面这样</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142458092.png" alt="image-20211112142458092"></p> <p>我们使用上面的那个例子来看一下 http 的请求报文</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142501843.png" alt="image-20211112142501843"></p> <p>如图，这是 <code>http://www.someSchool.edu/someDepartment/home.index</code> 请求的请求头，通过观察这个 HTTP 报文我们就能够学到很多东西，首先，我们看到报文是用普通 <code>ASCII</code> 文本书写的，这样保证人能够可以看懂。然后，我们可以看到每一行和下一行之间都会有换行，而且最后一行（请求头部后）再加上一个回车换行符。</p> <p>每个报文的起始行都是由三个字段组成：<strong>方法、URL 字段和 HTTP 版本字段</strong>。</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142505513.png" alt="image-20211112142505513"></p> <h3 id="http-请求方法"><a href="#http-请求方法" class="header-anchor">#</a> HTTP 请求方法</h3> <p>HTTP 请求方法一般分为 8 种，它们分别是</p> <ul><li><p><code>GET 获取资源</code>，GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；</p></li> <li><p><code>POST 传输实体</code>，虽然 GET 方法也可以传输主体信息，但是便于区分，我们一般不用 GET 传输实体信息，反而使用 POST 传输实体信息，</p></li> <li><p><code>PUT 传输文件</code>，PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</p> <p>但是，鉴于 HTTP 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 W eb 网站不使用该方法。若配合 W eb 应用程序的验证机制，或架构设计采用<code>REST（REpresentational State Transfer，表征状态转移）</code>标准的同类 Web 网站，就可能会开放使用 PUT 方法。</p></li> <li><p><code>HEAD 获得响应首部</code>，HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。</p></li> <li><p><code>DELETE 删除文件</code>，DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。</p></li> <li><p><code>OPTIONS 询问支持的方法</code>，OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</p></li> <li><p><code>TRACE 追踪路径</code>，TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。</p></li> <li><p><code>CONNECT 要求用隧道协议连接代理</code>，CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 <code>SSL（Secure Sockets Layer，安全套接层）</code>和 <code>TLS（Transport Layer Security，传输层安全）</code>协议把通信内容加 密后经网络隧道传输。</p></li></ul> <p>我们一般最常用的方法也就是 GET 方法和 POST 方法，其他方法暂时了解即可。下面是 HTTP1.0 和 HTTP1.1 支持的方法清单</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142508986.png" alt="image-20211112142508986"></p> <h3 id="http-请求-url"><a href="#http-请求-url" class="header-anchor">#</a> HTTP 请求 URL</h3> <p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。URL 带有请求对象的标识符。在上面的例子中，浏览器正在请求对象 <code>/somedir/page.html</code> 的资源。</p> <p>我们再通过一个完整的域名解析一下 URL</p> <p>比如 <code>http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</code> 这个 URL 比较繁琐了吧，你把这个 URL 搞懂了其他的 URL 也就不成问题了。</p> <p>首先出场的是 <code>http</code></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142512503.png" alt="image-20211112142512503"></p> <p><code>http://</code>告诉浏览器使用何种协议。对于大部分 Web 资源，通常使用 HTTP 协议或其安全版本，HTTPS 协议。另外，浏览器也知道如何处理其他协议。例如， <code>mailto:</code> 协议指示浏览器打开邮件客户端；<code>ftp:</code>协议指示浏览器处理文件传输。</p> <p>第二个出场的是 <code>主机</code></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142516399.png" alt="image-20211112142516399"></p> <p><code>www.example.com</code> 既是一个域名，也代表管理该域名的机构。它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/IP_address" target="_blank" rel="noopener noreferrer">IP address<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 地址发起请求。但直接使用 IP 地址的场景并不常见。</p> <p>第三个出场的是 <code>端口</code></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142519977.png" alt="image-20211112142519977"></p> <p>我们前面说到，两个主机之间要发起 TCP 连接需要两个条件，主机 + 端口。它表示用于访问 Web 服务器上资源的入口。如果访问的该 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。</p> <p>上面是请求 URL 所必须包含的部分，下面就是 URL 具体请求资源路径</p> <p>第四个出场的是 <code>路径</code></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142525758.png" alt="image-20211112142525758"></p> <p><code>/path/to/myfile.html</code> 是 Web 服务器上资源的路径。以端口后面的第一个 <code>/</code> 开始，到 <code>?</code> 号之前结束，中间的 每一个<code>/</code> 都代表了层级（上下级）关系。这个 URL 的请求资源是一个 html 页面。</p> <p>紧跟着路径后面的是 <code>查询参数</code></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142529610.png" alt="image-20211112142529610"></p> <p><code>?key1=value1&amp;key2=value2</code> 是提供给 Web 服务器的额外参数。如果是 GET 请求，一般带有请求 URL 参数，如果是 POST 请求，则不会在路径后面直接加参数。这些参数是用 &amp; 符号分隔的<code>键/值对</code>列表。key1 = value1 是第一对，key2 = value2 是第二对参数</p> <p>紧跟着参数的是<code>锚点</code></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142532899.png" alt="image-20211112142532899"></p> <p><code>#SomewhereInTheDocument</code> 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在 HTML 文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。</p> <h3 id="http-版本"><a href="#http-版本" class="header-anchor">#</a> HTTP 版本</h3> <p>表示报文使用的 HTTP 协议版本。</p> <h3 id="请求头部"><a href="#请求头部" class="header-anchor">#</a> 请求头部</h3> <p>在表述完了起始行之后我们再来看一下<code>请求头部</code>，现在我们向上找，找到<code>http://www.someSchool.edu/someDepartment/home.index</code>，来看一下它的请求头部</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Host:</span> www.someschool.edu
<span class="token header-name keyword">Connection:</span> close
<span class="token header-name keyword">User-agent:</span> Mozilla/5.0
<span class="token header-name keyword">Accept-language:</span> fr
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个请求头信息比较少</p> <ul><li>首先 <code>Host</code> 表示的是对象所在的主机。你也许认为这个 Host 是不需要的，因为 URL 不是已经指明了请求对象的路径了吗？这个首部行提供的信息是 <code>Web 代理高速缓存</code>所需要的。</li> <li><code>Connection: close</code> 表示的是浏览器需要告诉服务器使用的是<code>非持久连接</code>。它要求服务器在发送完响应的对象后就关闭连接。</li> <li><code>User-agent</code>: 这是请求头用来告诉 Web 服务器，浏览器使用的类型是 <code>Mozilla/5.0</code>，即 Firefox 浏览器。</li> <li><code>Accept-language</code> 告诉 Web 服务器，浏览器想要得到对象的法语版本，前提是服务器需要支持法语类型，否则将会发送服务器的默认版本。</li> <li>下面我们针对主要的实体字段进行介绍（具体的可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener noreferrer">developer.mozilla.org/zh-CN/docs/…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> MDN 官网学习）</li></ul> <p>HTTP 的请求标头分为四种： <code>通用标头</code>、<code>请求标头</code>、<code>响应标头</code> 和 <code>实体标头</code>，依次来进行详解。</p> <h4 id="通用标头"><a href="#通用标头" class="header-anchor">#</a> 通用标头</h4> <p>通用标头主要有三个，分别是 <code>Date</code>、<code>Cache-Control</code> 和 <code>Connection</code></p> <h5 id="date"><a href="#date" class="header-anchor">#</a> <strong>Date</strong></h5> <p>Date 是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Date: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>表示的是格林威治标准时间，这个时间要比北京时间慢八个小时</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142538113.png" alt="image-20211112142538113"></p> <h5 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> <strong>Cache-Control</strong></h5> <p>Cache-Control 是一个通用标头，他可以出现在请求标头和响应标头中，Cache-Control 的种类比较多，虽然说这是一个通用标头，但是又一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 <code>可缓存性</code>、<code>阈值性</code>、 <code>重新验证并重新加载</code> 和<code>其他特性</code></p> <p>可缓存性是唯一响应标头才具有的特性，我们会在响应标头中详述。</p> <p>阈值性，这个我翻译可能不准确，它的原英文是 Expiration，我是根据它的值来翻译的，你看到这些值可能会觉得我翻译的有点道理</p> <ul><li><code>max-age</code>: 资源被认为仍然有效的最长时间，与 <code>Expires</code> 不同，这个请求是相对于 request 标头的时间，而 Expires 是相对于响应标头。（请求标头）</li> <li><code>s-maxage</code>: 重写了 max-age 和 Expires 请求头，仅仅适用于共享缓存，被私有缓存所忽略（这块不理解，看完响应头的 Cache-Control 再进行理解）（请求标头）</li> <li><code>max-stale</code>：表示客户端将接受的最大响应时间，以秒为单位。（响应标头）</li> <li><code>min-fresh</code>: 表示客户端希望响应在指定的最小时间内有效。（响应标头）</li></ul> <h5 id="connection"><a href="#connection" class="header-anchor">#</a> <strong>Connection</strong></h5> <p>Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是<code>持久性连接</code>，即一次事务完成后不关闭网络连接</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Connection:</span> keep-alive
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>另一种是<code>非持久性连接</code>，即一次事务完成后关闭网络连接</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Connection:</span> close
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>HTTP1.1 其他通用标头如下</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142548160.png" alt="image-20211112142548160"></p> <h4 id="实体标头"><a href="#实体标头" class="header-anchor">#</a> 实体标头</h4> <p>实体标头是描述消息正文内容的 HTTP 标头。实体标头用于 HTTP 请求和响应中。头部<code>Content-Length</code>、 <code>Content-Language</code>、 <code>Content-Encoding</code> 是实体头。</p> <ul><li>Content-Length 实体报头指示实体主体的大小，以字节为单位，发送到接收方。</li> <li>Content-Language 实体报头描述了客户端或者服务端能够接受的语言，例如</li></ul> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Content-Language:</span> de-DE
<span class="token header-name keyword">Content-Language:</span> en-US
<span class="token header-name keyword">Content-Language:</span> de-DE, en-CA
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><p>Content-Encoding 这又是一个比较麻烦的属性，这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。</p> <p>常见的内容编码有这几种： <strong>gzip、compress、deflate、identity</strong> ，这个属性可以应用在请求报文和响应报文中</p></li></ul> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate //请求头
<span class="token header-name keyword">Content-Encoding:</span> gzip  //响应头
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>下面是一些实体标头字段</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142553183.png" alt="image-20211112142553183"></p> <h4 id="请求标头"><a href="#请求标头" class="header-anchor">#</a> 请求标头</h4> <p>上面给出的例子请求报文的属性比较少，下面给出一个 MDN 官网的例子</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/home.html</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header-name keyword">Host:</span> developer.mozilla.org
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
<span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
<span class="token header-name keyword">Accept-Language:</span> en-US,en;q=0.5
<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate, br
<span class="token header-name keyword">Referer:</span> https://developer.mozilla.org/testpage.html
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Upgrade-Insecure-Requests:</span> 1
<span class="token header-name keyword">If-Modified-Since:</span> Mon, 18 Jul 2016 02:36:04 GMT
<span class="token header-name keyword">If-None-Match:</span> &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;
<span class="token header-name keyword">Cache-Control:</span> max-age=0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>Host</strong></p> <p>Host 请求头指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的 TCP 端口号。如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个 HTTP 的 URL 会自动使用 80 作为端口）。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Host:</span> developer.mozilla.org
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面的 <code>Accpet</code>、 <code>Accept-Language</code>、<code>Accept-Encoding</code> 都是属于内容协商的请求标头，我们会在下面说明</p> <p><strong>Referer</strong></p> <p>HTTP Referer 属性是请求标头的一部分，当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Referer:</span> https://developer.mozilla.org/testpage.html
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>Upgrade-Insecure-Requests</strong></p> <p>Upgrade-Insecure-Requests 是一个请求标头，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Upgrade-Insecure-Requests:</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>If-Modified-Since</strong></p> <p>HTTP 的 If-Modified-Since 使其成为<code>条件请求</code>：</p> <ul><li>返回 200，只有在给定日期的最后一次修改资源后，服务器才会以 200 状态发送回请求的资源。</li> <li>如果请求从开始以来没有被修改过，响应会返回 304 并且没有任何响应体</li></ul> <p>If-Modified-Since 通常会与 If-None-Match 搭配使用，If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 <code>Last-Modified</code> 来确定。</p> <p>大白话说就是如果在 <code>Last-Modified</code> 之后更新了服务器资源，那么服务器会响应 200，如果在 <code>Last-Modified</code> 之后没有更新过资源，则返回 304。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">If-Modified-Since:</span> Mon, 18 Jul 2016 02:36:04 GMT
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>If-None-Match</strong></p> <p>If-None-Match HTTP 请求标头使请求成为条件请求。 对于 GET 和 HEAD 方法，仅当服务器没有与给定资源匹配的 <code>ETag</code> 时，服务器才会以 200 状态发送回请求的资源。 对于其他方法，仅当最终现有资源的<code>ETag</code>与列出的任何值都不匹配时，才会处理请求。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">If-None-Match:</span> &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>ETag 属于响应标头，后面进行介绍。</p> <h4 id="内容协商"><a href="#内容协商" class="header-anchor">#</a> 内容协商</h4> <p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的标准。</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142558985.png" alt="image-20211112142558985"></p> <p>内容协商主要有以下 3 种类型：</p> <ul><li><code>服务器驱动协商（Server-driven Negotiation）</code></li></ul> <p>这种协商方式是由服务器端进行内容协商。服务器端会根据请求首部字段进行自动处理</p> <ul><li><code>客户端驱动协商（Agent-driven Negotiation）</code></li></ul> <p>这种协商方式是由客户端来进行内容协商。</p> <ul><li><code>透明协商（Transparent Negotiation）</code></li></ul> <p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p> <p>内容协商的分类有很多种，主要的几种类型是 <strong>Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language</strong>。</p> <p><strong>Accept</strong></p> <p>接受请求 HTTP 标头会通告客户端其能够理解的 MIME 类型</p> <p>那么什么是 MIME 类型呢？在回答这个问题前你应该先了解一下什么是 MIME</p> <blockquote><p>MIME: MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p></blockquote> <p>也就是说，MIME 类型其实就是一系列消息内容类型的集合。那么 MIME 类型都有哪些呢？</p> <p><code>文本文件</code>： text/html、text/plain、text/css、application/xhtml+xml、application/xml</p> <p><code>图片文件</code>： image/jpeg、image/gif、image/png</p> <p><code>视频文件</code>： video/mpeg、video/quicktime</p> <p><code>应用程序二进制文件</code>： application/octet-stream、application/zip</p> <p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。</p> <p>一般 MIME 类型也会和 <code>q</code> 这个属性一起使用，q 是什么？q 表示的是权重，来看一个例子</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这是什么意思呢？若想要给显示的<strong>媒体类型增加优先级</strong>，则使用 q= 来额外表示权重值，没有显示权重的时候默认值是 1.0 ，我给你列个表格你就明白了</p> <table><thead><tr><th>q</th> <th>MIME</th></tr></thead> <tbody><tr><td>1.0</td> <td>text/html</td></tr> <tr><td>1.0</td> <td>application/xhtml+xml</td></tr> <tr><td>0.9</td> <td>application/xml</td></tr> <tr><td>0.8</td> <td>_ / _</td></tr></tbody></table> <p>也就是说，这是一个放置顺序，权重高的在前，低的在后，<code>application/xml;q=0.9</code> 是不可分割的整体。</p> <p><strong>Accept-Charset</strong></p> <p>accept-charset 属性规定服务器处理表单数据所接受的字符集。</p> <p>accept-charset 属性允许您指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。</p> <p>该属性的值是用引号包含字符集名称列表。如果可接受字符集与用户所使用的字符即不相匹配的话，浏览器可以选择忽略表单或是将该表单区别对待。</p> <p>此属性的默认值是 <code>unknown</code>，表示表单的字符集与包含表单的文档的字符集相同。</p> <p>常用的字符集有： UTF-8 - Unicode 字符编码 ； ISO-8859-1 - 拉丁字母表的字符编码</p> <p><strong>Accept-Language</strong></p> <p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。 和 Accept 首部字段一样，按权重值 <code>q</code>来表示相对优先级。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Accept-Language:</span> en-US,en;q=0.5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>请求标头我们大概就介绍这几种，后面会有一篇文章详细深挖所有的响应头的，下面是一个响应头的汇总，基于 HTTP 1.1</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142604459.png" alt="image-20211112142604459"></p> <h4 id="响应标头"><a href="#响应标头" class="header-anchor">#</a> 响应标头</h4> <p>响应标头是可以在 HTTP 响应种使用的 HTTP 标头，这听起来是像一句废话，不过确实是这样解释。并不是所有出现在响应中的标头都是响应标头。还有一些特殊的我们上面说过，有通用标头和实体标头也会出现在响应标头中，比如 <code>Content-Length</code> 就是一个实体标头，但是，在这种情况下，这些实体请求通常称为响应头。下面以一个例子为例和你探讨一下响应头</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code>200 OK
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> *
<span class="token header-name keyword">Connection:</span> Keep-Alive
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Date:</span> Mon, 18 Jul 2016 16:06:00 GMT
<span class="token header-name keyword">Etag:</span> &quot;c561c68d0ba92bbeb8b0f612a9199f722e3a621a&quot;
<span class="token header-name keyword">Keep-Alive:</span> timeout=5, max=997
<span class="token header-name keyword">Last-Modified:</span> Mon, 18 Jul 2016 02:36:04 GMT
<span class="token header-name keyword">Server:</span> Apache
<span class="token header-name keyword">Set-Cookie:</span> mykey=myvalue; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure
<span class="token header-name keyword">Transfer-Encoding:</span> chunked
<span class="token header-name keyword">Vary:</span> Cookie, Accept-Encoding
<span class="token header-name keyword">x-frame-options:</span> DENY
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>响应状态码</strong></p> <p>首先出现的应该就是 <code>200 OK</code>，这是 HTTP 响应标头的状态码，它表示着响应成功完成。HTTP 响应标头的状态码有很多，并做了如下规定</p> <p>以 <code>2xx</code> 为开头的都表示请求成功响应。</p> <table><thead><tr><th>状态码</th> <th>含义</th></tr></thead> <tbody><tr><td>200</td> <td>成功响应</td></tr> <tr><td>204</td> <td>请求处理成功，但是没有资源可以返回</td></tr> <tr><td>206</td> <td>对资源某一部分进行响应，由 Content-Range 指定范围的实体内容。</td></tr></tbody></table> <p>以 <code>3xx</code> 为开头的都表示需要进行附加操作以完成请求</p> <table><thead><tr><th>状态码</th> <th>含义</th></tr></thead> <tbody><tr><td>301</td> <td>永久性重定向，该状态码表示请求的资源已经重新分配 URI，以后应该使用资源现有的 URI</td></tr> <tr><td>302</td> <td>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</td></tr> <tr><td>303</td> <td>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</td></tr> <tr><td>304</td> <td>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。</td></tr> <tr><td>307</td> <td>临时重定向。该状态码与 302 Found 有着相同的含义。</td></tr></tbody></table> <p>以 <code>4xx</code> 的响应结果表明客户端是发生错误的原因所在</p> <table><thead><tr><th>状态码</th> <th>含义</th></tr></thead> <tbody><tr><td>400</td> <td>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</td></tr> <tr><td>401</td> <td>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</td></tr> <tr><td>403</td> <td>该状态码表明对请求资源的访问被服务器拒绝了。</td></tr> <tr><td>404</td> <td>该状态码表明服务器上无法找到请求的资源。</td></tr></tbody></table> <p>以 <code>5xx</code> 为开头的响应标头都表示服务器本身发生错误</p> <table><thead><tr><th>状态码</th> <th>含义</th></tr></thead> <tbody><tr><td>500</td> <td>该状态码表明服务器端在执行请求时发生了错误。</td></tr> <tr><td>503</td> <td>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</td></tr></tbody></table> <p><strong>Access-Control-Allow-Origin</strong></p> <p>一个返回的 HTTP 标头可能会具有 Access-Control-Allow-Origin ，<code>Access-Control-Allow-Origin</code> 指定一个来源，它告诉浏览器允许该来源进行资源访问。 否则-对于没有凭据的请求 <code>*</code>通配符，告诉浏览器允许任何源访问资源。例如，要允许源 <code>https://mozilla.org</code> 的代码访问资源，可以指定：</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Access-Control-Allow-Origin:</span> https://mozilla.org
<span class="token header-name keyword">Vary:</span> Origin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果服务器指定单个来源而不是 <code>*</code>通配符的话 ，则服务器还应在 Vary 响应标头中包含 <code>Origin</code> ，以向客户端指示 服务器响应将根据原 http 始请求标头的值而有所不同。</p> <p><strong>Keep-Alive</strong></p> <p>上面我们提到，HTTP 报文标头会分为四种，这其实是按着<code>上下文</code>来分类的</p> <p>还有一种分类是根据<code>代理</code>进行分类，根据代理会分为<code>端到端头</code> 和 <code>逐跳标头</code></p> <p>而 Keep-Alive 表示的是 Connection 非持续连接的存活时间，如下</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Connection:</span> Keep-Alive
<span class="token header-name keyword">Keep-Alive:</span> timeout=5, max=997
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Keep-Alive 有两个参数，它们是以逗号分隔的参数列表，每个参数由一个标识符和一个由等号 = 分隔的值组成。</p> <p><code>timeout</code>：指示空闲连接必须保持打开状态的最短时间（以秒为单位）。</p> <p><code>max</code>：指示在关闭连接之前可以在此连接上发送的最大请求数。</p> <p>上述 HTTP 代码的意思就是限制最大的超时时间是 5s 和 最大的连接请求是 997 个。</p> <p><strong>Server</strong></p> <p>服务器标头包含有关原始服务器用来处理请求的软件的信息。</p> <p>应该避免使用过于冗长和详细的 Server 值，因为它们可能会泄露内部实施细节，这可能会使攻击者容易地发现并利用已知的安全漏洞。例如下面这种写法</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Server:</span> Apache/2.4.1 (Unix)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>Set-Cookie</strong></p> <p>Cookie 又是另外一个领域的内容了，我们后面文章会说道 Cookie，这里需要记住 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们不是属于 HTTP 1.1 的首部字段，但是使用率仍然很高。</p> <p><strong>Transfer-Encoding</strong></p> <p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">Transfer-Encoding:</span> chunked
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>HTTP /1.1 的传输编码方式仅对分块传输编码有效。</p> <p><strong>X-Frame-Options</strong></p> <p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p> <p>首部字段 <code>X-Frame-Options</code> 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p> <p>下面是一个响应头的汇总，基于 HTTP 1.1</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142609829.png" alt="image-20211112142609829"></p> <h2 id="非-http-1-1-首部字段"><a href="#非-http-1-1-首部字段" class="header-anchor">#</a> 非 HTTP/1.1 首部字段</h2> <p>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。 这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</p> <h2 id="end-to-end-首部和-hop-by-hop-首部"><a href="#end-to-end-首部和-hop-by-hop-首部" class="header-anchor">#</a> End-to-end 首部和 Hop-by-hop 首部</h2> <p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。</p> <p>一种是 <code>End-to-end</code> 首部 和 <code>Hop-by-hop</code> 首部</p> <h3 id="end-to-end-端到端-首部"><a href="#end-to-end-端到端-首部" class="header-anchor">#</a> End-to-end（端到端） 首部</h3> <p>这些标头必须发送给消息的最终接收者 : 请求的服务器，或响应的客户端。中间代理必须重新传输未经修改的标头，并且缓存必须存储这些信息</p> <h3 id="hop-by-hop-逐跳-首部"><a href="#hop-by-hop-逐跳-首部" class="header-anchor">#</a> Hop-by-hop（逐跳） 首部</h3> <p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。</p> <p>下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。</p> <p><strong>Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade</strong></p> <h2 id="http-的优点和缺点"><a href="#http-的优点和缺点" class="header-anchor">#</a> HTTP 的优点和缺点</h2> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <h4 id="简单灵活易扩展"><a href="#简单灵活易扩展" class="header-anchor">#</a> 简单灵活易扩展</h4> <p>HTTP 最重要也是最突出的优点是 <strong>简单、灵活、易于扩展</strong>。</p> <p>HTTP 的协议比较简单，它的主要组成就是 <code>header + body</code>，头部信息也是简单的文本格式，而且 HTTP 的请求报文根据英文也能猜出来个大概的意思，降低学习门槛，能够让更多的人研究和开发 HTTP 应用。</p> <p>所以，在简单的基础上，HTTP 协议又多了<code>灵活</code> 和 <code>易扩展</code> 的优点。</p> <p>HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被制定死，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由。</p> <h4 id="应用广泛、环境成熟"><a href="#应用广泛、环境成熟" class="header-anchor">#</a> 应用广泛、环境成熟</h4> <p>因为过于简单，普及，因此应用很广泛。因为 HTTP 协议本身不属于一种语言，它并不限定某种编程语言或者操作系统，所以天然具有<strong>跨语言、跨平台</strong>的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具。</p> <p>随着移动互联网的发展， HTTP 的触角已经延伸到了世界的每一个角落，从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP、新闻、论坛、购物、手机游戏，你很难找到一个没有使用 HTTP 的地方。</p> <h4 id="无状态"><a href="#无状态" class="header-anchor">#</a> 无状态</h4> <p>无状态其实既是优点又是缺点。因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <h4 id="无状态-2"><a href="#无状态-2" class="header-anchor">#</a> 无状态</h4> <p>既然服务器没有记忆能力，它就无法支持需要连续多个步骤的<code>事务</code>操作。每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。由此出现了 <code>Cookie</code> 技术。</p> <h4 id="明文"><a href="#明文" class="header-anchor">#</a> 明文</h4> <p>HTTP 协议里还有一把优缺点一体的双刃剑，就是<strong>明文传输</strong>。明文意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。</p> <p>对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利。</p> <p>当然缺点也是显而易见的，就是<code>不安全</code>，可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被更改过。</p> <h4 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h4> <p>HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间</p> <h2 id="面试相关"><a href="#面试相关" class="header-anchor">#</a> 面试相关</h2> <h3 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="header-anchor">#</a> HTTP 和 HTTPS 的区别</h3> <p>HTTP 是一种 <code>超文本传输协议(Hypertext Transfer Protocol)</code>，<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p> <p>HTTPS 的全称是 <code>Hypertext Transfer Protocol Secure</code>，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 TLS/SSL 所做的工作。</p> <p>也就是说，<strong>HTTPS 就是身披了一层 SSL 的 HTTP</strong>。</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142616806.png" alt="image-20211112142616806"></p> <p>那么，HTTP 和 HTTPS 的主要区别是什么呢？</p> <ul><li>最简单的，HTTP 在地址栏上的协议是以 <code>http://</code> 开头，而 HTTPS 在地址栏上的协议是以 <code>https://</code> 开头</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>http://www.cxuanblog.com/
https://www.cxuanblog.com/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 <strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong> 能够解决上面这些问题。</li></ul> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142622933.png" alt="image-20211112142622933"></p> <ul><li>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</li></ul> <h3 id="简述-http1-0-1-1-2-0-的区别"><a href="#简述-http1-0-1-1-2-0-的区别" class="header-anchor">#</a> 简述 HTTP1.0/1.1/2.0 的区别</h3> <h4 id="http-1-0"><a href="#http-1-0" class="header-anchor">#</a> HTTP 1.0</h4> <p>HTTP 1.0 是在 1996 年引入的，从那时开始，它的普及率就达到了惊人的效果。</p> <ul><li>HTTP 1.0 仅仅提供了最基本的认证，这时候用户名和密码还未经加密，因此很容易收到窥探。</li> <li>HTTP 1.0 被设计用来使用短链接，即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。</li> <li>HTTP 1.0 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li> <li>HTTP 1.0 不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li> <li>HTTP 1.0 认为每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）。</li></ul> <h4 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> HTTP 1.1</h4> <p>HTTP 1.1 是 HTTP 1.0 开发三年后出现的，也就是 1999 年，它做出了以下方面的变化</p> <ul><li>HTTP 1.1 使用了摘要算法来进行身份验证</li> <li>HTTP 1.1 默认使用长连接，长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 <code>keep-alive</code> 来设置</li> <li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</li> <li>HTTP 1.1 支持断点续传，通过使用请求头中的 <code>Range</code> 来实现。</li> <li>HTTP 1.1 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。</li></ul> <h4 id="http-2-0"><a href="#http-2-0" class="header-anchor">#</a> HTTP 2.0</h4> <p>HTTP 2.0 是 2015 年开发出来的标准，它主要做的改变如下</p> <ul><li><p><code>头部压缩</code>，由于 HTTP 1.1 经常会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</p></li> <li><p><code>二进制格式</code>，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，提升了解析效率</p></li> <li><p><code>强化安全</code>，由于安全已经成为重中之重，所以 HTTP2.0 一般都跑在 HTTPS 上。</p></li> <li><p><code>多路复用</code>，即每一个请求都是是用作连接共享。一个请求对应一个 id，这样一个连接上可以有多个请求。</p></li></ul> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142627242.png" alt="image-20211112142627242"></p> <h3 id="https-的工作原理-tls-握手-rsa-非对称加密"><a href="#https-的工作原理-tls-握手-rsa-非对称加密" class="header-anchor">#</a> HTTPS 的工作原理(TLS 握手，RSA 非对称加密)</h3> <p>HTTPS 不是一种新出现的协议，而是 HTTP+SSL = HTTPS</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142632640.png" alt="image-20211112142632640"></p> <p>所以，我们探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。</p> <p>TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。</p> <p>每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用 HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。</p> <p>TLS 具体的握手过程会根据所使用的<code>密钥交换算法的类型</code>和双方支持的<code>密码套件</code>而不同。 我们以<code>RSA 非对称加密</code>来讨论这个过程。整个 TLS 通信流程图如下</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112142635829.png" alt="image-20211112142635829"></p> <ul><li>在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程</li> <li>ClientHello：客户端通过向服务器发送 <code>hello</code> 消息来发起握手过程。这个消息中会夹带着客户端支持的 <code>TLS 版本号(TLS1.0 、TLS1.2、TLS1.3)</code> 、客户端支持的密码套件、以及一串 <code>客户端随机数</code>。</li> <li>ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。</li> <li>认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 <code>Certificate</code> 报文，报文中包含公开密钥证书。最后服务器发送 <code>ServerHelloDone</code> 作为 <code>hello</code> 请求的响应。第一部分握手阶段结束。</li> <li><code>加密阶段</code>：在第一个阶段握手完成后，客户端会发送 <code>ClientKeyExchange</code> 作为响应，这个响应中包含了一种称为 <code>The premaster secret</code> 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 <code>ChangeCipherSpec</code>，告诉服务端使用私钥解密这个 <code>premaster secret</code> 的字符串，然后客户端发送 <code>Finished</code> 告诉服务端自己发送完成了。</li></ul> <blockquote><p>Session key 其实就是用公钥证书加密的公钥。</p></blockquote> <ul><li><code>实现了安全的非对称加密</code>：然后，服务器再发送 <code>ChangeCipherSpec</code> 和 <code>Finished</code> 告诉客户端解密完成，至此实现了 RSA 的非对称加密</li></ul> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <blockquote><p><a href="https://juejin.cn/post/6844904132067885064#heading-1" target="_blank" rel="noopener noreferrer">面试 HTTP ，99% 的面试官都爱问这些问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844904045572800525#heading-48" target="_blank" rel="noopener noreferrer">看完这篇 HTTP，跟面试官扯皮就没问题了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">4 小时前</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-press/technology/computer-network/EventLoop.html" class="prev">
        EventLoop
      </a></span> <span class="next"><a href="/blog-press/technology/computer-network/UDP和TCP.html">
        UDP和TCP
      </a>
      →
    </span></p></div>  <!----></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog-press/assets/js/app.6139d12d.js" defer></script><script src="/blog-press/assets/js/8.ae6c3984.js" defer></script><script src="/blog-press/assets/js/2.0264d6f2.js" defer></script><script src="/blog-press/assets/js/26.b4efff9b.js" defer></script><script src="/blog-press/assets/js/3.d809f9f2.js" defer></script>
  </body>
</html>
