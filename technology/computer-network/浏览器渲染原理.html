<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>渲染原理 | 吴泽鹏</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog-press/logo.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/blog-press/assets/css/0.styles.1c926e40.css" as="style"><link rel="preload" href="/blog-press/assets/js/app.6139d12d.js" as="script"><link rel="preload" href="/blog-press/assets/js/8.ae6c3984.js" as="script"><link rel="preload" href="/blog-press/assets/js/2.0264d6f2.js" as="script"><link rel="preload" href="/blog-press/assets/js/34.3d45314e.js" as="script"><link rel="preload" href="/blog-press/assets/js/3.d809f9f2.js" as="script"><link rel="prefetch" href="/blog-press/assets/js/10.d7e47f38.js"><link rel="prefetch" href="/blog-press/assets/js/11.dec774c1.js"><link rel="prefetch" href="/blog-press/assets/js/12.bf4e5bd9.js"><link rel="prefetch" href="/blog-press/assets/js/13.b8d07eb6.js"><link rel="prefetch" href="/blog-press/assets/js/14.c00caa94.js"><link rel="prefetch" href="/blog-press/assets/js/15.9a666249.js"><link rel="prefetch" href="/blog-press/assets/js/16.bd6a696c.js"><link rel="prefetch" href="/blog-press/assets/js/17.3cd69cd0.js"><link rel="prefetch" href="/blog-press/assets/js/18.517287fb.js"><link rel="prefetch" href="/blog-press/assets/js/19.91ac48bf.js"><link rel="prefetch" href="/blog-press/assets/js/20.e32f2fcd.js"><link rel="prefetch" href="/blog-press/assets/js/21.0da0a074.js"><link rel="prefetch" href="/blog-press/assets/js/22.1bd30e45.js"><link rel="prefetch" href="/blog-press/assets/js/23.48cb1fe1.js"><link rel="prefetch" href="/blog-press/assets/js/24.2f91fffc.js"><link rel="prefetch" href="/blog-press/assets/js/25.dde1cf53.js"><link rel="prefetch" href="/blog-press/assets/js/26.b4efff9b.js"><link rel="prefetch" href="/blog-press/assets/js/27.37b9aeae.js"><link rel="prefetch" href="/blog-press/assets/js/28.5b257151.js"><link rel="prefetch" href="/blog-press/assets/js/29.0234654e.js"><link rel="prefetch" href="/blog-press/assets/js/30.138d64b3.js"><link rel="prefetch" href="/blog-press/assets/js/31.5083ded0.js"><link rel="prefetch" href="/blog-press/assets/js/32.e9b32179.js"><link rel="prefetch" href="/blog-press/assets/js/33.009994b5.js"><link rel="prefetch" href="/blog-press/assets/js/35.0bb4365b.js"><link rel="prefetch" href="/blog-press/assets/js/36.7bc05dac.js"><link rel="prefetch" href="/blog-press/assets/js/37.c0c6a5c8.js"><link rel="prefetch" href="/blog-press/assets/js/38.f4da4354.js"><link rel="prefetch" href="/blog-press/assets/js/39.5649b375.js"><link rel="prefetch" href="/blog-press/assets/js/4.9e4232dd.js"><link rel="prefetch" href="/blog-press/assets/js/40.2894689c.js"><link rel="prefetch" href="/blog-press/assets/js/41.11221830.js"><link rel="prefetch" href="/blog-press/assets/js/42.d2488d65.js"><link rel="prefetch" href="/blog-press/assets/js/43.66d734aa.js"><link rel="prefetch" href="/blog-press/assets/js/44.1ffab8f9.js"><link rel="prefetch" href="/blog-press/assets/js/45.00e58203.js"><link rel="prefetch" href="/blog-press/assets/js/46.fa6aee68.js"><link rel="prefetch" href="/blog-press/assets/js/47.b5f65afa.js"><link rel="prefetch" href="/blog-press/assets/js/48.61e98198.js"><link rel="prefetch" href="/blog-press/assets/js/49.6207cdd1.js"><link rel="prefetch" href="/blog-press/assets/js/5.007799f8.js"><link rel="prefetch" href="/blog-press/assets/js/50.7dc3280a.js"><link rel="prefetch" href="/blog-press/assets/js/51.825a4e12.js"><link rel="prefetch" href="/blog-press/assets/js/52.ca846de1.js"><link rel="prefetch" href="/blog-press/assets/js/53.3e4e9df9.js"><link rel="prefetch" href="/blog-press/assets/js/54.fcf0bda2.js"><link rel="prefetch" href="/blog-press/assets/js/55.f149c70b.js"><link rel="prefetch" href="/blog-press/assets/js/56.de5a9567.js"><link rel="prefetch" href="/blog-press/assets/js/57.8047ad0c.js"><link rel="prefetch" href="/blog-press/assets/js/58.2eb97615.js"><link rel="prefetch" href="/blog-press/assets/js/59.5b73b1ee.js"><link rel="prefetch" href="/blog-press/assets/js/6.93b98aae.js"><link rel="prefetch" href="/blog-press/assets/js/60.ff4d1ea3.js"><link rel="prefetch" href="/blog-press/assets/js/61.251fdbfd.js"><link rel="prefetch" href="/blog-press/assets/js/62.5e3e7061.js"><link rel="prefetch" href="/blog-press/assets/js/63.7a89825d.js"><link rel="prefetch" href="/blog-press/assets/js/64.7180cc32.js"><link rel="prefetch" href="/blog-press/assets/js/65.009bf214.js"><link rel="prefetch" href="/blog-press/assets/js/66.a41afd3f.js"><link rel="prefetch" href="/blog-press/assets/js/67.6cb1357c.js"><link rel="prefetch" href="/blog-press/assets/js/68.9ddd8ab2.js"><link rel="prefetch" href="/blog-press/assets/js/69.e0768e8d.js"><link rel="prefetch" href="/blog-press/assets/js/7.d02898a9.js"><link rel="prefetch" href="/blog-press/assets/js/70.9d69f736.js"><link rel="prefetch" href="/blog-press/assets/js/71.188f6682.js"><link rel="prefetch" href="/blog-press/assets/js/72.5844fa81.js"><link rel="prefetch" href="/blog-press/assets/js/73.c2a47b6c.js"><link rel="prefetch" href="/blog-press/assets/js/74.c87c63e9.js"><link rel="prefetch" href="/blog-press/assets/js/75.7b2094f7.js"><link rel="prefetch" href="/blog-press/assets/js/76.f5e7d6d7.js"><link rel="prefetch" href="/blog-press/assets/js/77.09ed1df7.js"><link rel="prefetch" href="/blog-press/assets/js/78.c80e3d27.js"><link rel="prefetch" href="/blog-press/assets/js/79.039de0ce.js"><link rel="prefetch" href="/blog-press/assets/js/9.7810b5e0.js">
    <link rel="stylesheet" href="/blog-press/assets/css/0.styles.1c926e40.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog-press/" class="home-link router-link-active"><img src="/blog-press/logo.png" alt="吴泽鹏" class="logo"> <span class="site-name can-hide">吴泽鹏</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-press/technology/html-css/" class="nav-link">
  HtmlCss
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/cli-tools/" class="nav-link">
  构建工具
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/data-base/" class="nav-link">
  Database
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/computer-network/" class="nav-link router-link-active">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/extension/" class="nav-link">
  拓展知识
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/bug/" class="nav-link">
  踩坑日记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wzp-coding/blog-press" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/1521379825951864" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-press/technology/html-css/" class="nav-link">
  HtmlCss
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/cli-tools/" class="nav-link">
  构建工具
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/data-base/" class="nav-link">
  Database
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/computer-network/" class="nav-link router-link-active">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/extension/" class="nav-link">
  拓展知识
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/bug/" class="nav-link">
  踩坑日记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wzp-coding/blog-press" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/1521379825951864" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog-press/technology/computer-network/" aria-current="page" class="sidebar-link">计算机网络发展史</a></li><li><a href="/blog-press/technology/computer-network/DNS与CDN.html" class="sidebar-link">DNS解析原理</a></li><li><a href="/blog-press/technology/computer-network/EventLoop.html" class="sidebar-link">EventLoop</a></li><li><a href="/blog-press/technology/computer-network/HTTP和HTTPS.html" class="sidebar-link">HTTP和HTTPS</a></li><li><a href="/blog-press/technology/computer-network/UDP和TCP.html" class="sidebar-link">UDP和TCP</a></li><li><a href="/blog-press/technology/computer-network/Web Workers.html" class="sidebar-link">Web Worker</a></li><li><a href="/blog-press/technology/computer-network/get和post.html" class="sidebar-link">get和post</a></li><li><a href="/blog-press/technology/computer-network/传输加密安全.html" class="sidebar-link">加密传输</a></li><li><a href="/blog-press/technology/computer-network/前端安全问题.html" class="sidebar-link">前端安全</a></li><li><a href="/blog-press/technology/computer-network/图解HTTP状态码.html" class="sidebar-link">HTTP状态码</a></li><li><a href="/blog-press/technology/computer-network/浏览器渲染原理.html" class="active sidebar-link">渲染原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#关键渲染路径" class="sidebar-link">关键渲染路径</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#dom-tree" class="sidebar-link">DOM Tree</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#构建流程" class="sidebar-link">构建流程</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#词法分析-标记化" class="sidebar-link">词法分析（标记化）</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#语法分析-解析器" class="sidebar-link">语法分析（解析器）</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#cssom-tree" class="sidebar-link">CSSOM Tree</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#样式计算" class="sidebar-link">样式计算</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#格式化样式表" class="sidebar-link">格式化样式表</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#标准化样式表" class="sidebar-link">标准化样式表</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#计算每个-dom-节点具体样式" class="sidebar-link">计算每个 DOM 节点具体样式</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#题外话-另一种说法-cssom" class="sidebar-link">（题外话）另一种说法 CSSOM</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#生成布局树" class="sidebar-link">生成布局树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#创建布局树" class="sidebar-link">创建布局树</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#布局计算" class="sidebar-link">布局计算</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#梳理前三个阶段" class="sidebar-link">梳理前三个阶段</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#分层" class="sidebar-link">分层</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#生成图层树" class="sidebar-link">生成图层树</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#显式合成" class="sidebar-link">显式合成</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#一、-拥有层叠上下文的节点。" class="sidebar-link" style="padding-left:3rem;">一、 拥有层叠上下文的节点。</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#二、需要剪裁-clip-的地方。" class="sidebar-link" style="padding-left:3rem;">二、需要剪裁(clip)的地方。</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#隐式合成" class="sidebar-link">隐式合成</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#绘制" class="sidebar-link">绘制</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#分块" class="sidebar-link">分块</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#光栅化" class="sidebar-link">光栅化</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#合成和显示" class="sidebar-link">合成和显示</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#回流-重绘-合成" class="sidebar-link">回流-重绘-合成</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#重排-回流-布局" class="sidebar-link">重排（回流/布局）</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#重绘" class="sidebar-link">重绘</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#flush-队列" class="sidebar-link">flush 队列</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#合成" class="sidebar-link">合成</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#gpu-加速原因" class="sidebar-link">GPU 加速原因</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#实践意义" class="sidebar-link">实践意义</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#面试知识点" class="sidebar-link">面试知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#load-和-domcontentloaded-区别" class="sidebar-link">Load 和 DOMContentLoaded 区别</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#图层-layer" class="sidebar-link">图层（Layer）</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#重绘-repaint-和回流-reflow" class="sidebar-link">重绘（Repaint）和回流（Reflow）</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#减少重绘和回流" class="sidebar-link">减少重绘和回流</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#行内样式和-cssstylesheet-的区别" class="sidebar-link">行内样式和 CSSStyleSheet 的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/computer-network/浏览器渲染原理.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/blog-press/technology/computer-network/浏览器缓存.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/blog-press/technology/computer-network/浏览器输入URL后发生什么事.html" class="sidebar-link">url输入后发生什么</a></li><li><a href="/blog-press/technology/computer-network/进程和线程.html" class="sidebar-link">进程和线程</a></li><li><a href="/blog-press/technology/computer-network/面试考查.html" class="sidebar-link">知识点</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="了解一下渲染原理"><a href="#了解一下渲染原理" class="header-anchor">#</a> 了解一下渲染原理</h1> <p></p><div class="table-of-contents"><ul><li><a href="#关键渲染路径">关键渲染路径</a></li><li><a href="#dom-tree">DOM Tree</a><ul><li><a href="#构建流程">构建流程</a></li><li><a href="#词法分析-标记化">词法分析（标记化）</a></li><li><a href="#语法分析-解析器">语法分析（解析器）</a></li></ul></li><li><a href="#cssom-tree">CSSOM Tree</a><ul><li><a href="#样式计算">样式计算</a></li><li><a href="#格式化样式表">格式化样式表</a></li><li><a href="#标准化样式表">标准化样式表</a></li><li><a href="#计算每个-dom-节点具体样式">计算每个 DOM 节点具体样式</a></li></ul></li><li><a href="#题外话-另一种说法-cssom">（题外话）另一种说法 CSSOM</a></li><li><a href="#生成布局树">生成布局树</a><ul><li><a href="#创建布局树">创建布局树</a></li><li><a href="#布局计算">布局计算</a></li><li><a href="#梳理前三个阶段">梳理前三个阶段</a></li></ul></li><li><a href="#分层">分层</a><ul><li><a href="#生成图层树">生成图层树</a></li><li><a href="#显式合成">显式合成</a><ul><li><a href="#一、-拥有-层叠上下文-的节点。">一、 拥有层叠上下文的节点。</a></li><li><a href="#二、需要-剪裁-clip-的地方。">二、需要剪裁(clip)的地方。</a></li></ul></li><li><a href="#隐式合成">隐式合成</a></li></ul></li><li><a href="#绘制">绘制</a></li><li><a href="#分块">分块</a></li><li><a href="#光栅化">光栅化</a></li><li><a href="#合成和显示">合成和显示</a></li><li><a href="#回流-重绘-合成">回流-重绘-合成</a><ul><li><a href="#重排-回流-布局">重排（回流/布局）</a></li><li><a href="#重绘">重绘</a></li><li><a href="#flush-队列">flush 队列</a></li><li><a href="#合成">合成</a></li><li><a href="#gpu-加速原因">GPU 加速原因</a></li></ul></li><li><a href="#实践意义">实践意义</a></li><li><a href="#面试知识点">面试知识点</a><ul><li><a href="#load-和-domcontentloaded-区别">Load 和 DOMContentLoaded 区别</a></li><li><a href="#图层-layer">图层（Layer）</a></li><li><a href="#重绘-repaint-和回流-reflow">重绘（Repaint）和回流（Reflow）</a></li><li><a href="#减少重绘和回流">减少重绘和回流</a></li><li><a href="#行内样式和-cssstylesheet-的区别">行内样式和 CSSStyleSheet 的区别</a></li></ul></li><li><a href="#参考">参考</a></li></ul></div><p></p> <p>浏览器的渲染原理大致都差不多，下面是 Chrome 浏览器的渲染流程</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103214132.png" alt="image-20211112103214132"></p> <h2 id="关键渲染路径"><a href="#关键渲染路径" class="header-anchor">#</a> 关键渲染路径</h2> <blockquote><p>关键渲染路径指的是浏览器将<code>HTML</code>，<code>CSS</code>，<code>JS</code>转化为实际运作的网站的必须采取的一系列步骤</p></blockquote> <ol><li>渲染进程的<u>主线程</u>处理 HTML 并构建 <u>DOM Tree(文档对象模型树)</u></li> <li>接下来处理 <code>CSS</code> 并构建<u><code>CSSOM Tree</code>(CSS 对象模型树)</u></li> <li>浏览器的布局系统根据 <code>DOM Tree</code> 和 <code>CSSOM Tree</code> 生成 <u>（布局树）<code>Layout Tree</code></u>（以前叫 Render Object Tree）</li> <li>构建<u>（图层树） Layer Tree</u> 以便用正确的顺序展示页面，这棵树的生成与 <code>Layout Tree</code> 的构建<u>同步进行</u></li> <li>生成<u>绘制列表</u>，渲染进程中的<u>主线程</u> 给 <u>合成线程</u>发送 commit 消息，把绘制列表<u>交给合成线程</u></li> <li>合成线程会根据绘制列表<u>绘制图层</u></li></ol> <p>较为专业的术语</p> <ol><li>构建 DOM 树（DOM Tree）</li> <li>样式计算（CSSOM Tree）</li> <li>布局阶段（Layout Tree）</li> <li>分层（Layer Tree）</li> <li>绘制（Paint）</li> <li>分块（Tile）</li> <li>光栅化</li> <li>合成</li></ol> <p>想象一下，从 0，1 字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到<u>字节流数据</u>后，经过这些子阶段的处理，最后输出像素，这个过程可以称为渲染流水线 ，我们从一张图上来看</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103219819.png" alt="image-20211112103219819"></p> <h2 id="dom-tree"><a href="#dom-tree" class="header-anchor">#</a> DOM Tree</h2> <blockquote><p>DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 交互的 API 文档。DOM 是载入到浏览器中的文档模型，它用节点树的形式来表现文档，每个节点代表文档的构成部分。</p></blockquote> <p>需要说明的是 DOM 只是构建了文档标记的<u>属性和关系</u>，并没有说明元素需要呈现的样式，这需要 CSSOM 来处理。</p> <h3 id="构建流程"><a href="#构建流程" class="header-anchor">#</a> 构建流程</h3> <p>获取到 HTML 字节数据后，会通过以下流程构建 DOM Tree：</p> <p><u>字节 → 字符 → 令牌 → 节点 → 对象模型(DOM)</u></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">&quot;viewport&quot;</span> content<span class="token operator">=</span><span class="token string">&quot;width=device-width,initial-scale=1&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>link href<span class="token operator">=</span><span class="token string">&quot;style.css&quot;</span> rel<span class="token operator">=</span><span class="token string">&quot;stylesheet&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Critical Path<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>Hello <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>web performance<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span> students<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;awesome-photo.jpg&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103224957.png" alt="image-20211112103224957"></p> <ol><li>编码：浏览器从<u>磁盘或网络</u>读取 HTML 的<u>原始字节</u>，并根据文件的指定编码（例如 UTF-8）将它们<u>转换成各个字符</u>。</li> <li>词法分析（标记化）：浏览器对输入字符串进行<u>逐字扫描</u>，根据 <u>构词规则</u> 识别单词和符号，分割成一个个我们可以理解的词汇（学名叫 <u>Token</u> ）的过程。</li> <li>语法分析（解析器）：对 Tokens 应用 HTML 的<u>语法规则</u>，进行<u>配对标记</u>、<u>确立节点关系</u>和<u>绑定属性</u>等操作，从而构建 DOM Tree 的过程。</li></ol> <p>词法分析和语法分析在每次处理 HTML 字符串时都会执行这个过程，比如使用 document.write 方法。</p> <img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20201209230559302.png" alt="image-20201209230559302" style="zoom:80%;"> <h3 id="词法分析-标记化"><a href="#词法分析-标记化" class="header-anchor">#</a> 词法分析（标记化）</h3> <p>HTML 结构不算太复杂，大部分情况下识别的标记会有开始标记、内容标记和结束标记，对应一个 HTML 元素。除此之外还有 DOCTYPE、Comment、EndOfFile 等标记。</p> <p>标记化是通过<u>状态机</u>来实现的，状态机模型在 W3C 中已经定义好了。</p> <p>想要得到一个标记，必须要经历一些状态，才能完成解析。我们通过一个简单的例子来了解一下流程。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>www.w3c.org<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>W3C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20201209230619688.png" alt="image-20201209230619688"></p> <ul><li>开始标记：</li> <li>Data state：碰到 <strong>&lt;</strong>，进入 Tag open state</li> <li>Tag open state：碰到 <strong>a</strong>，进入 Tag name state 状态</li> <li>Tag name state：碰到 <strong>空格</strong>，进入 Before attribute name state</li> <li>Before attribute name state：碰到 <strong>h</strong>，进入 Attribute name state</li> <li>Attribute name state：碰到 <strong>=</strong>，进入 Before attribute value state</li> <li>Before attribute value state：碰到 <strong>&quot;</strong>，进入 Attribute value (double-quoted) state</li> <li>Attribute value (double-quoted) state：碰到 <strong>w</strong>，保持当前状态</li> <li>Attribute value (double-quoted) state：碰到 <strong>&quot;</strong>，进入 After attribute value (quoted) state</li> <li>After attribute value (quoted) state：碰到 <strong>&gt;</strong>，进入 Data state，完成解析</li> <li>内容标记：W3C</li> <li>Data state：碰到 <strong>W</strong>，保持当前状态，提取内容</li> <li>Data state：碰到 <strong>&lt;</strong>，进入 Tag open state，完成解析</li> <li>结束标记：</li> <li>Tag open state：碰到 <strong>/</strong>，进入 End tag open state</li> <li>End tag open state：碰到 <strong>a</strong>，进入 Tag name state</li> <li>Tag name state：碰到 <strong>&gt;</strong>，进入 Data state，完成解析</li></ul> <p>通过上面这个例子，可以发现属性是<strong>开始标记</strong>的一部分。</p> <h3 id="语法分析-解析器"><a href="#语法分析-解析器" class="header-anchor">#</a> 语法分析（解析器）</h3> <p>在创建解析器后，会关联一个 Document 对象作为<u>根节点</u>。</p> <p>我会简单介绍一下流程，具体的实现过程可以在 Tree construction 查看。</p> <p>解析器在运行过程中，会对 Tokens 进行迭代；并根据当前 Token 的类型转换到对应的模式，再在当前模式下处理 Token；此时，如果 Token 是一个开始标记，就会创建对应的元素，添加到 DOM Tree 中，并压入还未遇到结束标记的开始标记栈中；此栈的主要目的是实现浏览器的容错机制，纠正嵌套错误，具体的策略在 W3C 中定义。更多标记的处理可以在 状态机算法中查看。</p> <h2 id="cssom-tree"><a href="#cssom-tree" class="header-anchor">#</a> CSSOM Tree</h2> <h3 id="样式计算"><a href="#样式计算" class="header-anchor">#</a> 样式计算</h3> <p>这个子阶段主要有三个步骤</p> <ul><li><u>格式化</u>样式表</li> <li><u>标准化</u>样式表</li> <li><u>计算</u>每个 DOM 节点具体样式</li></ul> <h3 id="格式化样式表"><a href="#格式化样式表" class="header-anchor">#</a> 格式化样式表</h3> <p>我们拿到的也就是 0，1 字节流数据，浏览器无法直接去识别的，所以渲染引擎收到 CSS 文本数据后，会执行一个操作，转换为浏览器可以理解的结构-<code>styleSheets</code></p> <p>如果你很想了解这个格式化的过程，可以好好去研究下，不同的浏览器可能在 CSS 格式化过程中会有所不同，在这里就不展开篇幅了。</p> <p>通过浏览器的控制台<code>document.styleSheets</code>可以来查看这个最终结果。<u>通过 JavaScript 可以完成查询和修改功能</u>,或者说这个阶段为后面的样式操作提供基石。</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20201210150959740.png" alt="image-20201210150959740"></p> <h3 id="标准化样式表"><a href="#标准化样式表" class="header-anchor">#</a> 标准化样式表</h3> <p>什么是标准化样式表呢?先看一段 CSS 文本 👇</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 2em<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">p</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">span</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">div</span> <span class="token punctuation">{</span>
  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">div p</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">div</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>有些时候，我们写 CSS 样式的时候，会写<code>font-size:2em;color:red;font-weight:bold</code>,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如<code>em</code>-&gt;<code>px</code>,<code>red</code>-&gt;<code>rgba(255,0,0,0)</code>,<code>bold</code>-&gt;<code>700</code>等等。</p> <p>上面的代码标准后属性值是什么样子呢</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103249771.png" alt="image-20211112103249771"></p> <h3 id="计算每个-dom-节点具体样式"><a href="#计算每个-dom-节点具体样式" class="header-anchor">#</a> 计算每个 DOM 节点具体样式</h3> <p>通过<u>格式化</u>和<u>标准化</u>，接下来就是计算每个节点具体样式信息了。</p> <p>计算规则：<u>继承</u>和<u>层叠</u></p> <p>继承：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫<code>UserAgent样式</code>。</p> <p>层叠：样式层叠，是 CSS 一个基本特征，它定义如何合并来自多个源的属性值的算法。某种意义上，它处于核心地位，具体的层叠规则属于深入 CSS 语言的范畴，这里就补展开篇幅说了。</p> <p>不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到<code>window.getComputedStyle</code>当中，也就是可以<strong>通过 JS 来获取计算后的样式</strong>，非常方便。</p> <p>这个阶段，完成了 DOM 节点中每个元素的具体样式，计算过程中要遵循 CSS 的<code>继承</code>和<code>层叠</code>两条规则，最终输出的内容是每个节点 DOM 的样式，被保存在 ComputedStyle 中。</p> <p>想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，选择 div 标签，然后再选择“Computed”子标签</p> <h2 id="题外话-另一种说法-cssom"><a href="#题外话-另一种说法-cssom" class="header-anchor">#</a> （题外话）另一种说法 CSSOM</h2> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103255390.png" alt="image-20211112103255390"></p> <p>跟处理 HTML 一样，我们需要更具 CSS 两个规则：<u>继承</u>和<u>层叠</u>转换成某种浏览器能理解和处理的东西，处理过程类似处理 HTML，如上图 ☝</p> <p>CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103300000.png" alt="image-20211112103300000"></p> <p>很多人肯定看这个很熟悉，确实，很多博客都是基于 CSSOM 说法来讲的，我要说的是：</p> <p><strong>和 DOM 不一样，源码中并没有 CSSOM 这个词，所以很多文章说的 CSSOM 应该就是 styleSheets</strong>，当然了这个 styleSheets 我们可以打印出来的</p> <p><strong>很多文章说法是渲染树也是 16 年前的说法，现在代码重构了，我们可以把 LayoutTree 看成是渲染树，不过它们之间还是有些区别的。</strong></p> <h2 id="生成布局树"><a href="#生成布局树" class="header-anchor">#</a> 生成布局树</h2> <p>上述过程已经完成 DOM 树（DOM 树）构建，以及样式计算（DOM 样式），接下来就是要通过浏览器的<u>布局系统</u>确定<strong>元素位置</strong>，也就是生成一颗布局树（Layout Tree）,之前说法叫 <strong>渲染树</strong>。</p> <h3 id="创建布局树"><a href="#创建布局树" class="header-anchor">#</a> 创建布局树</h3> <ol><li><p>在 DOM 树上不可见的元素，head 元素，meta 元素等，以及使用 display:none 属性的元素，最后都<u>不会出现</u>在布局树上，所以<strong>浏览器布局系统需要额外去构建一棵只包含<u>可见元素布局树</u>。</strong></p></li> <li><p>我们直接结合图来看看这个布局树构建过程：</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103309669.png" alt="image-20211112103309669"></p></li> <li><p>为了构建布局树，浏览器布局系统大体上完成了下面这些工作：</p></li></ol> <ul><li>遍历 DOM 树可见节点，并把这些节点加到布局树中</li> <li>对于不可见的节点，head,meta 标签等都会被忽略。对于 body.p.span 这个元素，它的属性包含 display:none,所以这个元素没有被包含进布局树。</li></ul> <h3 id="布局计算"><a href="#布局计算" class="header-anchor">#</a> 布局计算</h3> <p>接下来就是要计算布局树节点的坐标位置，布局的计算过程非常复杂，张开介绍的话，会显得文章过于臃肿，大多数情况下，我们只需要知道<strong>它所做的工作是什么</strong>，想知道它是如何做的话，可以看看以下两篇文章 👇</p> <blockquote><p><a href="https://www.rrfed.com/2017/02/26/chrome-layout/" target="_blank" rel="noopener noreferrer">人人 FED 团队的文章-从 Chrome 源码看浏览器如何 layout 布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://zhuanlan.zhihu.com/p/25445527?refer=dreawer" target="_blank" rel="noopener noreferrer">从 Chrome 源码看浏览器如何 layout 布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h3 id="梳理前三个阶段"><a href="#梳理前三个阶段" class="header-anchor">#</a> 梳理前三个阶段</h3> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103316625.png" alt="image-20211112103316625"></p> <h2 id="分层"><a href="#分层" class="header-anchor">#</a> 分层</h2> <ul><li>生成图层树（Layer Tree）</li> <li>拥有<u>层叠上下文</u>属性的元素会被提升为单独一层</li> <li>需要<u>裁剪（clip）</u>的地方也会创建图层</li> <li>图层绘制</li></ul> <p>首先需要知道的就是，浏览器在构建完<code>布局树</code>后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。</p> <h3 id="生成图层树"><a href="#生成图层树" class="header-anchor">#</a> <strong>生成图层树</strong></h3> <p>你最终看到的页面，就是由这些图层一起叠加构成的，它们按照一定的顺序叠加在一起，就形成了最终的页面。</p> <p><strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</strong></p> <p>我们来看看图层与布局树之间关系，如下图 👇</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103324645.png" alt="image-20211112103324645"></p> <p>通常情况下，<strong><u>并不是布局树的每个节点都包含一个图层</u>，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</strong></p> <p><strong><u>那什么情况下，渲染引擎会为特定的节点创建新图层呢？</u></strong></p> <p>有两种情况需要分别讨论，一种是<strong>显式合成</strong>，一种是<strong>隐式合成</strong>。</p> <h3 id="显式合成"><a href="#显式合成" class="header-anchor">#</a> <strong>显式合成</strong></h3> <h4 id="一、-拥有层叠上下文的节点。"><a href="#一、-拥有层叠上下文的节点。" class="header-anchor">#</a> 一、 拥有<strong>层叠上下文</strong>的节点。</h4> <p>层叠上下文也基本上是有一些特定的 CSS 属性创建的，一般有以下情况:</p> <ol><li><p>HTML<u>根元素</u>，<u>Canvas</u>，<u>Video</u>，<u>Document</u>元素本身就具有层叠上下文，</p></li> <li><p>普通元素设置<u><strong>position 不为 static</strong>并且<strong>设置了 z-index 属性</strong></u>，会产生层叠上下文。</p></li> <li><p>元素的 <u><strong>transform</strong> 值不是 none</u></p></li> <li><p>元素的 <u><strong>isolation</strong> 值是 isolate</u></p></li> <li><p>**<u>will-change</u>**指定的属性值为上面任意一个。(will-change 的作用后面会详细介绍)</p></li> <li><p>隐藏背面（<strong><u>backface-visibility: hidden</u></strong>）</p></li> <li><p>倒影（<u>box-reflect</u>）</p></li> <li><p><u>column-count（不为 auto）</u>或者<u>column-widthZ（不为 auto）</u></p></li> <li><p>透明的<u>（opacity 小于 1）</u>、滤镜（<u>filter</u>）、遮罩（<u>mask</u>）、混合模式（<u>mix-blend-mode 不为 normal</u>）</p></li> <li><p>对不透明度（opacity）、变换（transform）、滤镜（filter）<u>应用动画</u></p></li> <li><p><u>OverflowClipLayer</u></p></li> <li><p>剪切溢出内容（<u>overflow: hidden</u>）</p></li> <li><p>剪切路径（<u>clip-path</u>）</p></li></ol> <h4 id="二、需要剪裁-clip-的地方。"><a href="#二、需要剪裁-clip-的地方。" class="header-anchor">#</a> 二、需要<strong>剪裁</strong>(clip)的地方。</h4> <p>比如一个标签很小，50*50 像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层，如下图</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103337940.png" alt="image-20211112103337940"></p> <p>数字 1 箭头指向的地方，可以看看，可能效果不是很明显，大家可以自己打开这个 Layers 探索下。</p> <p><strong>元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</strong></p> <h3 id="隐式合成"><a href="#隐式合成" class="header-anchor">#</a> <strong>隐式合成</strong></h3> <p>这是一种什么样的情况呢，通俗意义上来说，就是<code>z-index</code>比较低的节点会提升为一个单独的途图层，那么<u>层叠等级比它高</u>的节点**<u>都会</u>**成为一个独立的图层。</p> <blockquote><p><a href="https://segmentfault.com/a/1190000014520786" target="_blank" rel="noopener noreferrer">浏览器渲染流程&amp;Composite（渲染层合并）简单总结<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p><strong>缺点：</strong> 根据上面的文章来说，在一个大型的项目中，一个<code>z-index</code>比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是<u>层爆炸</u></p> <h2 id="绘制"><a href="#绘制" class="header-anchor">#</a> 绘制</h2> <p>完成了图层的构建，接下来要做的工作就是图层的绘制了。图层的绘制跟我们日常的绘制一样，每次都会把一个复杂的图层拆分为很小的**<u>绘制指令</u><strong>，然后再按照这些指令的顺序组成一个</strong><u>绘制列表</u>**，类似于下图 👇</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103343436.png" alt="image-20211112103343436"></p> <p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。</p> <p>大家可以在 Chrome 开发者工具中在设置栏中展开 <code>more tools</code>, 然后选择<code>Layers</code>面板，就能看到下面的绘制列表:</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103405779.png" alt="image-20211112103405779"></p> <p>在该图中，**箭头 2 指向的区域 **就是 document 的绘制列表，**箭头 3 指向的拖动区域 **中的进度条可以重现列表的绘制过程。</p> <p>当然了，绘制图层的操作在渲染进程中有着专门的线程，这个线程叫做<u>合成线程</u>。</p> <h2 id="分块"><a href="#分块" class="header-anchor">#</a> 分块</h2> <ul><li>接下来我们就要开始绘制操作了，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫<strong>合成线程</strong>。</li> <li>绘制列表准备好了之后，渲染进程的主线程会给<u>合成线程</u>发送<code>commit</code>消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。</li></ul> <blockquote><p>你想呀，有时候，你的图层很大，或者说你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这个时候需要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p></blockquote> <ul><li>基于上面的原因，合成线程会讲图层划分为<u>图块(tile)</u></li> <li>这些块的大小一般不会特别大，通常是 256 _ 256 或者 512 _ 512 这个规格。这样可以大大<u>加速页面的首屏展示</u>。</li></ul> <p>首屏渲染加速可以这么理解：</p> <blockquote><p>因为后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个**<u>低分辨率</u>**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容<u>替换</u>。这也是 Chrome 底层<u>优化首屏加载速度</u>的一个手段。</p></blockquote> <h2 id="光栅化"><a href="#光栅化" class="header-anchor">#</a> 光栅化</h2> <p>接着上面的步骤，有了图块之后，<strong>合成线程会按照<u>视口附近的图块</u>来<u>优先生成位图</u>，实际生成位图的操作是由<u>栅格化</u>来执行的。所谓栅格化，是指将<u>图块转换为位图</u>。</strong></p> <ul><li><u>图块</u>是栅格化执行的最小单位</li> <li>渲染进程中专门维护了一个**<u>栅格化线程池</u><strong>，专门负责把</strong><u>图块<strong>转换为</strong>位图数据</u>**</li> <li>合成线程会<u>选择视口附近的<strong>图块(tile)</strong></u>，把它交给<strong>栅格化线程池</strong><u>生成位图</u></li> <li>生成位图的过程实际上都会使用 <u>GPU</u> 进行加速，生成的位图最后<u>发送给合成线程</u></li></ul> <p>运行方式如下 👇</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103414603.png" alt="image-20211112103414603"></p> <p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫**<u>快速栅格化</u>**，或者 GPU 栅格化，生成的位图被<u>保存在 GPU 内存</u>中。</p> <p>相信你还记得，GPU 操作是运行在 <u>GPU 进程</u>中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103420641.png" alt="image-20211112103420641"></p> <p>从图中可以看出，渲染进程把<u>生成位图的指令</u>发送给 GPU，然后在 GPU 中<u>执行指令</u>，生成图块的位图，并<u>保存在 GPU 的内存</u>中。</p> <h2 id="合成和显示"><a href="#合成和显示" class="header-anchor">#</a> 合成和显示</h2> <p>栅格化操作完成后，<strong>合成线程</strong>会生成一个<u>绘制命令</u>，即&quot;<u>DrawQuad</u>&quot;，并发送给浏览器进程。</p> <p>浏览器进程中的<u><code>viz组件</code></u>接收到这个命令，根据这个命令，<u>把页面内容绘制到内存</u>，也就是生成了页面，然后把这部分内存<u>发送给显卡</u>,那你肯定对显卡的原理很好奇。</p> <p>看了某博主对显示器显示图像的原理解释:</p> <blockquote><p>无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的<strong>前缓冲区</strong>。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到<strong>后缓冲区</strong>，然后系统自动将<code>前缓冲区</code>和<code>后缓冲区</code>对换位置，如此循环更新。</p></blockquote> <p>这个时候，心中就有点概念了，比如某个动画大量占用内存时，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的<u>掉帧现象</u>。</p> <hr> <p>用一张图来总结 👇</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103429579.png" alt="image-20211112103429579"></p> <p>我们把上面整个的渲染流水线，用一张图片更直观的表示 👇</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103434423.png" alt="image-20211112103434423"></p> <h2 id="回流-重绘-合成"><a href="#回流-重绘-合成" class="header-anchor">#</a> 回流-重绘-合成</h2> <p>更新视图三种方式</p> <ul><li><u>回流</u></li> <li><u>重绘</u></li> <li><u>合成</u></li></ul> <h3 id="重排-回流-布局"><a href="#重排-回流-布局" class="header-anchor">#</a> 重排（回流/布局）</h3> <p><code>Render Object</code> 在添加到树之后，还需要重新计算位置和大小；<code>ComputedStyle</code> 里面已经包含了这些信息，<u><strong>为什么还需要重新计算呢？</strong></u>因为像 <code>margin: 0 auto;</code> 这样的声明是不能直接使用的，需要转化成实际的大小，才能通过**<u>绘图引擎</u>**绘制节点；这也是 <code>DOM Tree</code> 和 <code>CSSOM Tree</code> 需要组合成 <code>Render Object Tree</code> 的原因之一。</p> <p>布局是从 <code>Root Render Object</code> 开始<u>递归</u>的，每一个 <code>Render Object</code> 都有对自身进行布局的方法。</p> <p><u><strong>为什么需要递归</strong></u>（也就是先计算子节点再回头计算父节点）计算位置和大小呢？</p> <p>因为有些布局信息需要<u>子节点先计算</u>，之后才能通过子节点的布局信息<u>计算出父节点</u>的位置和大小；</p> <p>例如父节点的高度需要子节点撑起。如果子节点的宽度是父节点高度的 50%，要怎么办呢？这就需要在计算子节点之前，先计算自身的布局信息，再传递给子节点，子节点根据这些信息计算好之后就会告诉父节点是否需要重新计算。</p> <p>重排触发的条件就是:<strong>对 DOM 结构的修改引发 DOM <u>几何尺寸变化</u>的时候</strong>,会发生<u>回流</u>过程。</p> <p>具体一点，有以下的操作会触发回流:</p> <ol><li>一个 DOM 元素的<u>几何属性变化</u>，常见的几何属性有<code>width</code>、<code>height</code>、<code>padding</code>、<code>margin</code>、<code>left</code>、<code>top</code>、<code>border</code> 等等, 这个很好理解。</li> <li>使 DOM 节点发生<u>增减</u>或者<u>移动</u>。</li> <li>读写 <code>offset</code>族、<code>scroll</code>族和<code>client</code>族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li> <li>调用 <code>window.getComputedStyle</code> 方法。</li></ol> <p>一些常用且会导致回流的属性和方法：</p> <ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li> <li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li> <li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li> <li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li> <li><code>getComputedStyle()</code></li> <li><code>getBoundingClientRect()</code></li> <li><code>scrollTo()</code></li></ul> <p>依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103440561.png" alt="image-20211112103440561"></p> <h3 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h3> <p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <p>根据概念，我们知道由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下：</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20211112103444788.png" alt="image-20211112103444788"></p> <p>跳过了**<u>布局树</u>**和<u><strong>建图层树</strong></u>,直接去绘制列表，然后在去分块,生成位图等一系列操作。</p> <p>可以看到，<u>重绘不一定导致回流，但回流一定发生了重绘</u>。</p> <h3 id="flush-队列"><a href="#flush-队列" class="header-anchor">#</a> flush 队列</h3> <p>部分浏览器缓存了一个<u>flush 队列</u>，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来，或者达到了一定的时间间隔，或者“不得已”的时候，再将这些任务一口气出队列，但是当我们访问一些及时属性时，浏览器会为了获得此时此刻、最准确的属性值，而<u>提前</u>将 flush 队列的任务出队列</p> <h3 id="合成"><a href="#合成" class="header-anchor">#</a> 合成</h3> <p>还有一种情况：就是<strong>更改了一个既不要布局也不要绘制</strong>的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的<strong>合成</strong>操作，这个过程就叫<strong>合成</strong>。</p> <p>举个例子：比如使用<code>CSS</code>的<code>transform</code>来实现动画效果，<strong>避免了回流跟重绘</strong>，<u>直接在非主线程中执行合成动画操作</u>。显然这样子的效率更高，毕竟这个是在非主线程上合成的，<u>没有占用主线程资源</u>，另外也避开了布局和绘制两个子阶段，所以<strong>相对于重绘和重排，合成能大大提升绘制效率。</strong></p> <p>利用这一点好处：</p> <ul><li>合成层的位图，会交由 <u><code>GPU</code>（显卡）</u> 合成，比 <code>CPU</code> 处理要快</li> <li>当需要 <code>repaint</code> 时，只需要 <code>repaint</code> 本身，不会影响到其他的层</li> <li>对于 <code>transform</code> 和 <code>opacity</code> 效果，不会触发 <code>layout</code> 和 <code>paint</code></li></ul> <p><u>提升合成层的最好方式是使用 <code>CSS</code> 的 <code>will-change</code> 属性</u></p> <h3 id="gpu-加速原因"><a href="#gpu-加速原因" class="header-anchor">#</a> GPU 加速原因</h3> <p>比如利用 CSS3 的<code>transform</code>、<code>opacity</code>、<code>filter</code>这些属性就可以实现合成的效果，也就是大家常说的**<u>GPU 加速</u>**。</p> <ul><li>在合成的情况下，直接跳过布局和绘制流程，进入非主线程处理部分，即<u>直接交给合成线程处理</u>。</li> <li>充分发挥<code>GPU</code>优势，合成线程生成位图的过程中会<u>调用线程池</u>，并在其中使用<code>GPU</code>进行加速生成，而<u><code>GPU</code> 是擅长处理位图数据</u>的。</li> <li>没有占用主线程的资源，即使主线程卡住了，效果依然流畅展示。</li></ul> <h2 id="实践意义"><a href="#实践意义" class="header-anchor">#</a> 实践意义</h2> <ul><li>使用<code>createDocumentFragment</code>进行批量的 DOM 操作</li> <li>对于 <code>resize</code>、<code>scroll</code> 等进行防抖/节流处理。</li> <li>动画使用<code>transform</code>或者<code>opacity</code>实现</li> <li>将元素的<code>will-change</code> 设置为 <code>opacity、transform、top、left、bottom、right</code> 。这样子渲染引擎会为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。</li> <li>对于不支持<code>will-change</code> 属性的浏览器，使用一个<u><code>3D transform</code>属性来强制提升</u>为合成 <code>transform: translateZ(0);</code></li> <li><code>requestAnimationFrame</code>优化等等</li></ul> <h2 id="面试知识点"><a href="#面试知识点" class="header-anchor">#</a> 面试知识点</h2> <h3 id="load-和-domcontentloaded-区别"><a href="#load-和-domcontentloaded-区别" class="header-anchor">#</a> Load 和 <code>DOMContentLoaded</code> 区别</h3> <p>Load 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</p> <p><code>DOMContentLoaded</code> 事件触发代表<u>初始的 HTML 被完全加载和解析</u>，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载。</p> <h3 id="图层-layer"><a href="#图层-layer" class="header-anchor">#</a> 图层（Layer）</h3> <p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。<strong>不同的图层渲染互不影响</strong>，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。<strong>但也不能生成过多的图层，会引起反作用（层爆炸）。</strong></p> <p>通过以下几个常用属性可以生成新图层</p> <ul><li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li> <li><code>will-change</code></li> <li><code>video</code>、<code>iframe</code> 标签</li> <li>通过动画实现的 <code>opacity</code> 动画转换</li> <li><code>position: fixed</code></li></ul> <h3 id="重绘-repaint-和回流-reflow"><a href="#重绘-repaint-和回流-reflow" class="header-anchor">#</a> 重绘（Repaint）和回流（Reflow）</h3> <p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p> <ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li> <li>回流是布局或者几何属性需要改变就称为回流。</li></ul> <p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</p> <p>所以以下几个动作可能会导致性能问题：</p> <ul><li>改变 window 大小</li> <li>改变字体</li> <li>添加或删除样式</li> <li>文字改变</li> <li>定位或者浮动</li> <li>盒模型</li></ul> <p>很多人不知道的是，重绘和回流其实和 <code>Event loop</code> 有关。</p> <ol><li>当 <code>Event loop</code> 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li> <li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li> <li>判断是否触发了 <code>media query</code></li> <li>更新动画并且发送事件</li> <li>判断是否有全屏操作事件</li> <li>执行 <code>requestAnimationFrame</code> 回调</li> <li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li> <li>更新界面</li> <li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</li></ol> <p>以上内容来自于 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener noreferrer">HTML 文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="减少重绘和回流"><a href="#减少重绘和回流" class="header-anchor">#</a> 减少重绘和回流</h3> <ul><li><p>使用 <code>translate</code> 替代 <code>top</code></p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
  <span class="token selector">.test</span> <span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 引起回流</span>
    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">'100px'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div></li> <li><p>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p></li> <li><p>把 DOM <u>离线</u>后修改，比如：先把 DOM 给 <code>display:none</code> (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</p></li> <li><p>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p></li> <li><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></p></li> <li><p><code>CSS</code> 选择符从右往左匹配查找，<u>避免 <code>DOM</code> 深度过深</u></p></li> <li><p>将<u>频繁运行的动画变为图层</u>，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code> 标签，浏览器会自动将该节点变为图层。</p></li></ul> <h3 id="行内样式和-cssstylesheet-的区别"><a href="#行内样式和-cssstylesheet-的区别" class="header-anchor">#</a> 行内样式和 <code>CSSStyleSheet</code> 的区别</h3> <p>每个 <u><code>link</code>引入的<code>CSS</code> 文件</u>或<u>嵌入样式（style 标签）</u>都会<u>对应</u>一个 <code>CSS StyleSheet</code> 对象</p> <p>这个对象由一系列的 <code>Rule</code>（规则） 组成；每一条 <code>Rule</code> 都会包含 <code>Selectors</code>（选择器） 和若干 <code>Declearation</code>（声明），<code>Declearation</code> 又由 <code>Property</code>（属性）和 <code>Value</code>（值）组成。</p> <p>另外，浏览器默认样式表（<code>defaultStyleSheet</code>）和用户样式表（<code>UserStyleSheet</code>）也会有对应的 <code>CSSStyleSheet</code> 对象，因为它们都是单独的 <code>CSS</code> 文件。</p> <p>至于行内样式，在构建 <code>DOM Tree</code> 的时候会直接解析成 <code>Declearation</code> 集合<u>挂载到元素的 style 属性</u>上。</p> <p>所有的 <code>CSS StyleSheet</code> 都挂载在 <code>document</code> 节点上，我们可以在浏览器中通过 <code>document.styleSheets</code> 获取到这个集合。行内样式可以直接通过节点的 style 属性查看。</p> <p>通过一个例子，来了解下行内样式和 <code>CSSStyleSheet</code> 的区别：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code>--------demo.html---------
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>X-UA-Compatible<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ie=edge<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
      <span class="token selector">body .div1</span> <span class="token punctuation">{</span>
        <span class="token property">line-height</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./style.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
      <span class="token selector">.div1</span> <span class="token punctuation">{</span>
        <span class="token property">background-color</span><span class="token punctuation">:</span> #f0f<span class="token punctuation">;</span>
        <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>div1<span class="token punctuation">&quot;</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 12px<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><div class="language-css line-numbers-mode"><pre class="language-css"><code>----------style.css--------
<span class="token atrule"><span class="token rule">@import</span> <span class="token string">&quot;./index.css&quot;</span><span class="token punctuation">;</span></span>
<span class="token selector">.div1</span><span class="token punctuation">{</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> #fff<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">----------index.css---------- .div1</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 80px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到一共有三个 <code>CSSStyleSheet</code> 对象，每个 <code>CSSStyleSheet</code> 对象的 rules 里面会有一个 style 属性，style 属性的值就是 <code>CSSStyleDeclaration</code>，而行内样式获取到的直接就是 <code>CSSStyleDeclaration</code>。</p> <p>（在一个<code>css</code>文件中通过<code>@import</code>引入另一个<code>css</code>文件，会合并成一个<code>CSS StyleSheet</code>）</p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20201210174928221.png" alt="image-20201210174928221"></p> <p><img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20201210174949382.png" alt="image-20201210174949382"></p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <blockquote><p><a href="https://juejin.cn/post/6847902222349500430#heading-6" target="_blank" rel="noopener noreferrer">「浏览器工作原理」写给女友的秘籍-渲染流程篇（1.1W 字）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;mid=2650083493&amp;idx=1&amp;sn=faaf6ea4986e9db9718fdd5fb4bbcc9a&amp;chksm=83db8dc0b4ac04d64983a93fe147760814bc501dfa4a3d39ab2f43c1b9485c56e6a60406b6d6&amp;xtrack=1&amp;scene=90&amp;subscene=93&amp;sessionid=1605411572&amp;clicktime=1605411573&amp;enterid=1605411573&amp;ascene=56&amp;devicetype=android-29&amp;version=27001355&amp;nettype=3gnet&amp;abtest_cookie=AAACAA%3D%3D&amp;lang=zh_CN&amp;exportkey=A%2F2sFBScjPwWf%2BVWMYP8FK4%3D&amp;pass_ticket=56cQsWIuoMCp5DKYb%2FWTUmR8R1V7dtPqUU0wV5Q0jZR%2FRhak3xGBQSVBB%2B%2B5KMO5&amp;wx_header=1" target="_blank" rel="noopener noreferrer">网页渲染性能优化 —— 渲染原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">4 小时前</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-press/technology/computer-network/图解HTTP状态码.html" class="prev">
        HTTP状态码
      </a></span> <span class="next"><a href="/blog-press/technology/computer-network/浏览器缓存.html">
        浏览器缓存
      </a>
      →
    </span></p></div>  <!----></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog-press/assets/js/app.6139d12d.js" defer></script><script src="/blog-press/assets/js/8.ae6c3984.js" defer></script><script src="/blog-press/assets/js/2.0264d6f2.js" defer></script><script src="/blog-press/assets/js/34.3d45314e.js" defer></script><script src="/blog-press/assets/js/3.d809f9f2.js" defer></script>
  </body>
</html>
