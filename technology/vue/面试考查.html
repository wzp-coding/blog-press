<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点 | 吴泽鹏</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog-press/logo.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/blog-press/assets/css/0.styles.1c926e40.css" as="style"><link rel="preload" href="/blog-press/assets/js/app.6139d12d.js" as="script"><link rel="preload" href="/blog-press/assets/js/8.ae6c3984.js" as="script"><link rel="preload" href="/blog-press/assets/js/2.0264d6f2.js" as="script"><link rel="preload" href="/blog-press/assets/js/76.f5e7d6d7.js" as="script"><link rel="preload" href="/blog-press/assets/js/3.d809f9f2.js" as="script"><link rel="prefetch" href="/blog-press/assets/js/10.d7e47f38.js"><link rel="prefetch" href="/blog-press/assets/js/11.dec774c1.js"><link rel="prefetch" href="/blog-press/assets/js/12.bf4e5bd9.js"><link rel="prefetch" href="/blog-press/assets/js/13.b8d07eb6.js"><link rel="prefetch" href="/blog-press/assets/js/14.c00caa94.js"><link rel="prefetch" href="/blog-press/assets/js/15.9a666249.js"><link rel="prefetch" href="/blog-press/assets/js/16.bd6a696c.js"><link rel="prefetch" href="/blog-press/assets/js/17.3cd69cd0.js"><link rel="prefetch" href="/blog-press/assets/js/18.517287fb.js"><link rel="prefetch" href="/blog-press/assets/js/19.91ac48bf.js"><link rel="prefetch" href="/blog-press/assets/js/20.e32f2fcd.js"><link rel="prefetch" href="/blog-press/assets/js/21.0da0a074.js"><link rel="prefetch" href="/blog-press/assets/js/22.1bd30e45.js"><link rel="prefetch" href="/blog-press/assets/js/23.48cb1fe1.js"><link rel="prefetch" href="/blog-press/assets/js/24.2f91fffc.js"><link rel="prefetch" href="/blog-press/assets/js/25.dde1cf53.js"><link rel="prefetch" href="/blog-press/assets/js/26.b4efff9b.js"><link rel="prefetch" href="/blog-press/assets/js/27.37b9aeae.js"><link rel="prefetch" href="/blog-press/assets/js/28.5b257151.js"><link rel="prefetch" href="/blog-press/assets/js/29.0234654e.js"><link rel="prefetch" href="/blog-press/assets/js/30.138d64b3.js"><link rel="prefetch" href="/blog-press/assets/js/31.5083ded0.js"><link rel="prefetch" href="/blog-press/assets/js/32.e9b32179.js"><link rel="prefetch" href="/blog-press/assets/js/33.009994b5.js"><link rel="prefetch" href="/blog-press/assets/js/34.3d45314e.js"><link rel="prefetch" href="/blog-press/assets/js/35.0bb4365b.js"><link rel="prefetch" href="/blog-press/assets/js/36.7bc05dac.js"><link rel="prefetch" href="/blog-press/assets/js/37.c0c6a5c8.js"><link rel="prefetch" href="/blog-press/assets/js/38.f4da4354.js"><link rel="prefetch" href="/blog-press/assets/js/39.5649b375.js"><link rel="prefetch" href="/blog-press/assets/js/4.9e4232dd.js"><link rel="prefetch" href="/blog-press/assets/js/40.2894689c.js"><link rel="prefetch" href="/blog-press/assets/js/41.11221830.js"><link rel="prefetch" href="/blog-press/assets/js/42.d2488d65.js"><link rel="prefetch" href="/blog-press/assets/js/43.66d734aa.js"><link rel="prefetch" href="/blog-press/assets/js/44.1ffab8f9.js"><link rel="prefetch" href="/blog-press/assets/js/45.00e58203.js"><link rel="prefetch" href="/blog-press/assets/js/46.fa6aee68.js"><link rel="prefetch" href="/blog-press/assets/js/47.b5f65afa.js"><link rel="prefetch" href="/blog-press/assets/js/48.61e98198.js"><link rel="prefetch" href="/blog-press/assets/js/49.6207cdd1.js"><link rel="prefetch" href="/blog-press/assets/js/5.007799f8.js"><link rel="prefetch" href="/blog-press/assets/js/50.7dc3280a.js"><link rel="prefetch" href="/blog-press/assets/js/51.825a4e12.js"><link rel="prefetch" href="/blog-press/assets/js/52.ca846de1.js"><link rel="prefetch" href="/blog-press/assets/js/53.3e4e9df9.js"><link rel="prefetch" href="/blog-press/assets/js/54.fcf0bda2.js"><link rel="prefetch" href="/blog-press/assets/js/55.f149c70b.js"><link rel="prefetch" href="/blog-press/assets/js/56.de5a9567.js"><link rel="prefetch" href="/blog-press/assets/js/57.8047ad0c.js"><link rel="prefetch" href="/blog-press/assets/js/58.2eb97615.js"><link rel="prefetch" href="/blog-press/assets/js/59.5b73b1ee.js"><link rel="prefetch" href="/blog-press/assets/js/6.93b98aae.js"><link rel="prefetch" href="/blog-press/assets/js/60.ff4d1ea3.js"><link rel="prefetch" href="/blog-press/assets/js/61.251fdbfd.js"><link rel="prefetch" href="/blog-press/assets/js/62.5e3e7061.js"><link rel="prefetch" href="/blog-press/assets/js/63.7a89825d.js"><link rel="prefetch" href="/blog-press/assets/js/64.7180cc32.js"><link rel="prefetch" href="/blog-press/assets/js/65.009bf214.js"><link rel="prefetch" href="/blog-press/assets/js/66.a41afd3f.js"><link rel="prefetch" href="/blog-press/assets/js/67.6cb1357c.js"><link rel="prefetch" href="/blog-press/assets/js/68.9ddd8ab2.js"><link rel="prefetch" href="/blog-press/assets/js/69.e0768e8d.js"><link rel="prefetch" href="/blog-press/assets/js/7.d02898a9.js"><link rel="prefetch" href="/blog-press/assets/js/70.9d69f736.js"><link rel="prefetch" href="/blog-press/assets/js/71.188f6682.js"><link rel="prefetch" href="/blog-press/assets/js/72.5844fa81.js"><link rel="prefetch" href="/blog-press/assets/js/73.c2a47b6c.js"><link rel="prefetch" href="/blog-press/assets/js/74.c87c63e9.js"><link rel="prefetch" href="/blog-press/assets/js/75.7b2094f7.js"><link rel="prefetch" href="/blog-press/assets/js/77.09ed1df7.js"><link rel="prefetch" href="/blog-press/assets/js/78.c80e3d27.js"><link rel="prefetch" href="/blog-press/assets/js/79.039de0ce.js"><link rel="prefetch" href="/blog-press/assets/js/9.7810b5e0.js">
    <link rel="stylesheet" href="/blog-press/assets/css/0.styles.1c926e40.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog-press/" class="home-link router-link-active"><img src="/blog-press/logo.png" alt="吴泽鹏" class="logo"> <span class="site-name can-hide">吴泽鹏</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-press/technology/html-css/" class="nav-link">
  HtmlCss
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/cli-tools/" class="nav-link">
  构建工具
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/vue/" class="nav-link router-link-active">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/data-base/" class="nav-link">
  Database
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/computer-network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/extension/" class="nav-link">
  拓展知识
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/bug/" class="nav-link">
  踩坑日记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wzp-coding/blog-press" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/1521379825951864" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-press/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><span class="title">技术</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术" class="mobile-dropdown-title"><span class="title">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog-press/technology/html-css/" class="nav-link">
  HtmlCss
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/cli-tools/" class="nav-link">
  构建工具
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/vue/" class="nav-link router-link-active">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/data-base/" class="nav-link">
  Database
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/computer-network/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/extension/" class="nav-link">
  拓展知识
</a></li><li class="dropdown-item"><!----> <a href="/blog-press/technology/bug/" class="nav-link">
  踩坑日记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wzp-coding/blog-press" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://juejin.cn/user/1521379825951864" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog-press/technology/vue/" aria-current="page" class="sidebar-link">VUE发展史</a></li><li><a href="/blog-press/technology/vue/vue2.x源码.html" class="sidebar-link">vue2.x源码</a></li><li><a href="/blog-press/technology/vue/vue3.x源码.html" class="sidebar-link">vue3.x源码</a></li><li><a href="/blog-press/technology/vue/开课吧架构笔记.html" class="sidebar-link">学习笔记</a></li><li><a href="/blog-press/technology/vue/面试考查.html" class="active sidebar-link">知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vite-基本原理" class="sidebar-link">vite 基本原理</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#依赖预编译" class="sidebar-link">依赖预编译</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vue3-如何减少源码体积" class="sidebar-link">vue3 如何减少源码体积？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#tree-shaking" class="sidebar-link">Tree shaking？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#tree-shaking-的原理" class="sidebar-link">Tree shaking 的原理</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#tree-shaking-与-按需引入的区别" class="sidebar-link">Tree shaking 与 按需引入的区别？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vue3-使用-proxy-代替-object-defineproperty-的好处" class="sidebar-link">vue3 使用 Proxy 代替 Object.defineProperty 的好处</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vue3-的编译优化" class="sidebar-link">vue3 的编译优化</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#组合式-api-composition-api-好处" class="sidebar-link">组合式 API（Composition API）好处</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vnode-到真实-dom-是如何转变的" class="sidebar-link">vnode 到真实 DOM 是如何转变的</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#完整的-dom-diff-流程是怎样的" class="sidebar-link">完整的 DOM diff 流程是怎样的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#diff-算法流程" class="sidebar-link">diff 算法流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#setup-组件渲染前的初始化流程是怎样的" class="sidebar-link">setup 组件渲染前的初始化流程是怎样的</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#为什么需要创建渲染上下文代理" class="sidebar-link">为什么需要创建渲染上下文代理</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#研究-publicinstanceproxyhandlers" class="sidebar-link">研究 PublicInstanceProxyHandlers</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#渲染上下文中的访问优先级" class="sidebar-link">渲染上下文中的访问优先级</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vnode-有什么优势呢-为什么一定要设计-vnode-这样的数据结构呢" class="sidebar-link">vnode 有什么优势呢？为什么一定要设计 vnode 这样的数据结构呢？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#平时开发页面就是把页面拆成一个个组件-那么组件的拆分粒度是越细越好吗-为什么呢" class="sidebar-link">平时开发页面就是把页面拆成一个个组件，那么组件的拆分粒度是越细越好吗？为什么呢？</a></li><li class="sidebar-sub-header"><a href="/blog-press/technology/vue/面试考查.html#vue-devtools-打开-editor-原理" class="sidebar-link">vue-devtools 打开 editor 原理</a></li></ul></li><li><a href="/blog-press/technology/vue/项目难点.html" class="sidebar-link">项目难点</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vite-基本原理"><a href="#vite-基本原理" class="header-anchor">#</a> vite 基本原理</h2> <div class="language-html line-numbers-mode"><pre class="language-html"><code>// index.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
  <span class="token keyword">import</span> Main <span class="token keyword">from</span> <span class="token string">'./Main.vue'</span>

  <span class="token function">createApp</span><span class="token punctuation">(</span>Main<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Vite 会在本地帮你启动一个服务器，当浏览器读取到这个 html 文件之后，会在执行到 import 的时候才去向服务端发送 <code>Main.vue</code> 模块的请求，Vite 此时在利用内部的一系列黑魔法，包括 Vue 的 template 解析，代码的编译等等，解析成浏览器可以执行的 js 文件返回到浏览器端。</p> <p>这就保证了只有在真正使用到这个模块的时候，浏览器才会请求并且解析这个模块，最大程度的做到了按需加载。</p> <h2 id="依赖预编译"><a href="#依赖预编译" class="header-anchor">#</a> 依赖预编译</h2> <p>依赖预编译，其实是 Vite 2.0 在为用户启动开发服务器之前，先用 <code>esbuild</code> 把检测到的依赖预先构建了一遍。</p> <blockquote><p>当你用 <code>import { debounce } from 'lodash'</code> 导入一个命名函数的时候，可能你理想中的场景就是浏览器去下载只包含这个函数的文件。但其实没那么理想，<code>debounce</code> 函数的模块内部又依赖了很多其他函数，形成了一个依赖图。</p> <p>当浏览器请求 <code>debounce</code> 的模块时，又会发现内部有 2 个 <code>import</code>，再这样延伸下去，这个函数内部竟然带来了 600 次请求，耗时会在 1s 左右。</p> <p>这当然是不可接受的，于是尤老师想了个折中的办法，正好利用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fevanw%2Fesbuild" target="_blank" rel="noopener noreferrer">Esbuild<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 接近无敌的构建速度，让你在没有感知的情况下在启动的时候预先帮你把 <code>debounce</code> 所用到的所有内部模块全部打包成一个传统的 <code>js bundle</code>。</p> <p><code>Esbuild</code> 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p></blockquote> <p>大致过程：在 <code>httpServer.listen</code> 启动开发服务器之前，会进行依赖预构建步骤，根据本次运行的入口文件来扫描其中的依赖，之后再根据分析出来的依赖，使用 ESbuild 把它们打包成单文件的 bunble，之后在浏览器请求相关模块时，返回这个预构建好的模块</p> <p>在预构建这个步骤中，还会对 <code>CommonJS</code> 模块进行分析，方便后面需要统一处理成浏览器可以执行的 <code>ES Module</code>。</p> <blockquote><p>Vite Server 启动阶段，在 server.listen 的回调中执行 runOptimize 逻辑，进入预构建阶段。</p> <p><code>runOptimize</code> 中调用 <code>optimizeDeps</code>，内部调用 esbuild 进行构建， 并往 esbuild 里面传入自定义的 scan 插件，esbuild 构建过程中进行依赖分析，并将依赖项赋给 deps</p> <p>拿到 deps 后打印出上述的终端 log，第一次预构建结束。</p> <p>函数调用流程如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>startServer <span class="token operator">-</span><span class="token operator">&gt;</span> runOptimize <span class="token operator">-</span><span class="token operator">&gt;</span> optimizeDeps <span class="token operator">-</span><span class="token operator">&gt;</span> scanImports <span class="token operator">-</span><span class="token operator">&gt;</span> esbuild<span class="token punctuation">.</span>build
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <blockquote><p>Vite 预构建并不只有在服务启动的时候进行，在请求进入的时候也有可能触发预构建，也就是说，<strong>预构建的行为不只是在最开始触发一次，在浏览器访问项目的时候有可能再次触发，甚至是多次触发</strong>。</p> <p>简单来说，当浏览器发起请求时，请求进入 Vite 服务器中，首先是执行一系列的插件，其中就会在比较靠前的位置走到 <code>resolvePlugin</code>，这个插件中分析项目中的依赖关系，如果发现了有依赖没有被预构建，那么会执行 <code>_registerMissingImport</code> 将这个依赖进行预构建，并重启 Vite Server。</p> <p><code>_registerMissingImport</code> 调用之后会进行二次预构建，但不是立即执行，相当于每隔 100 ms <strong>批量收集一次</strong>然后一起构建，实际上有一个节流的过程，这样一来不用对每个依赖都调用 <code>optimizeDeps</code> ，也能提高预构建的效率，属于 Vite 里面细节性的优化，和 <code>Vue</code> 里面的<code>nextTick</code> 批量更新有异曲同工之妙。</p> <p>当通过动态 import 的依赖多了之后，会非常影响构建性能，这种场景下可以用 <code>vite-plugin-optimize-persist</code> 这个插件进行自动优化</p></blockquote> <h2 id="vue3-如何减少源码体积"><a href="#vue3-如何减少源码体积" class="header-anchor">#</a> vue3 如何减少源码体积？</h2> <p>首先，移除一些冷门的 feature（比如 filter、inline-template 等）；</p> <p>其次，引入 tree-shaking 的技术，减少打包体积。</p> <h2 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> Tree shaking？</h2> <p>Treeshaking 是一个术语，通常用于描述移除<a href="https://so.csdn.net/so/search?q=JavaScript&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>上下文中的未引用代码(dead-code)，就像一棵大树，将那些无用的叶子都摇掉。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。</p> <h2 id="tree-shaking-的原理"><a href="#tree-shaking-的原理" class="header-anchor">#</a> Tree shaking 的原理</h2> <p>tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过<strong>编译阶段</strong>的静态分析，找到没有引入的模块并<strong>打上标记</strong>。</p> <p>举个例子，一个 math 模块定义了 2 个方法 square(x) 和 cube(x) ：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> x
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">cube</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们在这个模块外面只引入了 cube 方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> cube <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./math.js'</span>
<span class="token comment">// do something with cube</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>最终 math 模块会被 webpack 打包生成如下代码：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/* 1 */</span>
<span class="token comment">/***/</span> <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> __webpack_exports__<span class="token punctuation">,</span> __webpack_require__</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">'use strict'</span>
  <span class="token comment">/* unused harmony export square */</span>
  <span class="token comment">/* harmony export (immutable) */</span> __webpack_exports__<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> cube
  <span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">cube</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>可以看到，未被引入的 square 模块被标记了， 然后<strong>压缩阶段</strong>会利用例如 uglify-js、terser 等压缩工具真正地<strong>删除这些没有用到的代码</strong>。</p> <p>也就是说，利用 tree-shaking 技术，如果你在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就不会打包，这样也就间接达到了减少项目引入的 Vue.js 包体积的目的。</p> <h2 id="tree-shaking-与-按需引入的区别"><a href="#tree-shaking-与-按需引入的区别" class="header-anchor">#</a> Tree shaking 与 按需引入的区别？</h2> <p>按需引入是在 babel 编译过程中，其本质是在 babel 编译阶段将部分代码做了替换</p> <p>Tree shaking 是在 webpack 打包阶段，移除 JavaScript 上下文中的未引用代码</p> <h2 id="vue3-使用-proxy-代替-object-defineproperty-的好处"><a href="#vue3-使用-proxy-代替-object-defineproperty-的好处" class="header-anchor">#</a> vue3 使用 Proxy 代替 Object.defineProperty 的好处</h2> <p>vue2 中 Object.defineProperty 的缺陷:</p> <ol><li>无法原生监听数组的变化，需要特殊处理</li> <li>必须遍历对象的每个属性（当示例初始化的时，Object.definePropety 是从 data 的根节点遍历到末节点。一次性遍历全部)</li> <li>无法监听属性的新增删除操作（vue 提供 Vue.set Vue.delete API，原因就是因为 Object.definePropety 无法监听新增删除操作）</li></ol> <p>vue3 中 proxy 的优点</p> <p>proxy 劫持的是整个对象，对于对象的属性的增加和删除都能检测到。</p> <p>但要注意的是，Proxy API 并不能监听到内部深层次的对象变化，因此 Vue.js 3.0 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归，这样无疑也在很大程度上提升了性能.</p> <p>到目前为止，各大主流移动端浏览器，PC 端浏览器，包括新一代 window 产品内置 Microsoft Edge 都满足对于 Vue3 的支持。其次，若真的需要满足支持 IE 及极少数低版本浏览器，还可以使用垫片工具（es6-proxy-polyfill）。</p> <h2 id="vue3-的编译优化"><a href="#vue3-的编译优化" class="header-anchor">#</a> vue3 的编译优化</h2> <p>我们知道通过数据劫持和依赖收集，Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树，举个例子，比如我们要更新这个组件：</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>content<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>static text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>static text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ message }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>static text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>static text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>整个 diff 过程如图所示</p> <img src="C:\Users\22362\AppData\Roaming\Typora\typora-user-images\image-20220305182133114.png" alt="image-20220305182133114" style="zoom:50%;"> <p>可以看到，因为这段代码中只有一个动态节点，所以这里有很多 diff 和遍历其实都是不需要的，这就会导致 <strong>vnode 的性能跟模版大小正相关</strong>，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。</p> <p>而对于上述例子，理想状态只需要 diff 这个绑定 message 动态节点的 p 标签即可。</p> <p>Vue.js 3.0 做到了，它通过<strong>编译阶段对静态模板的分析</strong>，编译生成了 <strong>Block tree</strong>。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。借助 Block tree，Vue.js 将 vnode <strong>更新性能</strong>由与模版整体大小相关提升为<strong>与动态内容的数量相关</strong>，这是一个非常大的性能突破</p> <p>除此之外，Vue.js 3.0 在编译阶段还包含了对 Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法</p> <h2 id="组合式-api-composition-api-好处"><a href="#组合式-api-composition-api-好处" class="header-anchor">#</a> 组合式 API（Composition API）好处</h2> <ul><li><p>优化逻辑组织</p> <ul><li>vue2 中 options API，逻辑关注点比较分散，代码比较多时难以阅读</li> <li>vue3 中通过 composition API，可以将每个逻辑关注点写在同一个函数中，解决了 options API 的缺陷</li></ul></li> <li><p>优化逻辑复用</p> <ul><li>vue2 中逻辑复用可以用 mixins 实现，当 mixins 比较多时，容易造成命名冲突和数据来源不清晰</li> <li>vue3 可以将复用的逻辑封装成一个 hook 函数，需要使用就引入，这样命名不会冲突而且数据来源也很清晰</li></ul></li> <li><p>更好的类型支持</p> <ul><li>因为它们都是一些函数，在调用函数时，自然所有的类型就被推导出来了，不像 Options API 所有的东西使用 this</li></ul></li> <li><p>对 tree-shaking 友好，代码也更容易压缩</p></li></ul> <blockquote><p>如果组件足够简单，还是可以使用 Options API 的</p></blockquote> <h2 id="vnode-到真实-dom-是如何转变的"><a href="#vnode-到真实-dom-是如何转变的" class="header-anchor">#</a> vnode 到真实 DOM 是如何转变的</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 在 Vue.js 3.0 中，初始化一个应用的方式如下</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./app'</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p>createApp 内部做了两件事，返回 app 对象</p> <ul><li><p>ensureRenderer().createApp() 来创建 app 对象</p> <blockquote><p>用 ensureRenderer() 来延时创建渲染器，这样做的好处是当用户只依赖响应式包的时候，就不会创建渲染器，因此可以通过 tree-shaking 的方式移除核心渲染逻辑相关的代码</p></blockquote></li> <li><p>重写 app.mount 方法</p> <blockquote><p>为什么重写？因为 Vue.js 不仅仅是为 Web 平台服务，它的目标是支持跨平台渲染，而 createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程（先创建 vnode，再渲染 vnode），也就是说这些代码的执行逻辑都是与平台无关的。因此我们需要在外部重写这个方法，来完善 Web 平台下的渲染逻辑。</p></blockquote></li></ul></li> <li><p>app.mount 内部标准化容器之后进行标准的渲染流程</p> <ul><li>首先是通过 normalizeContainer 标准化容器（这里可以传字符串选择器或者 DOM 对象，但如果是字符串选择器，就需要把它转成 DOM 对象，作为最终挂载的容器）</li> <li>if 判断，如果组件对象没有定义 render 函数和 template 模板，则取容器的 innerHTML 作为组件模板内容</li> <li>在挂载前清空容器内容，最终再调用 mount 方法走标准的组件渲染流程</li></ul></li> <li><p>标准渲染流程内部先创建 vnode，然后渲染 vnode</p> <ul><li><p>创建 vnode</p> <ul><li>调用 createVNode 函数，对 props 做标准化处理、对 vnode 的类型信息编码、创建 vnode 对象，标准化子节点 children</li></ul></li> <li><p>渲染 vnode</p> <ul><li><p>调用 render 函数，如果它的第一个参数 vnode 为空，则执行销毁组件的逻辑，否则执行创建或者更新组件的逻辑</p></li> <li><p>render 内部调用了 patch 函数，这个函数有两个功能，一个是根据 vnode 挂载 DOM，一个是根据新旧 vnode 更新 DOM</p></li> <li><p>patch 内部根据节点类型执行对应的渲染逻辑</p> <ul><li><p>组件渲染逻辑</p> <ul><li>执行 processComponent，该函数的逻辑很简单，如果 参数 1 为 null，则执行挂载组件的逻辑，否则执行更新组件的逻辑。</li> <li>processComponent 内部调用 mountComponent 函数挂载组件，这个函数主要做三件事情：创建组件实例、设置组件实例、设置并运行带副作用的渲染函数。
<ul><li>创建组件实例：内部通过对象的方式去创建了当前渲染的组件实例</li> <li>设置组件实例，instance 保留了很多组件相关的数据，维护了组件的上下文，包括对 props、插槽，以及其他实例的属性的初始化处理</li> <li>运行带副作用的渲染函数 setupRenderEffect，该函数利用响应式库的 effect 函数创建了一个副作用渲染函数 <strong><u>componentEffect</u></strong> 。<strong>副作用</strong>，这里你可以简单地理解为，<strong>当组件的数据发生变化时，effect 函数包裹的内部渲染函数 componentEffect 会重新执行一遍，从而达到重新渲染组件的目的</strong> <ul><li>渲染函数内部也会判断这是一次<strong>初始渲染</strong>还是<strong>组件更新</strong>。</li> <li><strong>初始渲染主要做两件事情：渲染组件生成 subTree、把 subTree 挂载到 container 中。</strong></li> <li>每个组件都会有对应的 render 函数，即使你写 template，也会编译成 render 函数，而 renderComponentRoot 函数就是去执行 render 函数创建整个组件树内部的 vnode，把这个 vnode 再经过内部一层标准化，就得到了该函数的返回结果：子树 vnode（也就是 subTree）。</li> <li>渲染生成子树 vnode 后，接下来就是继续<strong>调用 patch 函数</strong>把子树 vnode 挂载到 container 中了。</li> <li>那么我们又再次回到了 patch 函数，会继续对这个子树 vnode 类型进行判断，如果对应的子树 vnode 是一个普通元素 vnode，那么就执行<strong>普通元素渲染逻辑</strong></li></ul></li></ul></li></ul></li> <li><p>普通元素渲染逻辑</p> <ul><li><p>执行 processElement，该函数的逻辑很简单，如果 参数 1 为 null，走挂载元素节点的逻辑，否则走更新元素节点逻辑。</p></li> <li><p>processElement 内部调用 mountElement 函数挂载元素，这个函数主要做四件事：创建 DOM 元素节点、处理 props、处理 children、挂载 DOM 元素到 container 上</p> <ul><li><p>创建 DOM 元素节点，通过 hostCreateElement 方法创建，这个方法跟平台相关，在 web 平台下，它本质是调用底层的 DOM API document.createElement 创建元素，这些平台相关的方法是在<strong>创建渲染器阶段作为参数传入的</strong></p></li> <li><p>处理 props，如果有 props 的话，给这个 DOM 节点添加相关的 class、style、event 等属性，并做相关的处理，这些逻辑都是在 hostPatchProp 函数内部做的</p></li> <li><p>处理 children，处理纯文本和数组的情况</p> <ul><li><p>如果子节点是纯文本，则执行 hostSetElementText 方法，它在 Web 环境下通过设置 DOM 元素的 textContent 属性设置文本</p></li> <li><p>如果子节点是数组，则执行 mountChildren 方法，函数内部会遍历 children 获取到每一个 child，然后递归<strong>执行 patch 方法</strong>挂载每一个 child 。注意，<strong>这里有对 child 做预处理的情况，属于编译优化的内容</strong></p> <blockquote><p>为什么是 patch？不是 mountElement？因为子节点可能有其他类型的 vnode，比如组件 vnode。</p></blockquote></li></ul></li> <li><p>挂载 DOM 元素到 container 上，调用 hostInsert 方法，在 web 平台下，该函数内部会做一个 if 判断，如果有参考元素 anchor，就执行 parent.insertBefore ，否则执行 parent.appendChild 来把 child 添加到 parent 下，完成节点的挂载</p></li></ul></li></ul></li> <li><p>TELEPORT 组件</p></li> <li><p>SUSPENSE 组件</p></li></ul></li></ul></li></ul></li></ul> <p>大致流程：</p> <img src="https://blog-images-1302031947.cos.ap-guangzhou.myqcloud.com/images/image-20220305192359860.png" alt="image-20220305192359860" style="zoom:67%;"> <p>主要函数调用大致流程：</p> <p>createApp =&gt; mount =&gt; normalizeContainer =&gt; createVNode =&gt; render =&gt; patch =&gt;</p> <ul><li>processComponent =&gt; mountComponent =&gt; setupRenderEffect =&gt; patch</li> <li>processElement =&gt; mountElement =&gt; mountChilden =&gt; patch</li></ul> <h2 id="完整的-dom-diff-流程是怎样的"><a href="#完整的-dom-diff-流程是怎样的" class="header-anchor">#</a> 完整的 DOM diff 流程是怎样的</h2> <p>回顾带副作用渲染函数 <code>setupRenderEffect</code>创建的<code>componentEffect</code>函数，组件数据变化的时候会触发<code>componentEffect</code>，函数内部通过<code>instance.isMounted</code>判断是渲染组件还是更新组件，由于我们关注的是更新组件，这里关注更新组件的流程，更新组件主要做三件事情：<strong>更新组件 vnode 节点、渲染新的子树 vnode、根据新旧子树 vnode 执行 patch 逻辑</strong>。</p> <ul><li><p>更新组件 vnode 节点，这里会有一个条件判断，判断组件实例中是否有新的组件 vnode（用 next 表示），有则调用<code>updateComponentPreRender</code>去更新组件 vnode 节点信息，包括<strong>更改组件实例的 vnode 指针、更新 props 和更新插槽等一系列操作</strong>，没有 则 next 指向之前的组件 vnode</p></li> <li><p>渲染新的子树 vnode，调用<code>renderComponentRoot</code>函数去渲染新的子树 vnode，因为数据发生了变化，模板又和数据相关，所以渲染生成的子树 vnode 也会发生相应的变化</p></li> <li><p>执行 patch 逻辑，用来找出新旧子树 vnode 的不同，并找到一种合适的方式更新 DOM</p> <ul><li><p>首先判断新旧节点是否是相同的 vnode 类型，如果不同，销毁旧节点，挂载新节点，如果是相同的 vnode 类型，就需要走 diff 更新流程了</p> <blockquote><p>节点的 type 和 key 都相同，才是相同节点</p></blockquote></li> <li><p>挂载新节点和走 diff 流程都是通过调用<code>processElement</code>或<code>processComponent</code>函数</p> <blockquote><p>挂载组件调用<code>processComponent(n1 = null,n2)</code></p> <p>更新组件调用<code>processComponent(n1,n2)</code></p> <p>挂载普通元素调用<code>processElement(n1 = null,n2)</code></p> <p>更新普通元素调用<code>processElement(n1,n2)</code></p></blockquote></li> <li><p>如果是更新组件，走<code>processComponent</code>，更新组件的过程主要做两件事情：判断是否需要更新子组件，触发子组件的更新函数</p> <ul><li><code>processComponent</code>函数内部执行 <code>updateComponent</code> 函数来更新子组件，</li> <li>updateComponent 函数在更新子组件的时候，会先执行 shouldUpdateComponent 函数，根据新旧子组件 vnode 来判断是否需要更新子组件</li> <li>在 shouldUpdateComponent 函数的内部，主要是通过检测和<strong>对比组件 vnode 中的 props、chidren、dirs、transiton 等属性</strong>，来<strong>决定子组件是否需要更新</strong></li> <li>如果 <code>shouldUpdateComponent</code> 返回 true ，先执行 <code>invalidateJob（instance.update）</code>避免子组件由于自身数据变化导致的重复更新</li> <li>然后又执行了子组件的副作用渲染函数 <code>instance.update</code> 来主动触发子组件的更新</li></ul></li> <li><p>如果是更新普通元素，走<code>processElement</code>，更新元素的过程主要做两件事情：更新 props 和更新子节点</p> <ul><li><code>processElement</code>函数内部通过调用<code>patchProps</code>来更新<code>props</code>，接着调用<code>patchChildren</code>更新子节点</li> <li><code>patchProps</code> 函数就是在更新 DOM 节点的 class、style、event 以及其它的一些 DOM 属性</li> <li><code>patchChildren</code>函数内部根据子节点的情况去更新</li> <li>如果旧子节点是纯文本，新子节点是纯文本，新旧文本替换</li> <li>如果旧子节点是纯文本，新子节点是空，删除旧子节点</li> <li>如果旧子节点是纯文本，新子节点是数组，清空旧文本，添加新子节点</li> <li>如果旧子节点是空，新子节点是纯文本，添加新文本</li> <li>如果旧子节点是空，新子节点是空，什么都不需要做</li> <li>如果旧子节点是空，新子节点是数组，添加新字节点</li> <li>如果旧子节点是数组，新子节点是纯文本，删除旧子节点，添加新文本</li> <li>如果旧子节点是数组，新子节点是空，删除旧子节点</li> <li>如果旧子节点是数组，新子节点是数组，diff 算法</li></ul></li></ul></li></ul> <h3 id="diff-算法流程"><a href="#diff-算法流程" class="header-anchor">#</a> diff 算法流程</h3> <ol><li>同步头部索引<code>i</code></li> <li>同步头部节点就是从头部开始，依次对比新节点和旧节点，如果它们相同的则执行 patch 更新节点；如果<strong>不同</strong>或者<strong>索引 i 大于索引 e1 或者 e2</strong>，则同步过程结束。</li> <li>同步旧子节点数组的尾部索引<code>e1</code>，新子节点数组的尾部索引<code>e2</code></li> <li>同步尾部节点就是从尾部开始，依次对比新节点和旧节点，如果相同的则执行 patch 更新节点；如果<strong>不同</strong>或者<strong>索引 i 大于索引 e1 或者 e2</strong>，则同步过程结束。</li> <li>同步完成有三种情况</li> <li>如果<code>i &gt; e1</code>且<code>i &lt;= e2</code>,说明需要挂载剩余的新节点</li> <li>如果<code>i &gt; e2</code>且<code>i &lt;= e1</code>,说明需要删除多余的旧节点</li> <li>都不满足的话，根据 key 建立新子序列的索引图<code>keyToNewIndexMap</code>，<code>keyToNewIndexMap</code> 存储的就是新子序列中每个节点在新子序列中的索引</li> <li>正序遍历旧子序列，根据前面建立的 <code>keyToNewIndexMap</code> 查找旧子序列中的节点在新子序列中的索引，如果找不到就说明新子序列中没有该节点，就删除它；如果找得到则将它在旧子序列中的索引更新到 <code>newIndexToOldIndexMap</code><strong>数组</strong>中</li> <li>注意这里索引加了长度为 1 的偏移，是为了应对 i 为 0 的特殊情况，如果不这样处理就会影响后续求解最长递增子序列。</li> <li>遍历过程中，用变量 maxNewIndexSoFar 跟踪判断节点是否移动，maxNewIndexSoFar 始终存储的是上次求值的 newIndex，一旦本次求值的 newIndex 小于 maxNewIndexSoFar，这<strong>说明顺序遍历旧子序列的节点在新子序列中的索引并不是一直递增</strong>的，也就说明<strong>存在移动</strong>的情况。</li> <li>除此之外，这个过程中也会更新新旧子序列中匹配的节点，另外如果所有新的子序列节点都已经更新，而对旧子序列遍历还未结束，说明剩余的节点就是多余的，删除即可。</li> <li>至此，完成了<strong>新旧子序列节点的更新</strong>、<strong>多余旧节点的删除</strong>，并且<strong>建立了一个 newIndexToOldIndexMap 存储新子序列节点的索引和旧子序列节点的索引之间的映射关系</strong>，并<strong>确定是否有移动</strong>。</li> <li>如果 moved 为 true 就通过 <strong>getSequence(newIndexToOldIndexMap)</strong> 计算最长递增子序列</li> <li>接着采用<strong>倒序的方式遍历新子序列</strong>，因为倒序遍历可以方便使用最后更新的节点作为锚点。在倒序的过程中，锚点指向上一个更新的节点，然后判断 <code>newIndexToOldIndexMap[i]</code> 是否为 0，如果是则表示这是新节点，就需要挂载它；接着判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果在则倒序最长递增子序列，否则把它移动到锚点的前面。</li></ol> <h2 id="setup-组件渲染前的初始化流程是怎样的"><a href="#setup-组件渲染前的初始化流程是怎样的" class="header-anchor">#</a> setup 组件渲染前的初始化流程是怎样的</h2> <p>初始化组件，创建组件实例，设置组件实例，初始化 props，初始化 slots，设置有状态的组件实例，创建渲染上下文代理，创建 setup 函数上下文，执行 setup 函数获取结果，处理 setup 函数的执行结果，完成组件实例设置，初始化模板或者渲染函数，兼容 optionsAPI</p> <h2 id="为什么需要创建渲染上下文代理"><a href="#为什么需要创建渲染上下文代理" class="header-anchor">#</a> 为什么需要创建渲染上下文代理</h2> <p>在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props 求值后的数据，实际上存储在 <code>this._props</code> 上，而 data 中定义的数据存储在 <code>this._data</code> 上。在初始化组件的时候，data 中定义的 属性 在组件内部是存储在 <code>this._data</code> 上的，而模板渲染的时候访问 <code>this.xxx</code>，实际上访问的是 <code>this._data.xxx</code>，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。</p> <p>到了 Vue.js 3.0，为了方便维护，把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 instance.ctx 中的属性，所以我们也要做一层 proxy，<strong>对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改</strong>。</p> <h2 id="研究-publicinstanceproxyhandlers"><a href="#研究-publicinstanceproxyhandlers" class="header-anchor">#</a> 研究 PublicInstanceProxyHandlers</h2> <p>PublicInstanceProxyHandlers 是创建渲染上下文代理的时候用到的，作为传入 new Proxy 的 handler 对象，定义了 get 和 set</p> <h3 id="渲染上下文中的访问优先级"><a href="#渲染上下文中的访问优先级" class="header-anchor">#</a> 渲染上下文中的访问优先级</h3> <p>PublicInstanceProxyHandlers 的 get 函数中首先判断 key 是否以$开头</p> <p>不以<code>$</code>开头的 key 可能是访问 setupState、data、props、ctx</p> <p>判断优先级为 setupState &gt; data &gt; props &gt; ctx</p> <p>也就是说，当上述对象 key 值相同的时候，会优先访问 setup 中定义的 key，其次是 data，接着是 props，最后是 ctx</p> <p>以<code>$</code>开头的 key 可能是访问 vue 内部公开的<code>$xxx</code>属性或者方法，vue-loader 编译注入的 css 模块内部的 key，用户自定义以<code>$</code>开头的 key，全局属性</p> <p>判断优先级为 vue 内部公开的<code>$xxx</code>属性或者方法 &gt; vue-loader 编译注入的 css 模块内部的 key &gt; 用户自定义以<code>$</code>开头的 key &gt; 全局属性</p> <p>如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在 data 中定义的数据以 <code>$</code> 开头的警告，因为 <code>$</code>是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。</p> <p>set 函数在对 instance.ctx 中的属性修改时触发，触发判断顺序跟 get 一样，先判断 setupState，再判断 data，接着是 prop，最后是 ctx</p> <h2 id="vnode-有什么优势呢-为什么一定要设计-vnode-这样的数据结构呢"><a href="#vnode-有什么优势呢-为什么一定要设计-vnode-这样的数据结构呢" class="header-anchor">#</a> vnode 有什么优势呢？为什么一定要设计 vnode 这样的数据结构呢？</h2> <p>首先是<strong>抽象</strong>，引入 vnode，可以把渲染过程抽象化，从而使得组件的抽象能力也得到提升。</p> <p>其次是<strong>跨平台</strong>，因为 <code>patch vnode</code> 的过程不同平台可以有自己的实现，基于 <code>vnode</code> 再做服务端渲染、<code>Weex</code> 平台、小程序平台的渲染都变得容易了很多。</p> <blockquote><p>不过这里要特别注意，使用 <code>vnode</code> 并不意味着不用操作 DOM 了，很多同学会误以为 <code>vnode</code> 的性能一定比手动操作原生 DOM 好，这个其实是不一定的。</p> <p>因为，首先这种基于 <code>vnode</code> 实现的 <code>MVVM</code> 框架，在每次 <code>render to vnode</code> 的过程中，渲染组件会有一定的 JavaScript 耗时，特别是大组件，比如一个 1000 _ 10 的 Table 组件，<code>render to vnode</code> 的过程会遍历 1000 _ 10 次去创建内部 <code>cell vnode</code>，整个耗时就会变得比较长，加上 <code>patch vnode</code> 的过程也会有一定的耗时，当我们去更新组件的时候，用户会感觉到明显的卡顿。虽然 <code>diff</code> 算法在减少 DOM 操作方面足够优秀，但最终还是免不了操作 DOM，所以说性能并不是 <code>vnode</code> 的优势。</p></blockquote> <h2 id="平时开发页面就是把页面拆成一个个组件-那么组件的拆分粒度是越细越好吗-为什么呢"><a href="#平时开发页面就是把页面拆成一个个组件-那么组件的拆分粒度是越细越好吗-为什么呢" class="header-anchor">#</a> 平时开发页面就是把页面拆成一个个组件，那么组件的拆分粒度是越细越好吗？为什么呢？</h2> <p>并不是拆分粒度越小越好。</p> <p>原因：</p> <p>1、在我的日常开发中，有两种情况会去拆分组件，第一种是根据页面的布局或功能，将整个页面拆分成不同的模块组件，最后将这些模块组件拼起来形成页面；第二种是在实现第一部拆分出来的这些模块组件的时候，发现其中有一些模块组件具有相同或相似的功能点，将这些相似的功能点抽离出来写成公共组件，然后在各个模块中引用。无论是模块组件还是公共组件，拆分组件的出发点都和组件的大小粒度无关。可维护性和复用性才是拆分组件的出发点。</p> <p>2、对于组件的渲染，会先通过<code>renderComponentRoot</code>去生成组件的子树<code>vnode</code>，再递归 patch 去处理这个子树<code>vnode</code>。也就是说，对于同样一个 div，如果将其封装成组件的话，会比直接渲染一个 div 要多执行一次生成组件的子树<code>vnode</code>的过程。并且还要设置并运行带副作用的渲染函数。也就是说渲染组件比直接渲染元素要耗费更多的性能。如果组件过多，这些对应的过程就越多。如果按照组件粒度大小去划分组件的话会多出很多没有意义的渲染子树和设置并运行副作用函数的过程。</p> <p>综上所述，并不是拆分粒度越小越好，只要按照可维护性和复用性去划分组件就好。</p> <h2 id="vue-devtools-打开-editor-原理"><a href="#vue-devtools-打开-editor-原理" class="header-anchor">#</a> vue-devtools 打开 editor 原理</h2> <p>利用<code>nodejs</code>中的<code>child_process</code>，执行了类似<code>code path/to/file</code>命令，于是对应编辑器就打开了相应的文件，而对应的编辑器则是通过在进程中执行<code>ps x</code>（<code>Window</code>则用<code>Get-Process</code>）命令来查找的，当然也可以自己指定编辑器</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新:</span> <span class="time">4 小时前</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-press/technology/vue/开课吧架构笔记.html" class="prev">
        学习笔记
      </a></span> <span class="next"><a href="/blog-press/technology/vue/项目难点.html">
        项目难点
      </a>
      →
    </span></p></div>  <!----></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog-press/assets/js/app.6139d12d.js" defer></script><script src="/blog-press/assets/js/8.ae6c3984.js" defer></script><script src="/blog-press/assets/js/2.0264d6f2.js" defer></script><script src="/blog-press/assets/js/76.f5e7d6d7.js" defer></script><script src="/blog-press/assets/js/3.d809f9f2.js" defer></script>
  </body>
</html>
