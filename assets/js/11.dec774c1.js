(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{455:function(t,e,a){"use strict";a.r(e);var r=a(15),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#vue-的通信方式"}},[t._v("vue 的通信方式")])]),a("li",[a("a",{attrs:{href:"#tcp-三次连接和四次挥手"}},[t._v("TCP 三次连接和四次挥手")]),a("ul",[a("li",[a("a",{attrs:{href:"#为什么不能两次连接"}},[t._v("为什么不能两次连接")])]),a("li",[a("a",{attrs:{href:"#为什么不能三次挥手"}},[t._v("为什么不能三次挥手")])]),a("li",[a("a",{attrs:{href:"#为什么客户端要等待-2msl-时间"}},[t._v("为什么客户端要等待 2msl 时间")])])])]),a("li",[a("a",{attrs:{href:"#vue-生命周期"}},[t._v("vue 生命周期")]),a("ul",[a("li",[a("a",{attrs:{href:"#为什么异步请求放在-created-比较合适"}},[t._v("为什么异步请求放在 created 比较合适")])])])]),a("li",[a("a",{attrs:{href:"#vue-插槽原理"}},[t._v("vue 插槽原理")])]),a("li",[a("a",{attrs:{href:"#vue-router-原理"}},[t._v("vue-router 原理")])]),a("li",[a("a",{attrs:{href:"#执行上下文-作用域-链-vo-变量对象-this"}},[t._v("执行上下文(作用域/链,VO 变量对象,this)")])]),a("li",[a("a",{attrs:{href:"#vue2-x-和-vue3-x-的-diff-算法"}},[t._v("vue2.x 和 vue3.x 的 diff 算法")])]),a("li",[a("a",{attrs:{href:"#vue3-中-ref-reactive-readonly-等-api-实现"}},[t._v("vue3 中 ref，reactive，readonly 等 API 实现")])]),a("li",[a("a",{attrs:{href:"#grid-兼容性-能否用-float-实现-grid"}},[t._v("grid 兼容性，能否用 float 实现 grid？")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"vue-的通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的通信方式"}},[t._v("#")]),t._v(" vue 的通信方式")]),t._v(" "),a("p",[t._v("父子通信=>两种")]),t._v(" "),a("p",[t._v("隔代通信=>两种")]),t._v(" "),a("p",[t._v("兄弟通信=>两种")]),t._v(" "),a("h2",{attrs:{id:"tcp-三次连接和四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次连接和四次挥手"}},[t._v("#")]),t._v(" TCP 三次连接和四次挥手")]),t._v(" "),a("p",[t._v("了解 TCP 报文头，各种标志位含义")]),t._v(" "),a("h3",{attrs:{id:"为什么不能两次连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能两次连接"}},[t._v("#")]),t._v(" 为什么不能两次连接")]),t._v(" "),a("p",[t._v("前提：假设两次就能建立连接")]),t._v(" "),a("p",[t._v("原因一：无法确定双方的接收和发送能力")]),t._v(" "),a("p",[t._v("解释：")]),t._v(" "),a("p",[t._v("第一次，主机 A 发送，主机 B 收到，对于主机 B：确定了主机 A 有发送能力")]),t._v(" "),a("p",[t._v("第二次，主机 B 发送，主机 A 收到，对于主机 A：确定了主机 B 的发送能力和接收能力")]),t._v(" "),a("p",[t._v("可以发现，主机 B 无法确定主机 A 的接收能力")]),t._v(" "),a("p",[t._v("原因二：可能导致其中一方进入无限等待状态")]),t._v(" "),a("p",[t._v("解释：")]),t._v(" "),a("p",[t._v("第一次发送的数据包滞留了，主机 A 重发了一次，注意，此时旧的数据包对于主机 A 已经无法感知了")]),t._v(" "),a("p",[t._v("重发的这次连接很顺利，正常连接，正常挥手结束，此时主机 A 不再处于监听状态")]),t._v(" "),a("p",[t._v("就在这时，旧的数据包到了主机 B，由于主机 B 一直处于监听状态，会对该数据包进行回应，此时对于主机 B 来说，连接已经建立(因为前提是两次握手),但是主机 A 又不搭理主机 B，主机 B 就一直处于连接状态等待主机 A 发送资源(如果滞留了多个数据包，那么此时就有多个连接状态，但是都是处于无限等待状态)")]),t._v(" "),a("p",[t._v("刚刚假设的是旧数据包很久才到，那么如果旧数据包在重传新数据包之后，抢先在新数据包之前到达主机 B 呢？这个时候主机 B 正常应答发送数据包 ack=seq+1,主机 A 收到这个旧数据包了，但是发现 seq 对应不上新数据包的 seq，于是发送 RST 复位报文通知主机 B 放弃连接(可惜的是只有两次握手，因此这个通知无法到达主机 B，并且主机 B 在发送出 ack 包的时候就已经建立连接了)")]),t._v(" "),a("p",[t._v("因此：主机 B 很容易以为自己成功建立了多次连接，而主机 A 始终觉得自己只建立了一次连接(因为主机 A 可以根据 seq 来判断是不是最新的数据包)")]),t._v(" "),a("h3",{attrs:{id:"为什么不能三次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能三次挥手"}},[t._v("#")]),t._v(" 为什么不能三次挥手")]),t._v(" "),a("p",[t._v("服务端不能将 ACK 跟 FIN 同时发送，因为得预留一些时间将数据传输完毕")]),t._v(" "),a("h3",{attrs:{id:"为什么客户端要等待-2msl-时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么客户端要等待-2msl-时间"}},[t._v("#")]),t._v(" 为什么客户端要等待 2msl 时间")]),t._v(" "),a("p",[t._v("避免第三次挥手时客户端发送给服务端的 ACK 报文段接收不到，导致服务端一直关闭不了")]),t._v(" "),a("h2",{attrs:{id:"vue-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[t._v("#")]),t._v(" vue 生命周期")]),t._v(" "),a("p",[t._v("beforeCreate=>created=>beforeMount=>Mounted=>（beforeUpdate=>updated）=>beforeDestory=>Destroyed")]),t._v(" "),a("h3",{attrs:{id:"为什么异步请求放在-created-比较合适"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么异步请求放在-created-比较合适"}},[t._v("#")]),t._v(" 为什么异步请求放在 created 比较合适")]),t._v(" "),a("p",[t._v("一致性，因为服务端没有 mounted 和 beforeMount 生命周期钩子")]),t._v(" "),a("p",[t._v("在 created 发送请求，减少 loading 时间")]),t._v(" "),a("h2",{attrs:{id:"vue-插槽原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-插槽原理"}},[t._v("#")]),t._v(" vue 插槽原理")]),t._v(" "),a("h2",{attrs:{id:"vue-router-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-原理"}},[t._v("#")]),t._v(" vue-router 原理")]),t._v(" "),a("h2",{attrs:{id:"执行上下文-作用域-链-vo-变量对象-this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文-作用域-链-vo-变量对象-this"}},[t._v("#")]),t._v(" 执行上下文(作用域/链,VO 变量对象,this)")]),t._v(" "),a("h2",{attrs:{id:"vue2-x-和-vue3-x-的-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x-和-vue3-x-的-diff-算法"}},[t._v("#")]),t._v(" vue2.x 和 vue3.x 的 diff 算法")]),t._v(" "),a("h2",{attrs:{id:"vue3-中-ref-reactive-readonly-等-api-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-中-ref-reactive-readonly-等-api-实现"}},[t._v("#")]),t._v(" vue3 中 ref，reactive，readonly 等 API 实现")]),t._v(" "),a("h2",{attrs:{id:"grid-兼容性-能否用-float-实现-grid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grid-兼容性-能否用-float-实现-grid"}},[t._v("#")]),t._v(" grid 兼容性，能否用 float 实现 grid？")])])}),[],!1,null,null,null);e.default=v.exports}}]);